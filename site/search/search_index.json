{
    "docs": [
        {
            "location": "/", 
            "text": "Travaux Pratiques eServices\n\n\nCe(tte) \u0153uvre est mise \u00e0 disposition selon les termes de la \nLicence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International\n.\n\n\n\n\nGL5 - INSAT\n\n\n\n\n\n\nCours Disponible ici: \nhttp://liliasfaxi.wix.com/liliasfaxi/eservices\n\n\nPiazza : \nhttps://piazza.com/class/j3k0yr6cyex4n8\n\n\nRepo Github :  \nhttps://github.com/INSATunisia\n\n\n\n\nOverview\n\n\nVous trouverez sur mon \nsite officiel\n le cours Big Data associ\u00e9 \u00e0 ces TPs.L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures \u00e0 base de services en g\u00e9n\u00e9ral. Le cours va concerner principalement les points suivants:\n\n\n\n\nL'architecture orient\u00e9e services (SOA: Service-Oriented Architecture)\n\n\nLa composition de services: orchestration et chor\u00e9graphie\n\n\nLes bus de services (ESB: Enterprise Service Bus)\n\n\nLes Microservices\n\n\nLe API Management\n\n\nL'architecture orient\u00e9e web (WOA: Web-Oriented Architecture)\n\n\n\n\nCe cours comporte cinq s\u00e9ances de travaux pratiques:\n\n\n\n\nTP1\n: Manipulation des services SOAP et REST avec Talend\n\n\nTP2\n: Orchestration des services avec Camunda\n\n\nTP3\n: Mise en place d'un ESB avec Talend ESB\n\n\nTP4\n: Microservices avec Spring Boot et Spring Cloud\n\n\nTP5\n: API Management avec Anypoint", 
            "title": "Travaux Pratiques eServices"
        }, 
        {
            "location": "/#travaux-pratiques-eservices", 
            "text": "Ce(tte) \u0153uvre est mise \u00e0 disposition selon les termes de la  Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International .", 
            "title": "Travaux Pratiques eServices"
        }, 
        {
            "location": "/#gl5-insat", 
            "text": "Cours Disponible ici:  http://liliasfaxi.wix.com/liliasfaxi/eservices  Piazza :  https://piazza.com/class/j3k0yr6cyex4n8  Repo Github :   https://github.com/INSATunisia", 
            "title": "GL5 - INSAT"
        }, 
        {
            "location": "/#overview", 
            "text": "Vous trouverez sur mon  site officiel  le cours Big Data associ\u00e9 \u00e0 ces TPs.L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures \u00e0 base de services en g\u00e9n\u00e9ral. Le cours va concerner principalement les points suivants:   L'architecture orient\u00e9e services (SOA: Service-Oriented Architecture)  La composition de services: orchestration et chor\u00e9graphie  Les bus de services (ESB: Enterprise Service Bus)  Les Microservices  Le API Management  L'architecture orient\u00e9e web (WOA: Web-Oriented Architecture)   Ce cours comporte cinq s\u00e9ances de travaux pratiques:   TP1 : Manipulation des services SOAP et REST avec Talend  TP2 : Orchestration des services avec Camunda  TP3 : Mise en place d'un ESB avec Talend ESB  TP4 : Microservices avec Spring Boot et Spring Cloud  TP5 : API Management avec Anypoint", 
            "title": "Overview"
        }, 
        {
            "location": "/tp1/", 
            "text": "TP1 - Services Web REST et SOAP avec Talend\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\nCr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend.\n\n\nOutils et Versions\n\n\n\n\nTalend Open Studio for ESB\n Version: 6.3.0\n\n\nJava\n Version 1.8.0_121\n\n\nMySQL\n Version 14.14 Distrib 5.6.34\n\n\nSOAPUI\n Version 5.3.0\n\n\n\n\nTalend ESB\n\n\nTalend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services\n\nweb s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes.\n\nTalend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9\n\nApache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache\n\net a fait plusieurs contributions aux projets Apache.\n\nTalend fournit:\n\n\n\n\nUn courtier de messages \u00e0 haute performance.\n\n\nDes options de d\u00e9ploiement flexibles\n\n\nDes outils de d\u00e9veloppement pour Eclipse\n\n\nUne interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications\n\n\nSupport pour les services web SOAP et REST\n\n\nLa m\u00e9diation et le routage\n\n\nSupport pour le failover, le monitoring et la s\u00e9curit\u00e9\n\n\n\n\nL\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi.\n\nL\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox\n\ncomme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les\n\ndiff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es.\n\n\nTalend Open Studio for ESB\n\n\nTalend Open Studio for ESB (TOS-ESB) fournit une interface graphique de\n\nd\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des\n\napplications REST, des services de donn\u00e9es et des routes de messages.\n\nLe d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs\n\nrepr\u00e9sent\u00e9s dans cette figure:\n\n\n\n\n\n\nLe bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des\n\ndonn\u00e9es, des services ou des applications\n\n\nLes blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend\n\nd\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et\n\nd\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est\n\npossible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez\n\nbasculer gr\u00e2ce \u00e0 Talend Service Locator.\n\n\nLe bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les\n\ninformations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services.\n\n\n\n\nL\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit:\n\n\n\n\n\n\n\n\n\n\nComposant\n\n\nFonctionnalit\u00e9\n\n\n\n\n\n\n\n\n\n\n\n\nLe traditionnel \nRepository\n contenant vos Jobs, services, fichiers, routes\u2026\n\n\n\n\n\n\n\n\nLa fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes\n\n\n\n\n\n\n\n\nLa fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026\n\n\n\n\n\n\n\n\nLa palette des composants \u00e0 utiliser\n\n\n\n\n\n\n\n\nLes onglets pour le choix de la perspective \u00e0 utiliser\n\n\n\n\n\n\n\n\nService Web SOAP : Helloworld\n\n\nNous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des\n\nservices web avec les outils Talend ESB. Nous allons donc commencer avec le\n\ntraditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix.\n\nDans toute cette partie, nous nous trouverons dans la perspective Integration.\n\n\nCr\u00e9er le service SOAP\n\n\nPour cr\u00e9er un nouveau service de type SOAP:\n\n\n\n\nClic-droit sur \nServices\n de votre Repository, et choisir \nCreate Service\n. Appeler le\n\nservice \nHelloWorldService\n. Cliquer sur Suivant.\n\n\nOn vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer.\n\n\nUn service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est\n\ncr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche.\n\n\n\n\n\n\nConfigurer le service SOAP\n\n\nPour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord:\n\n\n\n\nImporter le WSDL de votre service dans votre repository. Pour cela, clic droit sur\n\n\nHelloWorldService\n, et choisir \nImporter les sch\u00e9mas WSDL\n. Vous retrouverez votre\n\nWSDL dans la partie \nMetadonn\u00e9es -\n Fichier XML\n.\n\n\nCr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration \nHelloWorldServiceOperation\n (sous Services) et choisir \nAssign Job\n.\n\n\nModifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le \ntLogRow\n nous permettra\n\nd\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au\n\nconsommateur):\n\n\n\n\n\n\n\n\n\n\nConfigurer votre tXMLMap pour que le \nin\n de la requ\u00eate soit transmise au \nout\n de la\n\nr\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela:\n\n\n\n\nDouble clic sur votre XML Map.\n\n\nClic-droit sur \npayload\n de l\u2019entr\u00e9e, et cliquer sur \nImport from Repository\n.\n\n\nChoisir le \nHelloWorldServiceOperationRequest\n correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9.\n\n\nRefaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant \nHelloWorldServiceOperationResponse\n.\n\n\nRelier le \nin\n de la requ\u00eate avec le \nout\n de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse)\n\n\nModifier l\u2019expression du \nout\n en ajoutant la cha\u00eene \n\u201cHello \u201c\n avant la valeur \nin\n de l\u2019entr\u00e9e.\n\n\nLe r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\nSauvegarder et quitter.\n\n\n\n\n\n\n\n\nLancer votre Job (cela permettra de publier votre service web sur le port 8090).\n\nV\u00e9rifier que votre fichier WSDL existe bien.\n\n\n\n\n\n\nTester le service SOAP\n\n\nIl est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9 \nSOAPUI\n.\n\n\n\n\nLancer SOAPUI\n\n\nCliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale\n\n\nDonner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit:\n\n\n\n\n\n\n\n\nDouble cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le \n?\n par un nom de votre choix.\n\n\nCliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:\n\n\n\n\n\n\nConsommateur du WebService SOAP\n\n\nNous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela:\n\n\n\n\nCr\u00e9er un nouveau Job, que vous appellerez \nHelloWorldServiceConsumer\n.\n\n\nConcevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante:\n\n\n\n\n\n\n\n\n\n\nVoici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 :\n\n\n\n\ntFixedFlowInput\n : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service\n\n\ntXMLMap\n : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service\n\n\ntESBConsumer\n : consommateur du service\n\n\ntLogRow\n: afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a)\n\n\n\n\n\n\n\n\nConfigurer votre composant \ntFixedFlowInput\n. Pour cela:\n\n\n\n\nCliquer sur \nModifier le sch\u00e9ma\n et ajouter une colonne appel\u00e9e \nNom\n de type \nString\n.\n\n\nUtiliser une \nInline Table\n pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d.\n\n\n\n\n\n\n\n\nConfigurer votre \ntESBConsumer\n en lui donnant comme WSDL celui du service que\n\nvous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090.\n\n\n\n\nConfigurer votre \ntXMLMap\n pour que la variable \nNom\n soit associ\u00e9e au \nin\n de votre\n\nservice.\n\n\nEx\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant:\n\n\n\n\n\n\nService Web REST : Interrogation d'une base de donn\u00e9es\n\n\nNous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es.\n\n\nCr\u00e9ation de la base de donn\u00e9es\n\n\nNous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e \neservices-tp1\n avec une table, que nous appellerons \nuser\n. Cette table contient les champs \nid\n, \nfirstname\n et \nlastname\n. Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es.\n\n\nElle devra ressembler \u00e0 ce qui suit:\n\n\n\n\nAjout de la connexion \u00e0 la base avec Talend\n\n\nPour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes:\n\n\n\n\nDans les M\u00e9tadonn\u00e9es, sous \nConnexions aux bases de donn\u00e9es\n, clic-droit, puis choisir: \nCr\u00e9er une connexion\n.\n\n\nConfigurer votre connexion. Voici un exemple:\n\n\n\n\n\n\n\n\nUne fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -\n Connexions... -\n \n et choisir: \nR\u00e9cup\u00e9rer le sch\u00e9ma\n.\n\n\nS\u00e9lectionner la table \nuser\n, et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma.\n\n\n\n\nCr\u00e9ation du service REST\n\n\nNous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera \nDBService\n, puis glisser les composants suivants:\n\n\n\n\ntRestRequest\n : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler\n\n\nuser\n : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous \nSch\u00e9mas des tables\n, glisser la table \nuser\n vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet.\n\n\n\n\n\n\nRemarque\n\n\nJe choisis \ntMySQLInput\n car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le \nInput\n).\n\n\n\n\n\n\ntFlowToIterate\n : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales.\n\n\ntXMLMap\n : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate.\n\n\ntRestResponse\n : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate.\n\n\ntLogRow\n : Pour le log, bien s\u00fbr.\n\n\n\n\nLe job aura l'allure suivante:\n\n\n\n\nConfiguration du service REST\n\n\nNous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI:\n\n\nhttp://localhost:8088/users?from=1\nto=3\n, le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3.\n\n\nConfiguration de tRestRequest\n\n\ntRestRequest devra \u00eatre configur\u00e9 comme suit:\n\n\n\n\nLa valeur de \nEndpoint URL\n devra \u00eatre: \nhttp://localhost:8088/users\n\n\nSi vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9 \ngetUsers\n, vous devriez le retrouver dans la case \nREST API Mapping\n. Sinon, cr\u00e9ez-le.\n\n\nGarder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON).\n\n\nEn cliquant sur \ngetUsers\n, un bouton avec trois petits points appara\u00eet. Cliquez dessus.\n\n\n\n\nAjouter les deux colonnes \nfrom\n et \nto\n repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que:\n\n\n\n\nLeur type soit \nint\n\n\nLeurs valeurs par d\u00e9faut soient respectivement 1 et 3.\n\n\n\n\n\n\nRemarque\n\n\nCes valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres.\n\n\n\n\n\n\nLeur commentaire ait la valeur: \nquery\n\n\n\n\n\n\nRemarque\n\n\nCela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path.\n\n\n\n\n\n\n\n\nConfiguration de user\n\n\nPuisque le composant \nuser\n a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires.\n\n\nIl suffira dans notre cas de:\n\n\n\n\nCliquer sur \nGuess Schema\n  pour charger le sch\u00e9ma de la base.\n\n\nChanger la requ\u00eate pour qu'elle soit comme suit:\n\n\n\n\nSELECT * FROM `user` where id\n=\n+\nglobalMap\n.\nget\n(\ngetUsers.from\n)\n+\n\n                      \n and id\n=\n+\nglobalMap\n.\nget\n(\ngetUsers.to\n)\n\n\n\n\n\n\n\nRemarque\n\n\nglobalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres.\n\n\n\n\nConfiguration de tXMLMap\n\n\nCliquer deux fois sur la \ntXMLMap\n pour la configurer.\n\n\n\n\nDans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e \nbody\n dont le type est \nDocument\n.\n\n\nCette colonne contient un \u00e9l\u00e9ment \nroot\n. Renommer cet \u00e9l\u00e9ment pour \nusers\n.\n\n\nAjouter un sous-\u00e9l\u00e9ment \u00e0 \nusers\n appel\u00e9 \nuser\n.\n\n\nD\u00e9finir cet \u00e9l\u00e9ment comme \nloop Element\n.\n\n\nGlisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le \nuser\n. Cr\u00e9ez-le comme attribut du noeud cible.\n\n\nDe m\u00eame pour le \nfirstname\n et \nlastname\n, qui seront, eux, des sous-\u00e9l\u00e9ments du noeud \nuser\n.\n\n\nDans la colonne de droite, cliquer sur la petite clef \u00e0 molette (\n). Mettre la valeur de \"All in one\" \u00e0 \ntrue\n. Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux.\n\n\n\n\nLa configuration finale sera donc comme suit:\n\n\n\n\n\n\nIndication\n\n\nLa configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante:\n\n\nusers\n\n  \nuser\n \nid=\n1\n\n    \nfirstname\n flen \n/firstname\n\n    \nlastname\n fouleni \n/lastname\n\n  \n/user\n\n  \nuser\n \nid=\n2\n\n    \nfirstname\n flena \n/firstname\n\n    \nlastname\n foulenia \n/lastname\n\n  \n/user\n\n\nusers\n\n\n\n\n\n\n\nLes autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur \nEx\u00e9cuter\n.\n\n\nTester le Service\n\n\nDans un navigateur\n\n\nPour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix.\n\n\nPar exemple, la requ\u00eate suivante : \nhttp://localhost:8088/users?from=2\nto=4\n donnera:\n\n\n  \nusers\n\n      \nuser\n \nid=\n2\n\n          \nfirstname\nSouad\n/firstname\n\n          \nlastname\nMezghenni\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n3\n\n          \nfirstname\nMourad\n/firstname\n\n          \nlastname\nLahwel\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n4\n\n          \nfirstname\nMonia\n/firstname\n\n          \nlastname\nLandolsi\n/lastname\n\n      \n/user\n\n  \n/users\n\n\n\nSi aucun param\u00e8tre n'est indiqu\u00e9: \nhttp://localhost:8088/users\n cela donnera:\n\n\n  \nusers\n\n      \nuser\n \nid=\n1\n\n          \nfirstname\nAhmed\n/firstname\n\n          \nlastname\nRamzi\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n2\n\n          \nfirstname\nSouad\n/firstname\n\n          \nlastname\nMezghenni\n/lastname\n\n      \n/user\n\n      \nuser\n \nid=\n3\n\n          \nfirstname\nMourad\n/firstname\n\n          \nlastname\nLahwel\n/lastname\n\n      \n/user\n\n  \n/users\n\n\n\n\n\nAvec SOAPUI\n\n\nTester le service SOAP\n\n\nIl est possible de tester votre service REST avec \nSOAPUI\n.\n\n\n\n\nLancer SOAPUI\n\n\nCliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale\n\n\nEntrer l'URI que vous d\u00e9sirez tester: \nhttp://localhost:8088/users?from=2\nto=4\n\n\nLa fen\u00eatre suivante devrait appara\u00eetre:\n\n\n\n\n\n\n\n\nCliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:\n\n\n\n\n\n\nConsommateur du WebService REST\n\n\nPour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant:\n\n\n\n\nConfigurer le \ntRestClient\n comme suit:\n\n\n\n\nEx\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:", 
            "title": "TP1 - Services Web REST et SOAP avec Talend"
        }, 
        {
            "location": "/tp1/#tp1-services-web-rest-et-soap-avec-talend", 
            "text": "", 
            "title": "TP1 - Services Web REST et SOAP avec Talend"
        }, 
        {
            "location": "/tp1/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp1/#objectifs-du-tp", 
            "text": "Cr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp1/#outils-et-versions", 
            "text": "Talend Open Studio for ESB  Version: 6.3.0  Java  Version 1.8.0_121  MySQL  Version 14.14 Distrib 5.6.34  SOAPUI  Version 5.3.0", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp1/#talend-esb", 
            "text": "Talend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services \nweb s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes. \nTalend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9 \nApache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache \net a fait plusieurs contributions aux projets Apache. \nTalend fournit:   Un courtier de messages \u00e0 haute performance.  Des options de d\u00e9ploiement flexibles  Des outils de d\u00e9veloppement pour Eclipse  Une interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications  Support pour les services web SOAP et REST  La m\u00e9diation et le routage  Support pour le failover, le monitoring et la s\u00e9curit\u00e9   L\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi. \nL\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox \ncomme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les \ndiff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es.", 
            "title": "Talend ESB"
        }, 
        {
            "location": "/tp1/#talend-open-studio-for-esb", 
            "text": "Talend Open Studio for ESB (TOS-ESB) fournit une interface graphique de \nd\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des \napplications REST, des services de donn\u00e9es et des routes de messages. \nLe d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs \nrepr\u00e9sent\u00e9s dans cette figure:    Le bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des \ndonn\u00e9es, des services ou des applications  Les blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend \nd\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et \nd\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est \npossible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez \nbasculer gr\u00e2ce \u00e0 Talend Service Locator.  Le bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les \ninformations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services.   L\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit:      Composant  Fonctionnalit\u00e9       Le traditionnel  Repository  contenant vos Jobs, services, fichiers, routes\u2026     La fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes     La fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026     La palette des composants \u00e0 utiliser     Les onglets pour le choix de la perspective \u00e0 utiliser", 
            "title": "Talend Open Studio for ESB"
        }, 
        {
            "location": "/tp1/#service-web-soap-helloworld", 
            "text": "Nous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des \nservices web avec les outils Talend ESB. Nous allons donc commencer avec le \ntraditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix. \nDans toute cette partie, nous nous trouverons dans la perspective Integration.", 
            "title": "Service Web SOAP : Helloworld"
        }, 
        {
            "location": "/tp1/#creer-le-service-soap", 
            "text": "Pour cr\u00e9er un nouveau service de type SOAP:   Clic-droit sur  Services  de votre Repository, et choisir  Create Service . Appeler le \nservice  HelloWorldService . Cliquer sur Suivant.  On vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer.  Un service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est \ncr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche.", 
            "title": "Cr\u00e9er le service SOAP"
        }, 
        {
            "location": "/tp1/#configurer-le-service-soap", 
            "text": "Pour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord:   Importer le WSDL de votre service dans votre repository. Pour cela, clic droit sur  HelloWorldService , et choisir  Importer les sch\u00e9mas WSDL . Vous retrouverez votre \nWSDL dans la partie  Metadonn\u00e9es -  Fichier XML .  Cr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration  HelloWorldServiceOperation  (sous Services) et choisir  Assign Job .  Modifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le  tLogRow  nous permettra \nd\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au \nconsommateur):      Configurer votre tXMLMap pour que le  in  de la requ\u00eate soit transmise au  out  de la \nr\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela:   Double clic sur votre XML Map.  Clic-droit sur  payload  de l\u2019entr\u00e9e, et cliquer sur  Import from Repository .  Choisir le  HelloWorldServiceOperationRequest  correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9.  Refaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant  HelloWorldServiceOperationResponse .  Relier le  in  de la requ\u00eate avec le  out  de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse)  Modifier l\u2019expression du  out  en ajoutant la cha\u00eene  \u201cHello \u201c  avant la valeur  in  de l\u2019entr\u00e9e.  Le r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit:     Sauvegarder et quitter.     Lancer votre Job (cela permettra de publier votre service web sur le port 8090). \nV\u00e9rifier que votre fichier WSDL existe bien.", 
            "title": "Configurer le service SOAP"
        }, 
        {
            "location": "/tp1/#tester-le-service-soap", 
            "text": "Il est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9  SOAPUI .   Lancer SOAPUI  Cliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale  Donner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit:     Double cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le  ?  par un nom de votre choix.  Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:", 
            "title": "Tester le service SOAP"
        }, 
        {
            "location": "/tp1/#consommateur-du-webservice-soap", 
            "text": "Nous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela:   Cr\u00e9er un nouveau Job, que vous appellerez  HelloWorldServiceConsumer .  Concevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante:      Voici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 :   tFixedFlowInput  : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service  tXMLMap  : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service  tESBConsumer  : consommateur du service  tLogRow : afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a)     Configurer votre composant  tFixedFlowInput . Pour cela:   Cliquer sur  Modifier le sch\u00e9ma  et ajouter une colonne appel\u00e9e  Nom  de type  String .  Utiliser une  Inline Table  pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d.     Configurer votre  tESBConsumer  en lui donnant comme WSDL celui du service que \nvous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090.   Configurer votre  tXMLMap  pour que la variable  Nom  soit associ\u00e9e au  in  de votre \nservice.  Ex\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant:", 
            "title": "Consommateur du WebService SOAP"
        }, 
        {
            "location": "/tp1/#service-web-rest-interrogation-dune-base-de-donnees", 
            "text": "Nous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es.", 
            "title": "Service Web REST : Interrogation d'une base de donn\u00e9es"
        }, 
        {
            "location": "/tp1/#creation-de-la-base-de-donnees", 
            "text": "Nous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e  eservices-tp1  avec une table, que nous appellerons  user . Cette table contient les champs  id ,  firstname  et  lastname . Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es.  Elle devra ressembler \u00e0 ce qui suit:", 
            "title": "Cr\u00e9ation de la base de donn\u00e9es"
        }, 
        {
            "location": "/tp1/#ajout-de-la-connexion-a-la-base-avec-talend", 
            "text": "Pour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes:   Dans les M\u00e9tadonn\u00e9es, sous  Connexions aux bases de donn\u00e9es , clic-droit, puis choisir:  Cr\u00e9er une connexion .  Configurer votre connexion. Voici un exemple:     Une fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -  Connexions... -    et choisir:  R\u00e9cup\u00e9rer le sch\u00e9ma .  S\u00e9lectionner la table  user , et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma.", 
            "title": "Ajout de la connexion \u00e0 la base avec Talend"
        }, 
        {
            "location": "/tp1/#creation-du-service-rest", 
            "text": "Nous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera  DBService , puis glisser les composants suivants:   tRestRequest  : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler  user  : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous  Sch\u00e9mas des tables , glisser la table  user  vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet.    Remarque  Je choisis  tMySQLInput  car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le  Input ).    tFlowToIterate  : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales.  tXMLMap  : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate.  tRestResponse  : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate.  tLogRow  : Pour le log, bien s\u00fbr.   Le job aura l'allure suivante:", 
            "title": "Cr\u00e9ation du service REST"
        }, 
        {
            "location": "/tp1/#configuration-du-service-rest", 
            "text": "Nous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI:  http://localhost:8088/users?from=1 to=3 , le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3.", 
            "title": "Configuration du service REST"
        }, 
        {
            "location": "/tp1/#configuration-de-trestrequest", 
            "text": "tRestRequest devra \u00eatre configur\u00e9 comme suit:   La valeur de  Endpoint URL  devra \u00eatre:  http://localhost:8088/users  Si vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9  getUsers , vous devriez le retrouver dans la case  REST API Mapping . Sinon, cr\u00e9ez-le.  Garder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON).  En cliquant sur  getUsers , un bouton avec trois petits points appara\u00eet. Cliquez dessus.   Ajouter les deux colonnes  from  et  to  repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que:   Leur type soit  int  Leurs valeurs par d\u00e9faut soient respectivement 1 et 3.    Remarque  Ces valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres.    Leur commentaire ait la valeur:  query    Remarque  Cela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path.", 
            "title": "Configuration de tRestRequest"
        }, 
        {
            "location": "/tp1/#configuration-de-user", 
            "text": "Puisque le composant  user  a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires.  Il suffira dans notre cas de:   Cliquer sur  Guess Schema   pour charger le sch\u00e9ma de la base.  Changer la requ\u00eate pour qu'elle soit comme suit:   SELECT * FROM `user` where id = + globalMap . get ( getUsers.from ) + \n                        and id = + globalMap . get ( getUsers.to )    Remarque  globalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres.", 
            "title": "Configuration de user"
        }, 
        {
            "location": "/tp1/#configuration-de-txmlmap", 
            "text": "Cliquer deux fois sur la  tXMLMap  pour la configurer.   Dans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e  body  dont le type est  Document .  Cette colonne contient un \u00e9l\u00e9ment  root . Renommer cet \u00e9l\u00e9ment pour  users .  Ajouter un sous-\u00e9l\u00e9ment \u00e0  users  appel\u00e9  user .  D\u00e9finir cet \u00e9l\u00e9ment comme  loop Element .  Glisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le  user . Cr\u00e9ez-le comme attribut du noeud cible.  De m\u00eame pour le  firstname  et  lastname , qui seront, eux, des sous-\u00e9l\u00e9ments du noeud  user .  Dans la colonne de droite, cliquer sur la petite clef \u00e0 molette ( ). Mettre la valeur de \"All in one\" \u00e0  true . Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux.   La configuration finale sera donc comme suit:    Indication  La configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante:  users \n   user   id= 1 \n     firstname  flen  /firstname \n     lastname  fouleni  /lastname \n   /user \n   user   id= 2 \n     firstname  flena  /firstname \n     lastname  foulenia  /lastname \n   /user  users    Les autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur  Ex\u00e9cuter .", 
            "title": "Configuration de tXMLMap"
        }, 
        {
            "location": "/tp1/#tester-le-service", 
            "text": "", 
            "title": "Tester le Service"
        }, 
        {
            "location": "/tp1/#dans-un-navigateur", 
            "text": "Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix.  Par exemple, la requ\u00eate suivante :  http://localhost:8088/users?from=2 to=4  donnera:     users \n       user   id= 2 \n           firstname Souad /firstname \n           lastname Mezghenni /lastname \n       /user \n       user   id= 3 \n           firstname Mourad /firstname \n           lastname Lahwel /lastname \n       /user \n       user   id= 4 \n           firstname Monia /firstname \n           lastname Landolsi /lastname \n       /user \n   /users  \nSi aucun param\u00e8tre n'est indiqu\u00e9:  http://localhost:8088/users  cela donnera:     users \n       user   id= 1 \n           firstname Ahmed /firstname \n           lastname Ramzi /lastname \n       /user \n       user   id= 2 \n           firstname Souad /firstname \n           lastname Mezghenni /lastname \n       /user \n       user   id= 3 \n           firstname Mourad /firstname \n           lastname Lahwel /lastname \n       /user \n   /users", 
            "title": "Dans un navigateur"
        }, 
        {
            "location": "/tp1/#avec-soapui", 
            "text": "", 
            "title": "Avec SOAPUI"
        }, 
        {
            "location": "/tp1/#tester-le-service-soap_1", 
            "text": "Il est possible de tester votre service REST avec  SOAPUI .   Lancer SOAPUI  Cliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale  Entrer l'URI que vous d\u00e9sirez tester:  http://localhost:8088/users?from=2 to=4  La fen\u00eatre suivante devrait appara\u00eetre:     Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:", 
            "title": "Tester le service SOAP"
        }, 
        {
            "location": "/tp1/#consommateur-du-webservice-rest", 
            "text": "Pour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant:   Configurer le  tRestClient  comme suit:   Ex\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:", 
            "title": "Consommateur du WebService REST"
        }, 
        {
            "location": "/tp2/", 
            "text": "TP2 - Orchestration de Services avec Camunda\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\nCr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.\n\n\nOutils et Versions\n\n\n\n\nCamunda\n Version: 7.7.0\n\n\nJava\n Version 1.8.0_121 (7+ needed).\n\n\nIntelliJ IDEA\n Version Ultimate 2016.1 (ou tout autre IDE de votre choix)\n\n\nCamunda Modeler\n Version 1.10.0\n\n\n\n\nCamunda \n\n\nCamunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support \nBPMN\n pour l'automatisation des processus, \nCMMN\n pour le Case Management, et \nDMN\n pour le Business Decision Management.\n\n\nBPMN 2.0 \n\n\nBPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group (\nOMG\n) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations.\n\n\nDans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier.\n\n\nCette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.\n\n\nInstallation\n\n\nPour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes:\n\n\n\n\nT\u00e9l\u00e9charger \nCamunda\n (Distribution Tomcat), \nIntelliJ IDEA\n et \nCamunda Modeler\n.\n\n\nD\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter \nstart-camunda.sh\n (pour les syst\u00e8mes Unix-based) ou \nstart-camunda.bat\n (pour les syst\u00e8mes Windows).\n\n\nOuvrir la page d'accueil du serveur d'application dans votre navigateur pr\u00e9f\u00e9r\u00e9.\n\n\nLancer le Camunda Modeler.\n\n\n\n\nPremier Projet Camunda BPMN: Helloworld\n\n\nCr\u00e9ation du Projet et D\u00e9pendances\n\n\nVous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus.\n\n\n\n\nOuvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype).\n\n\n\n\nVous pouvez choisir les param\u00e8tres suivants:\n\n\n\n\nGroup Id: \ntn.insat.eservices.tp2\n\n\nArtifact Id: \nHelloworld\n\n\nProject Name: \nHelloworldCamunda\n\n\n\n\n\n\n\n\nDans le fichier \npom.xml\n, indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier \nwar\n. Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version:\n\n\n\n\n\n\npackaging\nwar\n/packaging\n\n\n\n\n\n\n\nAjouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier \npom.xml\n\n\n\n\ndependencyManagement\n\n    \ndependencies\n\n      \ndependency\n\n        \ngroupId\norg.camunda.bpm\n/groupId\n\n        \nartifactId\ncamunda-bom\n/artifactId\n\n        \nversion\n7.7.0\n/version\n\n        \nscope\nimport\n/scope\n\n        \ntype\npom\n/type\n\n      \n/dependency\n\n    \n/dependencies\n\n  \n/dependencyManagement\n\n\n  \ndependencies\n\n    \ndependency\n\n      \ngroupId\norg.camunda.bpm\n/groupId\n\n      \nartifactId\ncamunda-engine\n/artifactId\n\n      \nscope\nprovided\n/scope\n\n    \n/dependency\n\n\n    \ndependency\n\n      \ngroupId\njavax.servlet\n/groupId\n\n      \nartifactId\njavax.servlet-api\n/artifactId\n\n      \nversion\n3.0.1\n/version\n\n      \nscope\nprovided\n/scope\n\n    \n/dependency\n\n  \n/dependencies\n\n\n  \nbuild\n\n    \nplugins\n\n      \nplugin\n\n        \ngroupId\norg.apache.maven.plugins\n/groupId\n\n        \nartifactId\nmaven-war-plugin\n/artifactId\n\n        \nversion\n2.3\n/version\n\n        \nconfiguration\n\n          \nfailOnMissingWebXml\nfalse\n/failOnMissingWebXml\n\n        \n/configuration\n\n      \n/plugin\n\n    \n/plugins\n\n  \n/build\n\n\n\n\n\n\n\nFaire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez \nmaven-install\n par exemple, et vous \u00e9crirez dans la partie \nCommand Line\n : \ninstall\n, comme suit:\n\n\n\n\n\n\n\n\nLancer le build et v\u00e9rifiez bien que vos packages ont bien \u00e9t\u00e9 install\u00e9s.\n\n\n\n\nCr\u00e9ation de la classe principale pour le processus\n\n\nLa prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda.\n\n\npackage\n \ntn.insat.eservices.tp2.helloworld\n;\n\n\n\nimport\n \norg.camunda.bpm.application.ProcessApplication\n;\n\n\nimport\n \norg.camunda.bpm.application.impl.ServletProcessApplication\n;\n\n\n\n@ProcessApplication\n(\nHelloworld App\n)\n\n\npublic\n \nclass\n \nHelloworldApplication\n \nextends\n \nServletProcessApplication\n \n{\n\n    \n// empty implementation\n\n\n}\n\n\n\n\n\nAjouter ensuite le fichier \nprocesses.xml\n sous le r\u00e9pertoire \nsrc/main/resources/META-INF\n. Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus.\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n ?\n\n\nprocess-application\n\n        \nxmlns=\nhttp://www.camunda.org/schema/1.0/ProcessApplication\n\n        \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \nprocess-archive\n \nname=\nhelloworld\n\n        \nprocess-engine\ndefault\n/process-engine\n\n        \nproperties\n\n            \nproperty\n \nname=\nisDeleteUponUndeploy\nfalse\n/property\n\n            \nproperty\n \nname=\nisScanForProcessDefinitions\ntrue\n/property\n\n        \n/properties\n\n    \n/process-archive\n\n\n\n/process-application\n\n\n\n\n\nA partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus.\n\n\nMod\u00e9lisation d'un processus BPMN 2.0\n\n\nLa mod\u00e9lisation du processus se fera gr\u00e2ce au \nCamunda Modeler\n. Pour cela:\n\n\n\n\nD\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN en cliquant sur \nFile \n New File \n BPMN Diagram\n.\n\n\n\n\n\n\n\n\nDouble-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons \nDis Bonjour\n.\n\n\nCliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 \nAjouter Bonjour\n.\n\n\n\n\n\n\n\n\nCette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel \nBonjour \nnom>!\n. Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir \nUser Task\n.\n\n\n\n\n\n\n\n\nRajouter une t\u00e2che de fin au processus.\n\n\n\n\nNous obtenons pour finir le diagramme suivant:\n\n\n\n\nConfiguration du processus\n\n\n\n\nPour configurer la t\u00e2che utilisateur \nAjouter Bonjour\n, cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). D\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ \nAssignee\n, ins\u00e9rer \njohn\n. John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les.\n\n\nPour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants:\n\n\nId: \nhelloworld\n\n\nName: \nHelloworld\n\n\nExecutable: \ntrue\n\n\n\n\n\n\n\n\nVous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\n\n\nSauvegarder le diagramme sous le r\u00e9pertoire \nsrc/main/resources\n du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez \nhelloworld.bpmn\n\n\n\n\nD\u00e9ploiement du processus\n\n\n\n\n\n\nConfigurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ:\n\n\n\n\nAller au menu \nFile \n Project Structure...\n\n\nCliquer sur \nArtifacts\n.\n\n\nD\u00e9finir le type de l'archive \u00e0 d\u00e9ployer: \nWeb Application: Archive\n\n\nD\u00e9finir comme Output Directory le r\u00e9pertoire \nwebapps\n, se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire \n$CAMUNDA_HOME/server/apache-tomcat-\nversion>/webapps\n.\n\n\nEn bas de la fen\u00eatre, vous trouverez un bouton \nCreate Manifest\n. Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement.\n\n\nVous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\n\n\n\n\n\n\n\n\nFaire un \nmake\n du projet. Pour cela, aller au menu \nBuild \n Make Project\n ou cliquer sur \n. Normalement, un nouveau fichier \nhelloworld-1.0-SNAPSHOT.war\n sera cr\u00e9\u00e9 dans le r\u00e9pertoire \nwebapps\n du serveur.\n\n\n\n\nPour v\u00e9rifier que le processus a bien \u00e9t\u00e9 d\u00e9ploy\u00e9 sur le serveur Tomcat, consulter le fichier log se trouvant sous \n$CAMUNDA_HOME/server/apache-tomcat-\nversion>/logs\n et ouvrir le fichier \ncatalina.out\n.\n\n\n\n\nTip\n\n\nLe meilleur moyen de consulter en permanence le fichier log sur les syst\u00e8mes Linux-like est d'ouvrir un terminal, et de taper \ntail -f catalina.out\n.\n\n\n\n\nLe fichier devra contenir les lignes suivantes:\n\n\n\n\nV\u00e9rification du d\u00e9ploiement avec Cockpit\n\n\nCamunda offre l'outil \nCockpit\n pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant: \nhttp://localhost:8080/camunda/app/cockpit\n. Identifiez-vous comme administrateur en tapant les credentials: \ndemo/demo\n. Cliquer sur le nombre sous \nProcess Definitions\n (cela devra \u00eatre \n2\n dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat \nchecked\n.\n\n\n\n\nD\u00e9marrage du processus\n\n\n\n\nAller au \nCamunda Tasklist\n (\nhttp://localhost:8080/camunda/app/tasklist\n), puis lancer le processus en cliquant sur le bouton \nStart Process\n (en haut \u00e0 droite).\n\n\nCliquer sur votre processus \nHelloworld\n.\n\n\nAjouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable \nnom\n de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur \nAdd a variable\n et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien \n ):\n\n\n\n\n\n\n\n\nEn rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat \nRunning\n.\n\n\n\n\nConfiguration des permissions\n\n\nPour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus \nHelloworld\n, il faudra lui rajouter les autorisations. Pour cela:\n\n\n\n\nAller \u00e0 \nCamunda Admin\n (\nhttp://localhost:8080/camunda/app/admin/default/#/authorization?resource=0\n).\n\n\nAjouter une nouvelle autorisation dans la partie \nProcess Definition\n, pour permettre \u00e0 John de manipuler la d\u00e9finition du processus \nHelloworld\n.\n\n\n\n\n\n\n\n\nDans la partie \nProcess Instance\n, ajouter la permission de cr\u00e9er une instance de processus \u00e0 John.\n\n\n\n\n\n\n\n\nVous authentifier comme \u00e9tant John, en utilisant (\njohn/john\n), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus.\n\n\n\n\n\n\nCr\u00e9ation d'un formulaire personnalis\u00e9\n\n\nPour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service,  suivre les \u00e9tapes suivantes:\n\n\n\n\nRevenir vers IntelliJ, et cr\u00e9er un fichier \ndis-bonjour.html\n sous le r\u00e9pertoire \nsrc/main/webapp/forms\n. Ajouter le contenu suivant:\n\n\n\n\nform\n \nname\n=\ndisBonjour\n\n    \ndiv\n \nclass\n=\nform-group\n\n        \nlabel\n \nfor\n=\nnom\nNom\n/\nlabel\n\n        \ninput\n \nclass\n=\nform-control\n\n               \ncam-variable-type\n=\nString\n\n               \ncam-variable-name\n=\nnom\n\n               \nname\n=\nnom\n \n/\n\n    \n/\ndiv\n\n\n/\nform\n\n\n\n\n\n\n\nOuvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation \nForms\n  et ins\u00e9rer \nembedded:app:forms/dis-bonjour.html\n dans le champ \nKey\n. Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application.\n\n\nSauvegarder, et rafra\u00eechir le projet dans IntelliJ.\n\n\nDe m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera \nbonjour.html\n.\n\n\n\n\nform\n \nname\n=\nbonjour\n\n    \ndiv\n \nclass\n=\nform-group\n\n        \nlabel\n \nfor\n=\nsalutation\nSalutation\n/\nlabel\n\n        \ninput\n \nclass\n=\nform-control\n\n               \ncam-variable-type\n=\nString\n\n               \ncam-variable-name\n=\nsalutation\n\n               \nname\n=\nsalutation\n \n/\n\n    \n/\ndiv\n\n    \ndiv\n \nclass\n=\nform-group\n\n        \nlabel\n \nfor\n=\nnom\nNom\n/\nlabel\n\n        \ninput\n \nclass\n=\nform-control\n\n               \ncam-variable-type\n=\nString\n\n               \ncam-variable-name\n=\nnom\n\n               \nname\n=\nnom\n\n               \nreadonly\n=\ntrue\n \n/\n\n    \n/\ndiv\n\n\n/\nform\n\n\n\n\n\n\n\nAffecter ce formulaire \u00e0 la t\u00e2che \nAjouter Bonjour\n de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment.\n\n\nSauvegarder tout et re-d\u00e9ployer le projet.\n\n\nLancer maintenant le processus. Saisir votre nom dans la rubrique \nNom\n.\n\n\n\n\n\n\n\n\nIdentifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire:\n\n\n\n\n\n\nPour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un \nService Task\n.\n\n\nAjout d'un Service Task Java\n\n\nPour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes:\n\n\n\n\nUtiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette \n , s\u00e9lectionner l'option \nService Task\n. Appeler le service \nDire Bonjour\n. Vous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\n\n\n\n\nAjouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e \nProcessRequestDelegate\n qui impl\u00e9mente l'interface \nJavaDelegate\n, comme suit:\n\n\n\n\npackage\n \ntn.insat.eservices.tp2.helloworld\n;\n\n\n\nimport\n \njava.util.logging.Logger\n;\n\n\nimport\n \norg.camunda.bpm.engine.delegate.DelegateExecution\n;\n\n\nimport\n \norg.camunda.bpm.engine.delegate.JavaDelegate\n;\n\n\n\npublic\n \nclass\n \nProcessRequestDelegate\n \nimplements\n \nJavaDelegate\n \n{\n\n\n    \nprivate\n \nfinal\n \nstatic\n \nLogger\n \nLOGGER\n \n=\n \nLogger\n.\ngetLogger\n(\nHello-Greetings\n);\n\n\n    \npublic\n \nvoid\n \nexecute\n(\nDelegateExecution\n \nexecution\n)\n \nthrows\n \nException\n \n{\n\n        \nLOGGER\n.\ninfo\n(\nHey! \n \n+\n \nexecution\n.\ngetVariable\n(\nsalutation\n)\n\n                    \n+\n \n \n \n+\n \nexecution\n.\ngetVariable\n(\nnom\n)\n \n+\n \n!\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\nUtiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class: \ntn.insat.eservices.tp2.helloworld.ProcessRequestDelegate\n.\n\n\nD\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit:\n\n\n\n\n\n\nAppel d'un Service Web REST\n\n\nGr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour.\n\n\n\n\nCommencer par ajuster le formulaire \nbonjour.html\n, en lui ajoutant un autre champs de texte: \nville\n apr\u00e8s le champs \nnom\n.\n\n\nRevenir dans le Modeler, et ajouter un Service Task, qu'on appellera \nConsulter M\u00e9t\u00e9o\n, entre \nAjouter Bonjour\n  et \nDire Bonjour\n.\n\n\nDans ce service, indiquer que le type d'impl\u00e9mentation est \nConnector\n, et vous d\u00e9placer vers l'onglet \nConnector\n pour le configurer.\n\n\n\n\nDonner les param\u00e8tres suivants \u00e0 votre connecteur;\n\n\n\n\nId\n: \nhttp-connector\n\n\nInput\n: Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web \nOpenWeatherMap\n. Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs \nville\n.\n\n\n\n\n\n\n\n\n\n\nNom\n\n\nType\n\n\nValeur\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nScript / JavaScript / Inline Script\n\n\nvar ville=execution.getVariable(\nville\n); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266\nq='+ville;\n\n\n\n\n\n\nmethod\n\n\nText\n\n\nGET\n\n\n\n\n\n\nheaders\n\n\nMap\n\n\nkey: accept, value:application/json -       key:content-type, value:application/json\n\n\n\n\n\n\n\n\n\n\nOutput\n: Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\n{\n\n  \ncoord\n:\n \n{\n\n    \nlon\n:\n \n10.17\n,\n\n    \nlat\n:\n \n36.82\n\n  \n},\n\n  \nweather\n:\n \n[\n\n    \n{\n\n      \nid\n:\n \n801\n,\n\n      \nmain\n:\n \nClouds\n,\n\n      \ndescription\n:\n \nfew clouds\n,\n\n      \nicon\n:\n \n02d\n\n    \n}\n\n  \n],\n\n  \nbase\n:\n \nstations\n,\n\n  \nmain\n:\n \n{\n\n    \ntemp\n:\n \n299.87\n,\n\n    \npressure\n:\n \n1018\n,\n\n    \nhumidity\n:\n \n39\n,\n\n    \ntemp_min\n:\n \n299.15\n,\n\n    \ntemp_max\n:\n \n301.15\n\n  \n},\n\n  \nvisibility\n:\n \n10000\n,\n\n  \nwind\n:\n \n{\n\n    \nspeed\n:\n \n3.6\n,\n\n    \ndeg\n:\n \n40\n\n  \n},\n\n  \nclouds\n:\n \n{\n\n    \nall\n:\n \n20\n\n  \n},\n\n  \ndt\n:\n \n1506864600\n,\n\n  \nsys\n:\n \n{\n\n    \ntype\n:\n \n1\n,\n\n    \nid\n:\n \n6318\n,\n\n    \nmessage\n:\n \n0.0039\n,\n\n    \ncountry\n:\n \nTN\n,\n\n    \nsunrise\n:\n \n1506834907\n,\n\n    \nsunset\n:\n \n1506877308\n\n  \n},\n\n  \nid\n:\n \n2464470\n,\n\n  \nname\n:\n \nTunis\n,\n\n  \ncod\n:\n \n200\n\n\n}\n\n\n\n\n\nSi l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment \nmain\n puis \u00e0 son fils \ntemp\n. L'output de notre service aura donc la forme suivante:\n\n\n\n\n\n\n\n\nNom\n\n\nType\n\n\nValeur\n\n\n\n\n\n\n\n\n\n\nWsResponse\n\n\nScript / JavaScript / Inline Script\n\n\nS(response).prop(\nmain\n).prop(\ntemp\n).numberValue();\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nToujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application!\n\n\n\n\n\n\nMaintenant, ajouter le code d'exploitation de ce service dans la classe \nProcessRequestDelegate\n, pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate:\n\n\n\n\npublic\n \nclass\n \nProcessRequestDelegate\n \nimplements\n \nJavaDelegate\n \n{\n\n\n    \nprivate\n \nfinal\n \nstatic\n \nLogger\n \nLOGGER\n \n=\n \nLogger\n.\ngetLogger\n(\nHello-Greetings\n);\n\n\n    \npublic\n \nvoid\n \nexecute\n(\nDelegateExecution\n \nexecution\n)\n \nthrows\n \nException\n \n{\n\n        \nLOGGER\n.\ninfo\n(\nHey! \n \n+\n \nexecution\n.\ngetVariable\n(\nsalutation\n)\n \n+\n \n \n\n                \n+\n \nexecution\n.\ngetVariable\n(\nnom\n)\n\n                \n+\n \n! La temp\u00e9rature aujourd\nhui \u00e0 \n\n                \n+\n \nexecution\n.\ngetVariable\n(\nville\n)\n\n                \n+\n \n est de \n\n                \n+\n \nexecution\n.\ngetVariable\n(\nWsResponse\n)+\n!\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\n\n\nTout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant:\n\n\n\n\n\n\nL'utilisateur demo saisit son nom:\n\n\n\n\n\n\n\n\nL'utilisateur john rajoute la salutation et la ville:\n\n\n\n\n\n\n\n\nLe processus affiche ce r\u00e9sultat sur le log:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTAF\n\n\nVous remarquerez que le service web REST que nous avons appel\u00e9 rend la temp\u00e9rature en degr\u00e9 Kelvin. Chercher un service web qui fasse la conversion du \u00baK vers le \u00baC, puis appelez-le avant de faire l'affichage.\n\n\n\n\nHomework\n\n\nVous \u00eates manager d'une entreprise, dont vous choisirez le nom et le m\u00e9tier.Vous d\u00e9sirez r\u00e9aliser une application pour faciliter son processus de recrutement. C'est \u00e0 vous de choisir le degr\u00e9 de complexit\u00e9 et les sp\u00e9cificit\u00e9s m\u00e9tier du processus, \u00e0 partir du moment qu'il respecte ces conditions:\n\n\n\n\nVous devez d\u00e9finir au moins trois types d'acteurs.\n\n\nVous devez impl\u00e9menter votre processus avec Camunda.\n\n\nVous devez utiliser un service web REST ou SOAP impl\u00e9ment\u00e9 avec Talend.\n\n\nVous devez utiliser une base de donn\u00e9es.\n\n\n\n\nPour la s\u00e9ance de TP prochaine, vous devez me pr\u00e9senter un processus \nqui marche\n, en m'expliquant son fonctionnement et les choix m\u00e9tier que vous avez fait.", 
            "title": "TP2 - Orchestration de Services avec Camunda"
        }, 
        {
            "location": "/tp2/#tp2-orchestration-de-services-avec-camunda", 
            "text": "", 
            "title": "TP2 - Orchestration de Services avec Camunda"
        }, 
        {
            "location": "/tp2/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp2/#objectifs-du-tp", 
            "text": "Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp2/#outils-et-versions", 
            "text": "Camunda  Version: 7.7.0  Java  Version 1.8.0_121 (7+ needed).  IntelliJ IDEA  Version Ultimate 2016.1 (ou tout autre IDE de votre choix)  Camunda Modeler  Version 1.10.0", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp2/#camunda", 
            "text": "Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support  BPMN  pour l'automatisation des processus,  CMMN  pour le Case Management, et  DMN  pour le Business Decision Management.", 
            "title": "Camunda"
        }, 
        {
            "location": "/tp2/#bpmn-20", 
            "text": "BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations.  Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier.  Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.", 
            "title": "BPMN 2.0"
        }, 
        {
            "location": "/tp2/#installation", 
            "text": "Pour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes:   T\u00e9l\u00e9charger  Camunda  (Distribution Tomcat),  IntelliJ IDEA  et  Camunda Modeler .  D\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter  start-camunda.sh  (pour les syst\u00e8mes Unix-based) ou  start-camunda.bat  (pour les syst\u00e8mes Windows).  Ouvrir la page d'accueil du serveur d'application dans votre navigateur pr\u00e9f\u00e9r\u00e9.  Lancer le Camunda Modeler.", 
            "title": "Installation"
        }, 
        {
            "location": "/tp2/#premier-projet-camunda-bpmn-helloworld", 
            "text": "", 
            "title": "Premier Projet Camunda BPMN: Helloworld"
        }, 
        {
            "location": "/tp2/#creation-du-projet-et-dependances", 
            "text": "Vous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus.   Ouvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype).   Vous pouvez choisir les param\u00e8tres suivants:   Group Id:  tn.insat.eservices.tp2  Artifact Id:  Helloworld  Project Name:  HelloworldCamunda     Dans le fichier  pom.xml , indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier  war . Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version:    packaging war /packaging    Ajouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier  pom.xml   dependencyManagement \n     dependencies \n       dependency \n         groupId org.camunda.bpm /groupId \n         artifactId camunda-bom /artifactId \n         version 7.7.0 /version \n         scope import /scope \n         type pom /type \n       /dependency \n     /dependencies \n   /dependencyManagement \n\n   dependencies \n     dependency \n       groupId org.camunda.bpm /groupId \n       artifactId camunda-engine /artifactId \n       scope provided /scope \n     /dependency \n\n     dependency \n       groupId javax.servlet /groupId \n       artifactId javax.servlet-api /artifactId \n       version 3.0.1 /version \n       scope provided /scope \n     /dependency \n   /dependencies \n\n   build \n     plugins \n       plugin \n         groupId org.apache.maven.plugins /groupId \n         artifactId maven-war-plugin /artifactId \n         version 2.3 /version \n         configuration \n           failOnMissingWebXml false /failOnMissingWebXml \n         /configuration \n       /plugin \n     /plugins \n   /build    Faire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez  maven-install  par exemple, et vous \u00e9crirez dans la partie  Command Line  :  install , comme suit:     Lancer le build et v\u00e9rifiez bien que vos packages ont bien \u00e9t\u00e9 install\u00e9s.", 
            "title": "Cr\u00e9ation du Projet et D\u00e9pendances"
        }, 
        {
            "location": "/tp2/#creation-de-la-classe-principale-pour-le-processus", 
            "text": "La prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda.  package   tn.insat.eservices.tp2.helloworld ;  import   org.camunda.bpm.application.ProcessApplication ;  import   org.camunda.bpm.application.impl.ServletProcessApplication ;  @ProcessApplication ( Helloworld App )  public   class   HelloworldApplication   extends   ServletProcessApplication   { \n     // empty implementation  }   Ajouter ensuite le fichier  processes.xml  sous le r\u00e9pertoire  src/main/resources/META-INF . Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus.  ?xml version= 1.0  encoding= UTF-8  ?  process-application \n         xmlns= http://www.camunda.org/schema/1.0/ProcessApplication \n         xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     process-archive   name= helloworld \n         process-engine default /process-engine \n         properties \n             property   name= isDeleteUponUndeploy false /property \n             property   name= isScanForProcessDefinitions true /property \n         /properties \n     /process-archive  /process-application   A partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus.", 
            "title": "Cr\u00e9ation de la classe principale pour le processus"
        }, 
        {
            "location": "/tp2/#modelisation-dun-processus-bpmn-20", 
            "text": "La mod\u00e9lisation du processus se fera gr\u00e2ce au  Camunda Modeler . Pour cela:   D\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN en cliquant sur  File   New File   BPMN Diagram .     Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons  Dis Bonjour .  Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9  Ajouter Bonjour .     Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel  Bonjour  nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir  User Task .     Rajouter une t\u00e2che de fin au processus.   Nous obtenons pour finir le diagramme suivant:", 
            "title": "Mod\u00e9lisation d'un processus BPMN 2.0"
        }, 
        {
            "location": "/tp2/#configuration-du-processus", 
            "text": "Pour configurer la t\u00e2che utilisateur  Ajouter Bonjour , cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). D\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ  Assignee , ins\u00e9rer  john . John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les.  Pour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants:  Id:  helloworld  Name:  Helloworld  Executable:  true     Vous obtiendrez le r\u00e9sultat suivant:    Sauvegarder le diagramme sous le r\u00e9pertoire  src/main/resources  du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez  helloworld.bpmn", 
            "title": "Configuration du processus"
        }, 
        {
            "location": "/tp2/#deploiement-du-processus", 
            "text": "Configurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ:   Aller au menu  File   Project Structure...  Cliquer sur  Artifacts .  D\u00e9finir le type de l'archive \u00e0 d\u00e9ployer:  Web Application: Archive  D\u00e9finir comme Output Directory le r\u00e9pertoire  webapps , se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire  $CAMUNDA_HOME/server/apache-tomcat- version>/webapps .  En bas de la fen\u00eatre, vous trouverez un bouton  Create Manifest . Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement.  Vous obtiendrez le r\u00e9sultat suivant:       Faire un  make  du projet. Pour cela, aller au menu  Build   Make Project  ou cliquer sur  . Normalement, un nouveau fichier  helloworld-1.0-SNAPSHOT.war  sera cr\u00e9\u00e9 dans le r\u00e9pertoire  webapps  du serveur.   Pour v\u00e9rifier que le processus a bien \u00e9t\u00e9 d\u00e9ploy\u00e9 sur le serveur Tomcat, consulter le fichier log se trouvant sous  $CAMUNDA_HOME/server/apache-tomcat- version>/logs  et ouvrir le fichier  catalina.out .   Tip  Le meilleur moyen de consulter en permanence le fichier log sur les syst\u00e8mes Linux-like est d'ouvrir un terminal, et de taper  tail -f catalina.out .   Le fichier devra contenir les lignes suivantes:", 
            "title": "D\u00e9ploiement du processus"
        }, 
        {
            "location": "/tp2/#verification-du-deploiement-avec-cockpit", 
            "text": "Camunda offre l'outil  Cockpit  pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant:  http://localhost:8080/camunda/app/cockpit . Identifiez-vous comme administrateur en tapant les credentials:  demo/demo . Cliquer sur le nombre sous  Process Definitions  (cela devra \u00eatre  2  dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat  checked .", 
            "title": "V\u00e9rification du d\u00e9ploiement avec Cockpit"
        }, 
        {
            "location": "/tp2/#demarrage-du-processus", 
            "text": "Aller au  Camunda Tasklist  ( http://localhost:8080/camunda/app/tasklist ), puis lancer le processus en cliquant sur le bouton  Start Process  (en haut \u00e0 droite).  Cliquer sur votre processus  Helloworld .  Ajouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable  nom  de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur  Add a variable  et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien   ):     En rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat  Running .", 
            "title": "D\u00e9marrage du processus"
        }, 
        {
            "location": "/tp2/#configuration-des-permissions", 
            "text": "Pour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus  Helloworld , il faudra lui rajouter les autorisations. Pour cela:   Aller \u00e0  Camunda Admin  ( http://localhost:8080/camunda/app/admin/default/#/authorization?resource=0 ).  Ajouter une nouvelle autorisation dans la partie  Process Definition , pour permettre \u00e0 John de manipuler la d\u00e9finition du processus  Helloworld .     Dans la partie  Process Instance , ajouter la permission de cr\u00e9er une instance de processus \u00e0 John.     Vous authentifier comme \u00e9tant John, en utilisant ( john/john ), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus.", 
            "title": "Configuration des permissions"
        }, 
        {
            "location": "/tp2/#creation-dun-formulaire-personnalise", 
            "text": "Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service,  suivre les \u00e9tapes suivantes:   Revenir vers IntelliJ, et cr\u00e9er un fichier  dis-bonjour.html  sous le r\u00e9pertoire  src/main/webapp/forms . Ajouter le contenu suivant:   form   name = disBonjour \n     div   class = form-group \n         label   for = nom Nom / label \n         input   class = form-control \n                cam-variable-type = String \n                cam-variable-name = nom \n                name = nom   / \n     / div  / form    Ouvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation  Forms   et ins\u00e9rer  embedded:app:forms/dis-bonjour.html  dans le champ  Key . Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application.  Sauvegarder, et rafra\u00eechir le projet dans IntelliJ.  De m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera  bonjour.html .   form   name = bonjour \n     div   class = form-group \n         label   for = salutation Salutation / label \n         input   class = form-control \n                cam-variable-type = String \n                cam-variable-name = salutation \n                name = salutation   / \n     / div \n     div   class = form-group \n         label   for = nom Nom / label \n         input   class = form-control \n                cam-variable-type = String \n                cam-variable-name = nom \n                name = nom \n                readonly = true   / \n     / div  / form    Affecter ce formulaire \u00e0 la t\u00e2che  Ajouter Bonjour  de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment.  Sauvegarder tout et re-d\u00e9ployer le projet.  Lancer maintenant le processus. Saisir votre nom dans la rubrique  Nom .     Identifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire:    Pour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un  Service Task .", 
            "title": "Cr\u00e9ation d'un formulaire personnalis\u00e9"
        }, 
        {
            "location": "/tp2/#ajout-dun-service-task-java", 
            "text": "Pour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes:   Utiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette   , s\u00e9lectionner l'option  Service Task . Appeler le service  Dire Bonjour . Vous obtiendrez le r\u00e9sultat suivant:     Ajouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e  ProcessRequestDelegate  qui impl\u00e9mente l'interface  JavaDelegate , comme suit:   package   tn.insat.eservices.tp2.helloworld ;  import   java.util.logging.Logger ;  import   org.camunda.bpm.engine.delegate.DelegateExecution ;  import   org.camunda.bpm.engine.delegate.JavaDelegate ;  public   class   ProcessRequestDelegate   implements   JavaDelegate   { \n\n     private   final   static   Logger   LOGGER   =   Logger . getLogger ( Hello-Greetings ); \n\n     public   void   execute ( DelegateExecution   execution )   throws   Exception   { \n         LOGGER . info ( Hey!    +   execution . getVariable ( salutation ) \n                     +       +   execution . getVariable ( nom )   +   ! ); \n     }  }    Utiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class:  tn.insat.eservices.tp2.helloworld.ProcessRequestDelegate .  D\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit:", 
            "title": "Ajout d'un Service Task Java"
        }, 
        {
            "location": "/tp2/#appel-dun-service-web-rest", 
            "text": "Gr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour.   Commencer par ajuster le formulaire  bonjour.html , en lui ajoutant un autre champs de texte:  ville  apr\u00e8s le champs  nom .  Revenir dans le Modeler, et ajouter un Service Task, qu'on appellera  Consulter M\u00e9t\u00e9o , entre  Ajouter Bonjour   et  Dire Bonjour .  Dans ce service, indiquer que le type d'impl\u00e9mentation est  Connector , et vous d\u00e9placer vers l'onglet  Connector  pour le configurer.   Donner les param\u00e8tres suivants \u00e0 votre connecteur;   Id :  http-connector  Input : Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web  OpenWeatherMap . Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs  ville .      Nom  Type  Valeur      url  Script / JavaScript / Inline Script  var ville=execution.getVariable( ville ); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266 q='+ville;    method  Text  GET    headers  Map  key: accept, value:application/json -       key:content-type, value:application/json      Output : Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit:     { \n   coord :   { \n     lon :   10.17 , \n     lat :   36.82 \n   }, \n   weather :   [ \n     { \n       id :   801 , \n       main :   Clouds , \n       description :   few clouds , \n       icon :   02d \n     } \n   ], \n   base :   stations , \n   main :   { \n     temp :   299.87 , \n     pressure :   1018 , \n     humidity :   39 , \n     temp_min :   299.15 , \n     temp_max :   301.15 \n   }, \n   visibility :   10000 , \n   wind :   { \n     speed :   3.6 , \n     deg :   40 \n   }, \n   clouds :   { \n     all :   20 \n   }, \n   dt :   1506864600 , \n   sys :   { \n     type :   1 , \n     id :   6318 , \n     message :   0.0039 , \n     country :   TN , \n     sunrise :   1506834907 , \n     sunset :   1506877308 \n   }, \n   id :   2464470 , \n   name :   Tunis , \n   cod :   200  }   Si l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment  main  puis \u00e0 son fils  temp . L'output de notre service aura donc la forme suivante:     Nom  Type  Valeur      WsResponse  Script / JavaScript / Inline Script  S(response).prop( main ).prop( temp ).numberValue();      Tip  Toujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application!    Maintenant, ajouter le code d'exploitation de ce service dans la classe  ProcessRequestDelegate , pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate:   public   class   ProcessRequestDelegate   implements   JavaDelegate   { \n\n     private   final   static   Logger   LOGGER   =   Logger . getLogger ( Hello-Greetings ); \n\n     public   void   execute ( DelegateExecution   execution )   throws   Exception   { \n         LOGGER . info ( Hey!    +   execution . getVariable ( salutation )   +     \n                 +   execution . getVariable ( nom ) \n                 +   ! La temp\u00e9rature aujourd hui \u00e0  \n                 +   execution . getVariable ( ville ) \n                 +    est de  \n                 +   execution . getVariable ( WsResponse )+ ! ); \n     }  }     Tout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant:    L'utilisateur demo saisit son nom:     L'utilisateur john rajoute la salutation et la ville:     Le processus affiche ce r\u00e9sultat sur le log:        TAF  Vous remarquerez que le service web REST que nous avons appel\u00e9 rend la temp\u00e9rature en degr\u00e9 Kelvin. Chercher un service web qui fasse la conversion du \u00baK vers le \u00baC, puis appelez-le avant de faire l'affichage.", 
            "title": "Appel d'un Service Web REST"
        }, 
        {
            "location": "/tp2/#homework", 
            "text": "Vous \u00eates manager d'une entreprise, dont vous choisirez le nom et le m\u00e9tier.Vous d\u00e9sirez r\u00e9aliser une application pour faciliter son processus de recrutement. C'est \u00e0 vous de choisir le degr\u00e9 de complexit\u00e9 et les sp\u00e9cificit\u00e9s m\u00e9tier du processus, \u00e0 partir du moment qu'il respecte ces conditions:   Vous devez d\u00e9finir au moins trois types d'acteurs.  Vous devez impl\u00e9menter votre processus avec Camunda.  Vous devez utiliser un service web REST ou SOAP impl\u00e9ment\u00e9 avec Talend.  Vous devez utiliser une base de donn\u00e9es.   Pour la s\u00e9ance de TP prochaine, vous devez me pr\u00e9senter un processus  qui marche , en m'expliquant son fonctionnement et les choix m\u00e9tier que vous avez fait.", 
            "title": "Homework"
        }, 
        {
            "location": "/tp3/", 
            "text": "TP3 - Mise en Place d\u2019un ESB avec Talend ESB\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\n\n\nRoutage, m\u00e9diation et transformation avec Talend ESB.\n\n\nGestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB.\n\n\n\n\nOutils et Versions\n\n\n\n\nTalend Open Studio for ESB\n Version: 6.3.0\n\n\nDB Visualizer\n Version 10.0\n\n\nJava\n Version 1.8.0_121\n\n\n\n\nConfiguration et Utilisation de l'ESB Talend\n\n\nLancement de deux instances de l'ESB Talend\n\n\nPour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire:\n\n\n\n\nAller dans le r\u00e9pertoire \nrep_install_talend>/Runtime_ESBSE\n\n\nCopier le r\u00e9pertoire \ncontainer\n et le renommer en \nalternate-container\n.\n\n\n\n\nNous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans \nalternate-container\n) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela:\n\n\n\n\nLancer l\u2019ESB\n : dans le r\u00e9pertoire \nalternate-container\n que vous venez de cr\u00e9er, aller vers \nbin\n et ex\u00e9cuter \ntrun.bash\n (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire \nalternate-container/bin\n et  lancer dans un terminal la commande \n./trun\n. La fen\u00eatre suivante devrait s\u2019afficher:\n\n\n\n\n\n\n\n\nAttention\n\n\nLe premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante.\n\n\n\n\n\n\nConfigurer l'ESB\n : dans l\u2019invite de commande affich\u00e9e, taper:\n\n\n\n\n  \nsource\n scripts/configureC1.sh\n\n\n\n\n\n\nUn affichage tel que le suivant va appara\u00eetre:\n\n\n\n\n\n\nVous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh.\n\n\n\n\nArr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau.\n\n\nLancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040.\n\n\n\n\nPublier votre Service dans l'ESB et le Tester\n\n\nRevenir au service web SOAP \nHelloWorldService\n que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur \nTalend Open Studio\n sur le projet \nHelloworld\n, et suivre les \u00e9tapes suivantes:\n\n\n\n\nFaire un clic-droit sur le service \nHelloWorldService\n et choisir \nExporter le service\n. Choisir comme r\u00e9pertoire de destination le dossier \ndeploy\n se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB).\n\n\nD\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9.\n\n\nV\u00e9rifier que vos services sont actifs:\n\n\nen tapant \nlist\n dans vos deux instances d\u2019ESB\n\n\nen affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090.\n\n\n\n\n\n\n\n\nPour tester votre service web:\n\n\n\n\nDans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040\n\n\nLancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB.\n\n\n\n\nV\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci:\n\n\n\n\nCr\u00e9ation des Routes\n\n\nLes routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires.\n\n\nPremi\u00e8re Route: Filtrage des Messages\n\n\n\n\nCr\u00e9er une nouvelle route en cliquant-droit sur \nRoutes -\n Cr\u00e9er une Route\n. Nous allons l\u2019appeler FiltrageRoute.\n\n\nD\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\n\n\nLes composants utilis\u00e9s sont:\n\n\n\n\ncCXF\n : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS.\n\n\nMessageRouter\n\u00a0: route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es.\n\n\n\n\n\n\n\n\nConfigurer la condition \nwhen\n, en pr\u00e9cisant que c\u2019est une condition de type simple, dont le texte est :\n\n\n\n\n\n\n    \n${\nbodyAs\n(String)\n}\n contains \nAlice\n\n\n\n  Cela veut dire que, si le corps du message contient \nAlice\n, la requ\u00eate sera rout\u00e9e vers le composant \ncCXF_2\n.\n\n\n\n\n\n\nConfigurer le composant cCXF_1:\n\n\n\n\nAdresse: \nhttp://localhost:8042/services/HelloWorldService\n\n\nWSDL: \nhttp://localhost:8040/services/HelloWorldService?WSDL\n.\n\n\n\n\n\n\n\n\n\n\nRemarque\n\n\nRemarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB.\n\n\n\n\n\n\nConfigurer l\u2019adresse de cCXF_2 sur le port 8040, et celle de cCXF_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants.\n\n\nLancer la route pour la tester. La console devra afficher \nconnected\n.\n\n\n\n\nPour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous?\n\n\nD\u00e9ploiement des Routes sur l'ESB\n\n\nDans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes:\n\n\n\n\nFaites un clic-droit sur votre route et s\u00e9lectionner: \nBuild Route\n (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9).\n\n\nChoisir le r\u00e9pertoire deploy du conteneur de votre choix.\n\n\nTester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur.\n\n\n\n\n\n\nAttention\n\n\nVous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse.\n\n\n\n\nDeuxi\u00e8me Route : Filtrage et Modification de Messages\n\n\nDans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela:\n\n\n\n\nDans Talend Studio, dupliquer votre route \nFiltrageRoute\n et la nommer \nModificationRoute\n.\n\n\nIns\u00e9rer un composant \ncSetBody\n (permettant de modifier le corps du message re\u00e7u) puis un composant \ncProcessor\n (permettant  de remanier rapidement du code dans la route) entre le \ncMessageRouter\n et le \ncCXF_3\n. Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant:\n\n\n\n\n\n\n\n\nIns\u00e9rer le code suivant (de type Xpath) dans le \ncSetBody\n :\n\n\n\n\n  \ntns:HelloWorldServiceOperationRequest/in\n\n\n\n\n\nCeci permet de saisir le contenu de la balise \nin\n de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace \ntns\n (\nhttp://www.talend.org/service/\n).\n\n\n\n\nIns\u00e9rer le code suivant dans le processeur:\n\n\n\n\nString\n \nname\n \n=\n \nexchange\n.\ngetIn\n().\ngetBody\n(\nString\n.\nclass\n);\n\n\nString\n \nsurname\n;\n\n\nif\n \n(\nname\n.\ncontains\n(\nBob\n)){\n\n  \nsurname\n \n=\n \nBobby\n;\n\n\n}\nelse\n{\n\n  \nsurname\n \n=\n \nChucky\n;\n\n\n}\n\n\nexchange\n.\ngetIn\n().\nsetBody\n(\ntns:HelloWorldServiceOperationRequest \n+\n\n    \nxmlns:tns=\\\nhttp://www.talend.org/service/\\\nin\n\n    \n+\nsurname\n+\n/in\n \n/tns:HelloWorldServiceOperationRequest\n);\n\n\n\n\n\nCe code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom.\n\n\n\n\nModifier l'adresse du composant \ncCXF_1\n pour qu'il se lance sur le port 8043.\n\n\nSauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat.\n\n\n\n\nFonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB\n\n\nFailover et R\u00e9partition de Charge\n\n\nService Locator\n\n\nVia le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs).\n\n\nConfiguration du Service Locator\n\n\nPour activer le service locator (SL), il faut:\n\n\n\n\nD\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend\n\n\nActiver la prise en compte du SL au niveau du service cible\n\n\nConfigurer le consommateur du service pour prendre en compte le SL\n\n\n\n\n1. D\u00e9ploiement du SL dans le contenaire\n\n\nPour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB:\n\n\n  tesb\n:\nstart-locator\n\n\n\n\n\nIl est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes:\n\n\n\n\n2. Activer SL dans le service\n\n\nPour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio:\n\n\n\n\nClic-droit sur le service\n\n\nChoisir \nESB Runtime Options\n\n\nCocher la case \n\"Utiliser le Service Locator\"\n\n\n\n\nIl faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9.\n\n\n3. Activer SL dans le consommateur\n\n\nAu niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case \nUse Service Locator\n.\n\n\nTest du Service Locator\n\n\nPour tester la r\u00e9partition de charges\n : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat.\n\n\nPour tester la gestion du failover\n : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper \nlist\n, puis chercher l'identifiant du service \nHelloWorldService\n. Taper ensuite : \nstop \nid_service>\n. Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat.\n\n\nService Monitoring\n\n\nLe composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes.\n\n\nPour configurer le Service Activity Monitoring:\n\n\n\n\n\n\nD\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper :\n\n\ntesb\n:\nstart-sam\n\n\n\n  Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services.\n\n\n\n\n\n\nActiver la prise en compte de SAM au niveau du service cible\n\n\n\n\nConfigurer le consommateur du service pour prendre en compte le SAM\n\n\n\n\nPour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que \nDb Visualizer\n.\n\n\nPour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants:\n\n\n\n\nDatabase connection configuration (Default)\n: Derby/JavaDB\n\n\nDriver\n: JavaDB/Derby Server\n\n\nDatabase Server\n: localhost\n\n\nDatabase Port\n: 1527\n\n\nDatabase\n: DB\n\n\nDB username\n: test\n\n\nDB password\n: test\n\n\n\n\nEx\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat.\n\n\nAuthentification\n\n\nSecurity Token Service (STS) : Impl\u00e9mentation du WS-Trust\n\n\nDans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust. \n\"Trust\"\n veut dire \n\"Confiance\"\n: le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur.\n\n\nPour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service.\n\n\nLe STS (\nSecurity Token Service\n) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes:\n\n\n\n\nD\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s.\n\n\nV\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification\n\n\nRenouveler un jeton de s\u00e9curit\u00e9\n\n\nAnnuler un jeton de s\u00e9curit\u00e9\n\n\nTransformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent.\n\n\n\n\nL\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames.\n\n\nConfiguration des Param\u00e8tres de S\u00e9curit\u00e9\n\n\nPour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes:\n\n\n\n\nD\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend\n\n\nConfigurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur\n\n\nActiver la prise en compte de STS dans votre service\n\n\nConfigurer votre client pour saisir les param\u00e8tres d\u2019authentification.\n\n\n\n\n1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution\n\n\nPour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal:\n\n\n    feature\n:\ninstall tesb-sts\n\n\n\n\nSi le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande : \nlist\n. Vous devriez trouver les lignes suivantes:\n\n\n\n\n2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur\n\n\nComme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame.\n\n\nPour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier: \nconteneur>/etc/users.properties\n.\n\n\nDans ce fichier, les informations d'authentification sont sous la forme: \nuser=password,group\n. Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe \nadmin\n.\n\n\n3. Activer STS dans votre service\n\n\nPour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans \nESB Runtime Options\n, cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas, \nIdentifiant/Mot de passe\n)\n\n\n4. Configurer le client\n\n\nPour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.\n\n\nHomework\n\n\nReprendre l'application que vous avez cr\u00e9\u00e9 dans le Homework pr\u00e9c\u00e9dent (celle du processus de recrutement), en d\u00e9ployant cette fois votre service (REST ou SOAP) sur deux conteneurs ESB, en d\u00e9finissant au moins une route, et en activant les diff\u00e9rentes fonctionnalit\u00e9s suppl\u00e9mentaires (SL, SAM et STS).", 
            "title": "TP3 - Mise en Place d\u2019un ESB avec Talend ESB"
        }, 
        {
            "location": "/tp3/#tp3-mise-en-place-dun-esb-avec-talend-esb", 
            "text": "", 
            "title": "TP3 - Mise en Place d\u2019un ESB avec Talend ESB"
        }, 
        {
            "location": "/tp3/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp3/#objectifs-du-tp", 
            "text": "Routage, m\u00e9diation et transformation avec Talend ESB.  Gestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB.", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp3/#outils-et-versions", 
            "text": "Talend Open Studio for ESB  Version: 6.3.0  DB Visualizer  Version 10.0  Java  Version 1.8.0_121", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp3/#configuration-et-utilisation-de-lesb-talend", 
            "text": "", 
            "title": "Configuration et Utilisation de l'ESB Talend"
        }, 
        {
            "location": "/tp3/#lancement-de-deux-instances-de-lesb-talend", 
            "text": "Pour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire:   Aller dans le r\u00e9pertoire  rep_install_talend>/Runtime_ESBSE  Copier le r\u00e9pertoire  container  et le renommer en  alternate-container .   Nous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans  alternate-container ) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela:   Lancer l\u2019ESB  : dans le r\u00e9pertoire  alternate-container  que vous venez de cr\u00e9er, aller vers  bin  et ex\u00e9cuter  trun.bash  (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire  alternate-container/bin  et  lancer dans un terminal la commande  ./trun . La fen\u00eatre suivante devrait s\u2019afficher:     Attention  Le premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante.    Configurer l'ESB  : dans l\u2019invite de commande affich\u00e9e, taper:      source  scripts/configureC1.sh   Un affichage tel que le suivant va appara\u00eetre:    Vous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh.   Arr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau.  Lancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040.", 
            "title": "Lancement de deux instances de l'ESB Talend"
        }, 
        {
            "location": "/tp3/#publier-votre-service-dans-lesb-et-le-tester", 
            "text": "Revenir au service web SOAP  HelloWorldService  que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur  Talend Open Studio  sur le projet  Helloworld , et suivre les \u00e9tapes suivantes:   Faire un clic-droit sur le service  HelloWorldService  et choisir  Exporter le service . Choisir comme r\u00e9pertoire de destination le dossier  deploy  se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB).  D\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9.  V\u00e9rifier que vos services sont actifs:  en tapant  list  dans vos deux instances d\u2019ESB  en affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090.     Pour tester votre service web:   Dans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040  Lancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB.   V\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci:", 
            "title": "Publier votre Service dans l'ESB et le Tester"
        }, 
        {
            "location": "/tp3/#creation-des-routes", 
            "text": "Les routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires.", 
            "title": "Cr\u00e9ation des Routes"
        }, 
        {
            "location": "/tp3/#premiere-route-filtrage-des-messages", 
            "text": "Cr\u00e9er une nouvelle route en cliquant-droit sur  Routes -  Cr\u00e9er une Route . Nous allons l\u2019appeler FiltrageRoute.  D\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit:      Les composants utilis\u00e9s sont:   cCXF  : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS.  MessageRouter \u00a0: route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es.     Configurer la condition  when , en pr\u00e9cisant que c\u2019est une condition de type simple, dont le texte est :         ${ bodyAs (String) }  contains  Alice  \n  Cela veut dire que, si le corps du message contient  Alice , la requ\u00eate sera rout\u00e9e vers le composant  cCXF_2 .    Configurer le composant cCXF_1:   Adresse:  http://localhost:8042/services/HelloWorldService  WSDL:  http://localhost:8040/services/HelloWorldService?WSDL .      Remarque  Remarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB.    Configurer l\u2019adresse de cCXF_2 sur le port 8040, et celle de cCXF_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants.  Lancer la route pour la tester. La console devra afficher  connected .   Pour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous?", 
            "title": "Premi\u00e8re Route: Filtrage des Messages"
        }, 
        {
            "location": "/tp3/#deploiement-des-routes-sur-lesb", 
            "text": "Dans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes:   Faites un clic-droit sur votre route et s\u00e9lectionner:  Build Route  (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9).  Choisir le r\u00e9pertoire deploy du conteneur de votre choix.  Tester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur.    Attention  Vous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse.", 
            "title": "D\u00e9ploiement des Routes sur l'ESB"
        }, 
        {
            "location": "/tp3/#deuxieme-route-filtrage-et-modification-de-messages", 
            "text": "Dans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela:   Dans Talend Studio, dupliquer votre route  FiltrageRoute  et la nommer  ModificationRoute .  Ins\u00e9rer un composant  cSetBody  (permettant de modifier le corps du message re\u00e7u) puis un composant  cProcessor  (permettant  de remanier rapidement du code dans la route) entre le  cMessageRouter  et le  cCXF_3 . Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant:     Ins\u00e9rer le code suivant (de type Xpath) dans le  cSetBody  :      tns:HelloWorldServiceOperationRequest/in   Ceci permet de saisir le contenu de la balise  in  de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace  tns  ( http://www.talend.org/service/ ).   Ins\u00e9rer le code suivant dans le processeur:   String   name   =   exchange . getIn (). getBody ( String . class );  String   surname ;  if   ( name . contains ( Bob )){ \n   surname   =   Bobby ;  } else { \n   surname   =   Chucky ;  }  exchange . getIn (). setBody ( tns:HelloWorldServiceOperationRequest  + \n     xmlns:tns=\\ http://www.talend.org/service/\\ in \n     + surname + /in   /tns:HelloWorldServiceOperationRequest );   Ce code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom.   Modifier l'adresse du composant  cCXF_1  pour qu'il se lance sur le port 8043.  Sauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat.", 
            "title": "Deuxi\u00e8me Route : Filtrage et Modification de Messages"
        }, 
        {
            "location": "/tp3/#fonctionnalites-supplementaires-de-lesb", 
            "text": "", 
            "title": "Fonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB"
        }, 
        {
            "location": "/tp3/#failover-et-repartition-de-charge", 
            "text": "", 
            "title": "Failover et R\u00e9partition de Charge"
        }, 
        {
            "location": "/tp3/#service-locator", 
            "text": "Via le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs).", 
            "title": "Service Locator"
        }, 
        {
            "location": "/tp3/#configuration-du-service-locator", 
            "text": "Pour activer le service locator (SL), il faut:   D\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend  Activer la prise en compte du SL au niveau du service cible  Configurer le consommateur du service pour prendre en compte le SL", 
            "title": "Configuration du Service Locator"
        }, 
        {
            "location": "/tp3/#1-deploiement-du-sl-dans-le-contenaire", 
            "text": "Pour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB:    tesb : start-locator   Il est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes:", 
            "title": "1. D\u00e9ploiement du SL dans le contenaire"
        }, 
        {
            "location": "/tp3/#2-activer-sl-dans-le-service", 
            "text": "Pour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio:   Clic-droit sur le service  Choisir  ESB Runtime Options  Cocher la case  \"Utiliser le Service Locator\"   Il faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9.", 
            "title": "2. Activer SL dans le service"
        }, 
        {
            "location": "/tp3/#3-activer-sl-dans-le-consommateur", 
            "text": "Au niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case  Use Service Locator .", 
            "title": "3. Activer SL dans le consommateur"
        }, 
        {
            "location": "/tp3/#test-du-service-locator", 
            "text": "Pour tester la r\u00e9partition de charges  : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat.  Pour tester la gestion du failover  : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper  list , puis chercher l'identifiant du service  HelloWorldService . Taper ensuite :  stop  id_service> . Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat.", 
            "title": "Test du Service Locator"
        }, 
        {
            "location": "/tp3/#service-monitoring", 
            "text": "Le composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes.  Pour configurer le Service Activity Monitoring:    D\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper :  tesb : start-sam  \n  Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services.    Activer la prise en compte de SAM au niveau du service cible   Configurer le consommateur du service pour prendre en compte le SAM   Pour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que  Db Visualizer .  Pour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants:   Database connection configuration (Default) : Derby/JavaDB  Driver : JavaDB/Derby Server  Database Server : localhost  Database Port : 1527  Database : DB  DB username : test  DB password : test   Ex\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat.", 
            "title": "Service Monitoring"
        }, 
        {
            "location": "/tp3/#authentification", 
            "text": "", 
            "title": "Authentification"
        }, 
        {
            "location": "/tp3/#security-token-service-sts-implementation-du-ws-trust", 
            "text": "Dans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust.  \"Trust\"  veut dire  \"Confiance\" : le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur.  Pour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service.  Le STS ( Security Token Service ) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes:   D\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s.  V\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification  Renouveler un jeton de s\u00e9curit\u00e9  Annuler un jeton de s\u00e9curit\u00e9  Transformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent.   L\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames.", 
            "title": "Security Token Service (STS) : Impl\u00e9mentation du WS-Trust"
        }, 
        {
            "location": "/tp3/#configuration-des-parametres-de-securite", 
            "text": "Pour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes:   D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend  Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur  Activer la prise en compte de STS dans votre service  Configurer votre client pour saisir les param\u00e8tres d\u2019authentification.", 
            "title": "Configuration des Param\u00e8tres de S\u00e9curit\u00e9"
        }, 
        {
            "location": "/tp3/#1-deployer-sts-dans-le-conteneur-dexecution", 
            "text": "Pour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal:      feature : install tesb-sts   Si le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande :  list . Vous devriez trouver les lignes suivantes:", 
            "title": "1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution"
        }, 
        {
            "location": "/tp3/#2-configurer-les-parametres-de-securite-de-votre-conteneur", 
            "text": "Comme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame.  Pour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier:  conteneur>/etc/users.properties .  Dans ce fichier, les informations d'authentification sont sous la forme:  user=password,group . Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe  admin .", 
            "title": "2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur"
        }, 
        {
            "location": "/tp3/#3-activer-sts-dans-votre-service", 
            "text": "Pour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans  ESB Runtime Options , cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas,  Identifiant/Mot de passe )", 
            "title": "3. Activer STS dans votre service"
        }, 
        {
            "location": "/tp3/#4-configurer-le-client", 
            "text": "Pour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.", 
            "title": "4. Configurer le client"
        }, 
        {
            "location": "/tp3/#homework", 
            "text": "Reprendre l'application que vous avez cr\u00e9\u00e9 dans le Homework pr\u00e9c\u00e9dent (celle du processus de recrutement), en d\u00e9ployant cette fois votre service (REST ou SOAP) sur deux conteneurs ESB, en d\u00e9finissant au moins une route, et en activant les diff\u00e9rentes fonctionnalit\u00e9s suppl\u00e9mentaires (SL, SAM et STS).", 
            "title": "Homework"
        }, 
        {
            "location": "/tp4/", 
            "text": "TP4 - Microservices avec Spring Boot et Spring Cloud\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\n\n\nCr\u00e9ation de microservices avec Spring Boot et Spring Cloud\n\n\nD\u00e9ploiement d'un microservices sur plusieurs instances\n\n\n\n\nAcknowledgement\n\n\nCe TP a \u00e9t\u00e9 largement inspir\u00e9 du travail d'un bin\u00f4me d'\u00e9tudiants en G\u00e9nie Logiciel \u00e0 l'INSAT, promotion 2017 (Houssem Ben Braiek et Hadhemi Jabnoun), que je tiens \u00e0 f\u00e9liciter et remercier.\n\n\nOutils et Versions\n\n\n\n\nSpring Boot\n Version: 1.5.8\n\n\nSpring Cloud\n Version 1.2.4\n\n\nJava\n Version 1.8.0_121\n\n\nMaven\n Version 3.5.2\n\n\nIntelliJ IDEA\n Version Ultimate 2016.1 (ou tout autre IDE de votre choix)\n\n\n\n\nArchitecture Microservices\n\n\nPr\u00e9sentation\n\n\nUne architecture \nMicroservices\n repr\u00e9sente un moyen de concevoir les applications comme ensemble de services ind\u00e9pendamment d\u00e9ployables. Ces services doivent de pr\u00e9f\u00e9rence \u00eatre organis\u00e9s autours des comp\u00e9tences m\u00e9tier, de d\u00e9ploiement automatique, d'extr\u00e9mit\u00e9s intelligentes et de contr\u00f4le d\u00e9centralis\u00e9 des technologies et des donn\u00e9es.\n\n\nArchitecture Propos\u00e9e\n\n\nL'objectif de ce travail est de montrer comment cr\u00e9er plusieurs services ind\u00e9pendamment d\u00e9ployables qui communiquent entre eux, en utilisant les facilit\u00e9s offertes par Spring Cloud et Spring Boot. \nSpring Cloud\n fournit des outils pour les d\u00e9veloppeurs pour construire rapidement et facilement des patrons communs de syst\u00e8mes r\u00e9partis (tel que des services de configuration, de d\u00e9couverte ou de routage intelligent). \nSpring Boot\n permet de son c\u00f4t\u00e9 de construire des applications Spring rapidement aussi rapidement que possible, en minimisant au maximum le temps de configuration, d'habitude p\u00e9nible, des applications Spring.\n\n\nNous allons donc cr\u00e9er les microservices suivants:\n\n\n\n\nProduct Service\n : Service principal, qui offre une API REST pour lister une liste de produits.\n\n\nConfig Service\n : Service de configuration, dont le r\u00f4le est de centraliser les fichiers de configuration des diff\u00e9rents microservices dans un endroit unique.\n\n\nProxy Service\n : Passerelle se chargeant du routage d'une requ\u00eate vers l'une des instances d'un service, de mani\u00e8re \u00e0 g\u00e9rer automatiquement la distribution de charge.\n\n\nDiscovery Service\n: Service permettant l'enregistrement des instances de services en vue d'\u00eatre d\u00e9couvertes par d'autres services.\n\n\n\n\nL'architecture r\u00e9sultante aura l'allure suivante:\n\n\n\n\nCr\u00e9ation des Microservices\n\n\nMicroservice \nProductService\n\n\nNous commen\u00e7ons par cr\u00e9er le service principal: \nProduct Service\n.\n\n\n\n\nChaque microservice sera sous forme d'un projet Spring. Pour cr\u00e9er rapidement et facilement un projet Spring avec toutes les d\u00e9pendances n\u00e9cessaires, Spring Boot fournit \nSpring Initializr\n.\n\n\nPour cela, aller au site \nstart.spring.io\n, et cr\u00e9er un projet avec les caract\u00e9ristiques suivantes:\n\n\n\n\nProjet Maven avec Java et Spring Boot version 1.5.8\n\n\nGroup: tn.insat.tpmicro\n\n\nArtifact: product-service\n\n\nD\u00e9pendances:\n\n\nWeb\n\n\nRest Repositories\n\n\nJPA : Java Persistence API\n\n\nH2 : base de donn\u00e9es pour le stockage\n\n\nActuator : pour le montoring et la gestion de l'application\n\n\nEureka Discovery : pour l'int\u00e9gration avec le \nDiscovery Service\n\n\nConfig Client : pour l'int\u00e9gration avec le \nConfig Service\n\n\n\n\n\n\n\n\nSuivre ensuite les \u00e9tapes suivantes pour cr\u00e9er le microservice \nProductService\n:\n\n\n\n\nOuvrir le projet t\u00e9l\u00e9charg\u00e9 avec IntelliJ IDEA.\n\n\nSous le r\u00e9pertoire \nsrc/main/java\n et dans le package \ntn.insat.tpmicro.productservice\n, cr\u00e9er la classe \nProduct\n suivante:\n\n\n\n\npackage\n \ntn.insat.tpmicro.productservice\n;\n\n\n\nimport\n \njavax.persistence.Entity\n;\n\n\nimport\n \njavax.persistence.GeneratedValue\n;\n\n\nimport\n \njavax.persistence.Id\n;\n\n\nimport\n \njava.io.Serializable\n;\n\n\n\n@Entity\n\n\npublic\n \nclass\n \nProduct\n \nimplements\n \nSerializable\n \n{\n\n    \n@Id\n\n    \n@GeneratedValue\n\n    \nprivate\n \nint\n \nid\n;\n\n    \nprivate\n \nString\n \nname\n;\n\n    \npublic\n \nProduct\n(){\n\n    \n}\n\n    \npublic\n \nProduct\n(\nString\n \nname\n)\n \n{\n\n        \nthis\n.\nname\n \n=\n \nname\n;\n\n    \n}\n\n    \npublic\n \nint\n \ngetId\n()\n \n{\n\n        \nreturn\n \nid\n;\n\n    \n}\n\n    \npublic\n \nvoid\n \nsetId\n(\nint\n \nid\n)\n \n{\n\n        \nthis\n.\nid\n \n=\n \nid\n;\n\n    \n}\n\n    \npublic\n \nString\n \ngetName\n()\n \n{\n\n        \nreturn\n \nname\n;\n\n    \n}\n\n    \npublic\n \nvoid\n \nsetName\n(\nString\n \nname\n)\n \n{\n\n        \nthis\n.\nname\n \n=\n \nname\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nCette classe est annot\u00e9e avec JPA, pour stocker ensuite les objets \nProduct\n dans la base de donn\u00e9es H2 gr\u00e2ce \u00e0 Spring Data. Pour cela, cr\u00e9er l'interface \nProductRepository\n dans le m\u00eame package:\n\n\npackage\n \ntn.insat.tpmicro.productservice\n;\n\n\n\nimport\n \norg.springframework.data.jpa.repository.JpaRepository\n;\n\n\n\npublic\n \ninterface\n \nProductRepository\n \nextends\n \nJpaRepository\nProduct\n \n,\n \nInteger\n \n{\n\n\n}\n\n\n\n\n\nPour ins\u00e9rer les objets dans la base, nous utiliserons l'objet \nStream\n. Pour cela, nous allons cr\u00e9er la classe \nDummyDataCLR\n :\n\n\npackage\n \ntn.insat.tpmicro.productservice\n;\n\n\n\nimport\n \norg.springframework.beans.factory.annotation.Autowired\n;\n\n\nimport\n \norg.springframework.boot.CommandLineRunner\n;\n\n\nimport\n \norg.springframework.stereotype.Component\n;\n\n\n\nimport\n \njava.util.stream.Stream\n;\n\n\n\n@Component\n\n\nclass\n \nDummyDataCLR\n \nimplements\n \nCommandLineRunner\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nString\n...\n \nstrings\n)\n \nthrows\n \nException\n \n{\n\n        \nStream\n.\nof\n(\nPencil\n,\n \nBook\n,\n \nEraser\n).\nforEach\n(\ns\n-\nproductRepository\n.\nsave\n(\nnew\n \nProduct\n(\ns\n)));\n\n        \nproductRepository\n.\nfindAll\n().\nforEach\n(\ns\n-\nSystem\n.\nout\n.\nprintln\n(\ns\n.\ngetName\n()));\n\n    \n}\n\n\n    \n@Autowired\n\n    \nprivate\n \nProductRepository\n \nproductRepository\n;\n\n\n\n}\n\n\n\n\n\nNous remarquons ici que le \nproductRepository\n sera instanci\u00e9 automatiquement gr\u00e2ce au m\u00e9canisme d'injection de d\u00e9pendances, utilis\u00e9 par Spring.\n\n\nLancer la classe principale. Une base de donn\u00e9es H2 sera cr\u00e9\u00e9e et le \nCommandLineRunner\n se chargera de lui injecter les donn\u00e9es.\n\n\n\n\nAttention\n\n\nPrenez soin d'utiliser JDK 8!\n\n\n\n\nPour ex\u00e9cuter votre application:\n\n\n\n\nCr\u00e9er une configuration \nmvn package\n en faisant \nRun-\nEdit Configurations\n puis en cr\u00e9ant une nouvelle configuration de type \nMaven\n avec la commande \npackage\n comme suit:\n\n\n\n\n\n\nUn r\u00e9pertoire \ntarget\n sera cr\u00e9\u00e9, contenant les classes g\u00e9n\u00e9r\u00e9es.\n\n\n\n\nLancer ensuite la configuration Spring Boot \nProductServiceApplication\n cr\u00e9\u00e9e par d\u00e9faut par IntelliJ. Le r\u00e9sultat sur la console devrait ressembler \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\nTip\n\n\nPour \u00e9viter de lancer \u00e0 chaque fois les deux configurations, ajouter dans la deuxi\u00e8me configuration une d\u00e9pendance vers la premi\u00e8re, rajouter cette derni\u00e8re dans la case \nBefore Launch: Build, Maven Goal, Activate Tool Window\n, comme suit:\n\n\n\n\n\n\nPour tester votre application, ouvrir la page \nhttp://localhost:8080\n sur le navigateur. Vous obtiendrez (si tout se passe bien) le r\u00e9sultat suivant:\n\n\n\n\nVous remarquerez que le service REST cr\u00e9\u00e9 respecte automatiquement la norme \nHATEOAS\n, qui offre dans les services REST, les liens pour naviguer dynamiquement entre les interfaces.\n\n\nSi vous naviguez vers la page \nhttp://localhost:8080/products\n, vous verrez la liste des produits, inject\u00e9s par le CLR, comme suit:\n\n\n\n\nPour voir les informations relatives \u00e0 un seul produit, il suffit de conna\u00eetre son ID: \nhttp://localhost:8080/products/1\n, par exemple.\n\n\nPour rajouter une fonctionnalit\u00e9 de recherche par nom, par exemple, modifier l'interface \nProductRepository\n, comme suit:\n\n\npackage\n \ntn.insat.tpmicro.productservice\n;\n\n\n\nimport\n \norg.springframework.data.domain.Page\n;\n\n\nimport\n \norg.springframework.data.domain.Pageable\n;\n\n\nimport\n \norg.springframework.data.jpa.repository.JpaRepository\n;\n\n\nimport\n \norg.springframework.data.jpa.repository.Query\n;\n\n\nimport\n \norg.springframework.data.repository.query.Param\n;\n\n\nimport\n \norg.springframework.data.rest.core.annotation.RepositoryRestResource\n;\n\n\n\n@RepositoryRestResource\n\n\npublic\n \ninterface\n \nProductRepository\n \nextends\n \nJpaRepository\nProduct\n \n,\n \nInteger\n \n{\n\n\n    \n@Query\n(\nselect p from Product p where p.name like :name\n)\n\n    \npublic\n \nPage\nProduct\n \nproductByName\n(\n@Param\n(\nname\n)\n \nString\n \nmc\n\n            \n,\n \nPageable\n \npageable\n);\n\n\n}\n\n\n\nPour tester cette fonctionnalit\u00e9 de recherche, aller au lien \nhttp://localhost:8080/products/search/productByName?name=Eraser\n\n\nLe r\u00e9sultat obtenu sera le suivant:\n\n\n\n\nLa d\u00e9pendance \nActuator\n qui a \u00e9t\u00e9 rajout\u00e9e au projet permet d'afficher des informations sur votre API REST sans avoir \u00e0 impl\u00e9menter explicitement la fonctionnalit\u00e9. Par exemple, si vous allez vers \nhttp://localhost:8080/metrics\n, vous pourrez avoir plusieurs informations sur le microservice, tel que le nombre de threads, la capacit\u00e9 m\u00e9moire, la classe charg\u00e9e en m\u00e9moire, etc. Mais d'abord, rajouter les deux lignes suivantes au fichier \nsrc/main/resources/application.properties\n pour (1) afficher des informations plus d\u00e9taill\u00e9es sur l'\u00e9tat du service et (2) d\u00e9sactiver les contraintes de s\u00e9curit\u00e9 par d\u00e9faut:\n\n\n  endpoints.health.sensitive\n \n=\n \nfalse\n\n\n  management.security.enabled\n \n=\n \nfalse\n\n\n\n\n\nRelancer le projet. Le r\u00e9sultat obtenu en ex\u00e9cutant \nhttp://localhost:8080/metrics\n sera comme suit:\n\n\n\n\nLes informations sur l'\u00e9tat du service sont affich\u00e9es gr\u00e2ce \u00e0 \nhttp://localhost:8080/health\n\n\n\n\nPlusieurs Instances du Microservice \nProductService\n\n\nNous allons maintenant cr\u00e9er d'autres instances du m\u00eame service et les d\u00e9ployer sur des ports diff\u00e9rents.\n\n\n\n\nPour lancer plusieurs instances du service \nProductService\n, nous allons d\u00e9finir plusieurs configurations avec des num\u00e9ros de port diff\u00e9rents. Pour cela:\n\n\n\n\nAller \u00e0 \nRun-\nEdit Configurations\n, et copier la configuration \nProductServiceApplication\n en la s\u00e9lectionnant dans la barre lat\u00e9rale, et en cliquant sur l'ic\u00f4ne \n. Une nouvelle configuration sera cr\u00e9\u00e9e.\n\n\nChanger son nom: \nProductServiceApplication:8081\n\n\nAjouter dans la case \nProgram Arguments\n l'argument suivant:\n\n\n\n\n--server.port\n=\n8081\n\n\n\n\n\n\n\nLancer la configuration. Un nouveau service sera disponible \u00e0 l'adresse: \nhttp://localhost:8081\n\n\n\n\n\n\nTip\n\n\nEn ex\u00e9cutant la seconde configuration, un popup s'affiche dans IntelliJ, qui vous demande si vous voulez afficher le dashboard pour visualiser plusieurs instances Spring Boot, comme suit:\n\n\n\n\nCliquer dessus, et choisir : \nShow Run Configurations in Dashboard\n. La vue suivante s'affiche, en bas de votre \u00e9cran:\n\n\n\n\nVous pouvez d\u00e9sormais g\u00e9rer vos instances dans cette fen\u00eatre.\n\n\n\n\n\n\nRefaire les m\u00eames \u00e9tapes pour cr\u00e9er une instance du service tourant sur le port 8082.\n\n\n\n\nMicroservice \nConfigService\n\n\nDans une architecture microservices, plusieurs services s'ex\u00e9cutent en m\u00eame temps, sur des processus diff\u00e9rents, avec chacun sa propre configuration et ses propres param\u00e8tres. Spring Cloud Config fournit un support c\u00f4t\u00e9 serveur et c\u00f4t\u00e9 client pour externaliser les configurations dans un syst\u00e8me distribu\u00e9. Gr\u00e2ce au service de configuration, il est possible d'avoir un endroit centralis\u00e9 pour g\u00e9rer les propri\u00e9t\u00e9s de chacun de ces services.\n\n\n\n\nPour cela:\n\n\n\n\nCommencer par cr\u00e9er un service ConfigService dans \nSpring Initializr\n, avec les d\u00e9pendances appropri\u00e9es, comme indiqu\u00e9 sur la figure suivante:\n\n\n\n\n\n\n\n\nOuvrir le projet dans une autre instance d'IntelliJ IDEA.\n\n\nPour exposer un service de configuration, utiliser l'annotation \n@EnableConfigServer\n pour la classe \nConfigServiceApplication\n, comme suit:\n\n\n\n\npackage\n \ntn.insat.tpmicro.configservice\n;\n\n\n\nimport\n \norg.springframework.boot.SpringApplication\n;\n\n\nimport\n \norg.springframework.boot.autoconfigure.SpringBootApplication\n;\n\n\nimport\n \norg.springframework.cloud.config.server.EnableConfigServer\n;\n\n\n\n@EnableConfigServer\n\n\n@SpringBootApplication\n\n\npublic\n \nclass\n \nConfigServiceApplication\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n\n        \nSpringApplication\n.\nrun\n(\nConfigServiceApplication\n.\nclass\n,\n \nargs\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nPour param\u00e9trer ce service de configuration, ajouter dans son fichier \napplication.properties\n les valeurs suivantes:\n\n\n\n\n  server.port\n=\n8888\n\n\n  spring.cloud.config.server.git.uri\n=\nfile:./src/main/resources/myConfig\n\n\n\n\n\nCeci indique que le service de configuration sera lanc\u00e9 sur le port 8888 et que le r\u00e9pertoire contenant les fichiers de configuration se trouve dans le r\u00e9pertoire \nsrc/main/resources/myConfig\n. Il suffit maintenant de cr\u00e9er ce r\u00e9pertoire.\n\n\n\n\nTip\n\n\nPour pouvoir r\u00e9f\u00e9rencer un r\u00e9pertoire avec son chemin absolu, utiliser plut\u00f4t \nfile:///\nchemin_absolu>\n.\n\n\n\n\n\n\nCr\u00e9er le r\u00e9pertoire \nmyConfig\n \u00e0 l'arborescence \nsrc/main/resources\n\n\nCr\u00e9er dans ce r\u00e9pertoire le fichier \napplication.properties\n dans lequel vous ins\u00e9rez l'instruction suivante:\n\n\n\n\nglobal\n=\nxxxxx\n\n\n\n\n\nCe fichier sera partag\u00e9 entre tous les microservices utilisant ce service de configuration.\n\n\n\n\nLe r\u00e9pertoire de configuration doit \u00eatre un r\u00e9pertoire git. Pour cela:\n\n\nOuvrir le terminal avec IntelliJ et naviguer vers ce r\u00e9pertoire.\n\n\nInitialiser votre r\u00e9pertoire: \ngit init\n\n\nCr\u00e9er une entr\u00e9e racine dans le repository: \ngit add .\n\n\nFaire un commit: \ngit commit -m \nadd .\n\n\n\n\n\n\n\n\nRevenir vers le projet \nProductService\n et ajouter dans le fichier de configuration \napplication.properties\n:\n\n\nspring.application.name\n \n=\n \nproduct-service\n\n\nspring.cloud.config.uri\n \n=\n \nhttp://localhost:8888\n\n\n\n\n\nRed\u00e9marrer vos services. Pour consulter le service de configuration, aller \u00e0 \nhttp://localhost:8888/product-service/master\n.\n\n\nVous verrez le fichier JSON suivant:\n\n\n{\n\n  \nname\n:\n \nproduct-service\n,\n\n  \nprofiles\n:\n \n[\n\n    \nmaster\n\n  \n],\n\n  \nlabel\n:\n \nnull\n,\n\n  \nversion\n:\n \n6e1ea61d706133e2d8b62f40c6b784192fb58e8a\n,\n\n  \nstate\n:\n \nnull\n,\n\n  \npropertySources\n:\n \n[\n\n    \n{\n\n      \nname\n:\n \nfile:./src/main/resources/myConfig/application.properties\n,\n\n      \nsource\n:\n \n{\n\n        \nglobal\n:\n \nxxxxx\n\n      \n}\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\nComme le fichier \napplication.properties\n contient toutes les propri\u00e9t\u00e9s partag\u00e9es des diff\u00e9rents microservices, nous aurons besoins d'autres fichiers pour les propri\u00e9t\u00e9s sp\u00e9cifiques \u00e0 un microservice. Pour cela:\n\n\n\n\nCr\u00e9er dans le r\u00e9pertoire \nmyConfig\n un fichier \nproduct-service.properties\n pour le service \nProductService\n.\n\n\n\n\n\n\nAttention\n\n\nLe nom du fichier doit correspondre \u00e0 la propri\u00e9t\u00e9 \nspring.application.name\n que vous avez saisi dans le fichier \napplication.properties\n de votre microservices!\n\n\n\n\n\n\nAjouter les propri\u00e9t\u00e9s de votre service, \u00e0 savoir, par exemple:\n\n\n\n\n  me\n=\nlilia.sfaxi@insat.rnu.tn\n\n\n\n\n\nRelancer le microservice de configuration. En consultant l'url \nhttp://localhost:8888/product-service/master\n, nous remarquons l'ajout de la nouvelle propri\u00e9t\u00e9.\n\n\n{\n\n  \nname\n:\n \nproduct-service\n,\n\n  \nprofiles\n:\n \n[\n\n    \nmaster\n\n  \n],\n\n  \nlabel\n:\n \nnull\n,\n\n  \nversion\n:\n \n6e1ea61d706133e2d8b62f40c6b784192fb58e8a\n,\n\n  \nstate\n:\n \nnull\n,\n\n  \npropertySources\n:\n \n[\n\n    \n{\n\n      \nname\n:\n \nfile:./src/main/resources/myConfig/product-service.properties\n,\n\n      \nsource\n:\n \n{\n\n\n        \nme\n:\n \nlilia.sfaxi@insat.rnu.tn\n\n\n      \n}\n\n    \n},\n\n    \n{\n\n      \nname\n:\n \nfile:./src/main/resources/myConfig/application.properties\n,\n\n      \nsource\n:\n \n{\n\n        \nglobal\n:\n \nxxxxx\n\n      \n}\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\n\nNous allons maintenant d\u00e9finir un appel REST \u00e0 cette propri\u00e9t\u00e9. Pour cela:\n\n\n\n\nCr\u00e9er la classe \nProductRestService\n dans le projet \nproduct-service\n. Son code ressemblera \u00e0 ce qui suit:\n\n\n\n\npackage\n \ntn.insat.tpmicro.productservice\n;\n\n\n\nimport\n \norg.springframework.beans.factory.annotation.Value\n;\n\n\nimport\n \norg.springframework.web.bind.annotation.RequestMapping\n;\n\n\nimport\n \norg.springframework.web.bind.annotation.RestController\n;\n\n\n\n@RestController\n\n\npublic\n \nclass\n \nProductRestService\n \n{\n\n\n  \n@Value\n(\n${me}\n)\n\n  \nprivate\n \nString\n \nme\n;\n\n\n  \n@RequestMapping\n(\n/messages\n)\n\n  \npublic\n \nString\n \ntellMe\n(){\n\n      \nSystem\n.\nout\n.\nprintln\n(\nc\nest moi qui ait r\u00e9pondu!\n);\n\n      \nreturn\n \nme\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nRed\u00e9marrer les trois instances du service, puis appeler dans votre navigateur le service en tapant: \nhttp://localhost:8080/messages\n. Vous verrez le r\u00e9sultat suivant sur le navigateur:\n\n\n\n\n\n\n\n\nConsulter votre Spring Dashboard, vous verrez le message suivant dans la console de l'instance du service lanc\u00e9e sur le port 8080:\n\n\n\n\n\n\nMicroservice \nDiscoveryService\n\n\nPour \u00e9viter un couplage fort entre microservices, il est fortement recommand\u00e9 d'utiliser un service de d\u00e9couverte qui permet d'enregistrer les propri\u00e9t\u00e9s des diff\u00e9rents services et d'\u00e9viter ainsi d'avoir \u00e0 appeler un service directement. Au lieu de cela, le service de d\u00e9couverte fournira dynamiquement les informations n\u00e9cessaires, ce qui permet d'assurer l'\u00e9lasticit\u00e9 et la dynamicit\u00e9 propres \u00e0 une architecture microservices.\n\n\n\n\nPour r\u00e9aliser cela, Netflix offre le service \nEureka Service Registration and Discovery\n, que nous allons utiliser dans notre application.\n\n\n\n\nRevenir \u00e0 \nSpring Initializr\n et cr\u00e9er un nouveau projet Spring Boot intitul\u00e9 \ndiscovery-service\n avec les d\u00e9pendances \nEureka Server\n et \nConfig Client\n.\n\n\nLancer le projet avec IntelliJ.\n\n\nDans la classe \nDiscoveryServiceApplication\n, ajouter l'annotation \nEnableEurekaServer\n.\n\n\n\n\npackage\n \ntn.insat.tpmicro.discoveryservice\n;\n\n\n\nimport\n \norg.springframework.boot.SpringApplication\n;\n\n\nimport\n \norg.springframework.boot.autoconfigure.SpringBootApplication\n;\n\n\nimport\n \norg.springframework.cloud.netflix.eureka.server.EnableEurekaServer\n;\n\n\n\n@EnableEurekaServer\n\n\n@SpringBootApplication\n\n\npublic\n \nclass\n \nDiscoveryServiceApplication\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nSpringApplication\n.\nrun\n(\nDiscoveryServiceApplication\n.\nclass\n,\n \nargs\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nAjouter les propri\u00e9t\u00e9s suivantes dans son fichier \napplication.properties\n.\n\n\n\n\nspring.application.name\n=\ndiscovery-service\n\n\nspring.cloud.config.uri\n=\nhttp://localhost:8888\n\n\n\n\n\n\n\nDans le projet \nconfig-service\n, cr\u00e9er un fichier \ndiscovery-service.properties\n sous le r\u00e9pertoire \nmyConfig\n.\n\n\nAjouter les propri\u00e9t\u00e9s suivantes pour (1) d\u00e9finir le port par d\u00e9faut du service de d\u00e9couverte et (2) emp\u00eacher un auto-enregistrement du service Eureka.\n\n\n\n\nserver.port\n \n=\n \n8761\n\n\neureka.client.fetch-registry\n \n=\n \nfalse\n\n\neureka.client.register-with-eureka\n \n=\n \nfalse\n\n\n\n\n\nPour consulter le service Eureka, aller \u00e0 \nhttp://localhost:8761\n, l'interface suivante s'affiche:\n\n\n\n\nNous remarquons qu'aucune instance n'est inscrite dans le serveur de d\u00e9couverte. Nous allons donc modifier le code de la classe \nProductServiceApplication\n pour que le microservice \nProductService\n s'enregistre:\n\n\npackage\n \ntn.insat.tpmicro.productservice\n;\n\n\n\nimport\n \norg.springframework.boot.SpringApplication\n;\n\n\nimport\n \norg.springframework.boot.autoconfigure.SpringBootApplication\n;\n\n\nimport\n \norg.springframework.cloud.client.discovery.EnableDiscoveryClient\n;\n\n\n\n@EnableDiscoveryClient\n\n\n@SpringBootApplication\n\n\npublic\n \nclass\n \nProductServiceApplication\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nSpringApplication\n.\nrun\n(\nProductServiceApplication\n.\nclass\n,\n \nargs\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nRed\u00e9marrer les trois instances de services \nProductService\n et actualiser la fen\u00eatre de \nEureka\n, vous verrez qu'un seul service est d\u00e9clar\u00e9, avec trois adresses diff\u00e9rentes.\n\n\n\n\nMicroservice \nProxyService\n\n\nL'architecture microservice, en fournissant un ensemble de services ind\u00e9pendants et faiblement coupl\u00e9s, se trouve confront\u00e9e au challenge de fournir une interface unifi\u00e9e pour les consommateurs, de mani\u00e8re \u00e0 ce qu'ils ne voient pas la d\u00e9composition \u00e0 faible granularit\u00e9 de vos services. C'est pour cela que l'utilisation d'un service proxy, responsable du routage des requ\u00eates et de la r\u00e9partition de charge, est important.\n\n\n\n\nNetflix offre le service \nZuul\n pour r\u00e9aliser cela. Pour cr\u00e9er votre microservice Proxy:\n\n\n\n\nAller \u00e0 \nSpring Initializr\n.\n\n\nCr\u00e9er le projet \nproxy-service\n avec les d\u00e9pendances suivantes: Zuul, Web, HATEOAS, Actuator, Config Client et Eureka Discovery.\n\n\nOuvrir le service avec IntelliJ IDEA.\n\n\nAjouter \u00e0 la classe \nProxyServiceApplication\n l'annotation \n@EnableZuulProxy\n, ainsi que \n@EnableDiscoveryClient\n pour que le proxy soit \u00e9galement enregistr\u00e9 dans le service ce d\u00e9couverte.\n\n\nAjouter les propri\u00e9t\u00e9s \nspring.application.name\n  et \nspring.cloud.config.uri\n dans le fichier \napplication.properties\n du service proxy.\n\n\nCr\u00e9er le fichier \nproxy-service.properties\n dans le r\u00e9pertoire \nmyConfig\n du service de configuration, dans lequel vous allez fixer le port du service proxy \u00e0 9999.\n\n\n\n\nEn lan\u00e7ant le service Proxy, vous remarquerez qu'il est rajout\u00e9 dans Eureka.\n\n\n\n\nSi vous ex\u00e9cutez la requ\u00eate \nhttp://localhost:9999/product-service/messages\n plusieurs fois, vous remarquerez que l'affichage \nc'est moi qui ait r\u00e9pondu!\n s'affichera sur les consoles des trois instances respectivement, \u00e0 tour de r\u00f4le.\n\n\nHomework\n\n\nLe concept de microservices est tr\u00e8s fortement li\u00e9 \u00e0 la culture DevOps, et \u00e0 la conteneurisation. Gr\u00e2ce aux conteneurs, vous n\u2019avez pas besoin de d\u00e9velopper et de configurer enti\u00e8rement un nouveau serveur physique, ni de mettre sur pied un nouvel environnement virtuel, ce qui requiert une \u00e9mulation de processeur, un syst\u00e8me d\u2019exploitation et des logiciels install\u00e9s. Le conteneur vous permet de faire tenir un environnement complet dans une seule image l\u00e9g\u00e8re.\n\n\nC'est pour cela que votre t\u00e2che pour la s\u00e9ance prochaine sera de \ndockeriser\n les diff\u00e9rents microservices que nous venons de cr\u00e9er, au lieu de les lancer sur notre machine physique (localhost). Les trois instances du service ProductService, ainsi que les trois autres services (Discovery, Config et Proxy) doivent tourner ind\u00e9pendamment, chacun dans soon propre contenaire.\n\n\nVous devez fournir chacun un lien vers un projet \nGithub\n contenant vos projets, ainsi qu'un \nReadme\n en bonne et due forme (respecter la norme Markdown svp) montrant les \u00e9tapes de conteneurisation des services. Chaque bin\u00f4me devra fournir son lien dans le fichier excel intitul\u00e9 \nHomework\n que vous trouverez dans \nPiazza\n.", 
            "title": "TP4 - Microservices avec Spring Boot et Spring Cloud"
        }, 
        {
            "location": "/tp4/#tp4-microservices-avec-spring-boot-et-spring-cloud", 
            "text": "", 
            "title": "TP4 - Microservices avec Spring Boot et Spring Cloud"
        }, 
        {
            "location": "/tp4/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp4/#objectifs-du-tp", 
            "text": "Cr\u00e9ation de microservices avec Spring Boot et Spring Cloud  D\u00e9ploiement d'un microservices sur plusieurs instances", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp4/#acknowledgement", 
            "text": "Ce TP a \u00e9t\u00e9 largement inspir\u00e9 du travail d'un bin\u00f4me d'\u00e9tudiants en G\u00e9nie Logiciel \u00e0 l'INSAT, promotion 2017 (Houssem Ben Braiek et Hadhemi Jabnoun), que je tiens \u00e0 f\u00e9liciter et remercier.", 
            "title": "Acknowledgement"
        }, 
        {
            "location": "/tp4/#outils-et-versions", 
            "text": "Spring Boot  Version: 1.5.8  Spring Cloud  Version 1.2.4  Java  Version 1.8.0_121  Maven  Version 3.5.2  IntelliJ IDEA  Version Ultimate 2016.1 (ou tout autre IDE de votre choix)", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp4/#architecture-microservices", 
            "text": "", 
            "title": "Architecture Microservices"
        }, 
        {
            "location": "/tp4/#presentation", 
            "text": "Une architecture  Microservices  repr\u00e9sente un moyen de concevoir les applications comme ensemble de services ind\u00e9pendamment d\u00e9ployables. Ces services doivent de pr\u00e9f\u00e9rence \u00eatre organis\u00e9s autours des comp\u00e9tences m\u00e9tier, de d\u00e9ploiement automatique, d'extr\u00e9mit\u00e9s intelligentes et de contr\u00f4le d\u00e9centralis\u00e9 des technologies et des donn\u00e9es.", 
            "title": "Pr\u00e9sentation"
        }, 
        {
            "location": "/tp4/#architecture-proposee", 
            "text": "L'objectif de ce travail est de montrer comment cr\u00e9er plusieurs services ind\u00e9pendamment d\u00e9ployables qui communiquent entre eux, en utilisant les facilit\u00e9s offertes par Spring Cloud et Spring Boot.  Spring Cloud  fournit des outils pour les d\u00e9veloppeurs pour construire rapidement et facilement des patrons communs de syst\u00e8mes r\u00e9partis (tel que des services de configuration, de d\u00e9couverte ou de routage intelligent).  Spring Boot  permet de son c\u00f4t\u00e9 de construire des applications Spring rapidement aussi rapidement que possible, en minimisant au maximum le temps de configuration, d'habitude p\u00e9nible, des applications Spring.  Nous allons donc cr\u00e9er les microservices suivants:   Product Service  : Service principal, qui offre une API REST pour lister une liste de produits.  Config Service  : Service de configuration, dont le r\u00f4le est de centraliser les fichiers de configuration des diff\u00e9rents microservices dans un endroit unique.  Proxy Service  : Passerelle se chargeant du routage d'une requ\u00eate vers l'une des instances d'un service, de mani\u00e8re \u00e0 g\u00e9rer automatiquement la distribution de charge.  Discovery Service : Service permettant l'enregistrement des instances de services en vue d'\u00eatre d\u00e9couvertes par d'autres services.   L'architecture r\u00e9sultante aura l'allure suivante:", 
            "title": "Architecture Propos\u00e9e"
        }, 
        {
            "location": "/tp4/#creation-des-microservices", 
            "text": "", 
            "title": "Cr\u00e9ation des Microservices"
        }, 
        {
            "location": "/tp4/#microservice-productservice", 
            "text": "Nous commen\u00e7ons par cr\u00e9er le service principal:  Product Service .   Chaque microservice sera sous forme d'un projet Spring. Pour cr\u00e9er rapidement et facilement un projet Spring avec toutes les d\u00e9pendances n\u00e9cessaires, Spring Boot fournit  Spring Initializr .  Pour cela, aller au site  start.spring.io , et cr\u00e9er un projet avec les caract\u00e9ristiques suivantes:   Projet Maven avec Java et Spring Boot version 1.5.8  Group: tn.insat.tpmicro  Artifact: product-service  D\u00e9pendances:  Web  Rest Repositories  JPA : Java Persistence API  H2 : base de donn\u00e9es pour le stockage  Actuator : pour le montoring et la gestion de l'application  Eureka Discovery : pour l'int\u00e9gration avec le  Discovery Service  Config Client : pour l'int\u00e9gration avec le  Config Service     Suivre ensuite les \u00e9tapes suivantes pour cr\u00e9er le microservice  ProductService :   Ouvrir le projet t\u00e9l\u00e9charg\u00e9 avec IntelliJ IDEA.  Sous le r\u00e9pertoire  src/main/java  et dans le package  tn.insat.tpmicro.productservice , cr\u00e9er la classe  Product  suivante:   package   tn.insat.tpmicro.productservice ;  import   javax.persistence.Entity ;  import   javax.persistence.GeneratedValue ;  import   javax.persistence.Id ;  import   java.io.Serializable ;  @Entity  public   class   Product   implements   Serializable   { \n     @Id \n     @GeneratedValue \n     private   int   id ; \n     private   String   name ; \n     public   Product (){ \n     } \n     public   Product ( String   name )   { \n         this . name   =   name ; \n     } \n     public   int   getId ()   { \n         return   id ; \n     } \n     public   void   setId ( int   id )   { \n         this . id   =   id ; \n     } \n     public   String   getName ()   { \n         return   name ; \n     } \n     public   void   setName ( String   name )   { \n         this . name   =   name ; \n     }  }   Cette classe est annot\u00e9e avec JPA, pour stocker ensuite les objets  Product  dans la base de donn\u00e9es H2 gr\u00e2ce \u00e0 Spring Data. Pour cela, cr\u00e9er l'interface  ProductRepository  dans le m\u00eame package:  package   tn.insat.tpmicro.productservice ;  import   org.springframework.data.jpa.repository.JpaRepository ;  public   interface   ProductRepository   extends   JpaRepository Product   ,   Integer   {  }   Pour ins\u00e9rer les objets dans la base, nous utiliserons l'objet  Stream . Pour cela, nous allons cr\u00e9er la classe  DummyDataCLR  :  package   tn.insat.tpmicro.productservice ;  import   org.springframework.beans.factory.annotation.Autowired ;  import   org.springframework.boot.CommandLineRunner ;  import   org.springframework.stereotype.Component ;  import   java.util.stream.Stream ;  @Component  class   DummyDataCLR   implements   CommandLineRunner   { \n\n     @Override \n     public   void   run ( String ...   strings )   throws   Exception   { \n         Stream . of ( Pencil ,   Book ,   Eraser ). forEach ( s - productRepository . save ( new   Product ( s ))); \n         productRepository . findAll (). forEach ( s - System . out . println ( s . getName ())); \n     } \n\n     @Autowired \n     private   ProductRepository   productRepository ;  }   Nous remarquons ici que le  productRepository  sera instanci\u00e9 automatiquement gr\u00e2ce au m\u00e9canisme d'injection de d\u00e9pendances, utilis\u00e9 par Spring.  Lancer la classe principale. Une base de donn\u00e9es H2 sera cr\u00e9\u00e9e et le  CommandLineRunner  se chargera de lui injecter les donn\u00e9es.   Attention  Prenez soin d'utiliser JDK 8!   Pour ex\u00e9cuter votre application:   Cr\u00e9er une configuration  mvn package  en faisant  Run- Edit Configurations  puis en cr\u00e9ant une nouvelle configuration de type  Maven  avec la commande  package  comme suit:    Un r\u00e9pertoire  target  sera cr\u00e9\u00e9, contenant les classes g\u00e9n\u00e9r\u00e9es.   Lancer ensuite la configuration Spring Boot  ProductServiceApplication  cr\u00e9\u00e9e par d\u00e9faut par IntelliJ. Le r\u00e9sultat sur la console devrait ressembler \u00e0 ce qui suit:     Tip  Pour \u00e9viter de lancer \u00e0 chaque fois les deux configurations, ajouter dans la deuxi\u00e8me configuration une d\u00e9pendance vers la premi\u00e8re, rajouter cette derni\u00e8re dans la case  Before Launch: Build, Maven Goal, Activate Tool Window , comme suit:    Pour tester votre application, ouvrir la page  http://localhost:8080  sur le navigateur. Vous obtiendrez (si tout se passe bien) le r\u00e9sultat suivant:   Vous remarquerez que le service REST cr\u00e9\u00e9 respecte automatiquement la norme  HATEOAS , qui offre dans les services REST, les liens pour naviguer dynamiquement entre les interfaces.  Si vous naviguez vers la page  http://localhost:8080/products , vous verrez la liste des produits, inject\u00e9s par le CLR, comme suit:   Pour voir les informations relatives \u00e0 un seul produit, il suffit de conna\u00eetre son ID:  http://localhost:8080/products/1 , par exemple.  Pour rajouter une fonctionnalit\u00e9 de recherche par nom, par exemple, modifier l'interface  ProductRepository , comme suit:  package   tn.insat.tpmicro.productservice ;  import   org.springframework.data.domain.Page ;  import   org.springframework.data.domain.Pageable ;  import   org.springframework.data.jpa.repository.JpaRepository ;  import   org.springframework.data.jpa.repository.Query ;  import   org.springframework.data.repository.query.Param ;  import   org.springframework.data.rest.core.annotation.RepositoryRestResource ;  @RepositoryRestResource  public   interface   ProductRepository   extends   JpaRepository Product   ,   Integer   { \n\n     @Query ( select p from Product p where p.name like :name ) \n     public   Page Product   productByName ( @Param ( name )   String   mc \n             ,   Pageable   pageable );  }  \nPour tester cette fonctionnalit\u00e9 de recherche, aller au lien  http://localhost:8080/products/search/productByName?name=Eraser  Le r\u00e9sultat obtenu sera le suivant:   La d\u00e9pendance  Actuator  qui a \u00e9t\u00e9 rajout\u00e9e au projet permet d'afficher des informations sur votre API REST sans avoir \u00e0 impl\u00e9menter explicitement la fonctionnalit\u00e9. Par exemple, si vous allez vers  http://localhost:8080/metrics , vous pourrez avoir plusieurs informations sur le microservice, tel que le nombre de threads, la capacit\u00e9 m\u00e9moire, la classe charg\u00e9e en m\u00e9moire, etc. Mais d'abord, rajouter les deux lignes suivantes au fichier  src/main/resources/application.properties  pour (1) afficher des informations plus d\u00e9taill\u00e9es sur l'\u00e9tat du service et (2) d\u00e9sactiver les contraintes de s\u00e9curit\u00e9 par d\u00e9faut:    endpoints.health.sensitive   =   false    management.security.enabled   =   false   Relancer le projet. Le r\u00e9sultat obtenu en ex\u00e9cutant  http://localhost:8080/metrics  sera comme suit:   Les informations sur l'\u00e9tat du service sont affich\u00e9es gr\u00e2ce \u00e0  http://localhost:8080/health", 
            "title": "Microservice ProductService"
        }, 
        {
            "location": "/tp4/#plusieurs-instances-du-microservice-productservice", 
            "text": "Nous allons maintenant cr\u00e9er d'autres instances du m\u00eame service et les d\u00e9ployer sur des ports diff\u00e9rents.   Pour lancer plusieurs instances du service  ProductService , nous allons d\u00e9finir plusieurs configurations avec des num\u00e9ros de port diff\u00e9rents. Pour cela:   Aller \u00e0  Run- Edit Configurations , et copier la configuration  ProductServiceApplication  en la s\u00e9lectionnant dans la barre lat\u00e9rale, et en cliquant sur l'ic\u00f4ne  . Une nouvelle configuration sera cr\u00e9\u00e9e.  Changer son nom:  ProductServiceApplication:8081  Ajouter dans la case  Program Arguments  l'argument suivant:   --server.port = 8081    Lancer la configuration. Un nouveau service sera disponible \u00e0 l'adresse:  http://localhost:8081    Tip  En ex\u00e9cutant la seconde configuration, un popup s'affiche dans IntelliJ, qui vous demande si vous voulez afficher le dashboard pour visualiser plusieurs instances Spring Boot, comme suit:   Cliquer dessus, et choisir :  Show Run Configurations in Dashboard . La vue suivante s'affiche, en bas de votre \u00e9cran:   Vous pouvez d\u00e9sormais g\u00e9rer vos instances dans cette fen\u00eatre.    Refaire les m\u00eames \u00e9tapes pour cr\u00e9er une instance du service tourant sur le port 8082.", 
            "title": "Plusieurs Instances du Microservice ProductService"
        }, 
        {
            "location": "/tp4/#microservice-configservice", 
            "text": "Dans une architecture microservices, plusieurs services s'ex\u00e9cutent en m\u00eame temps, sur des processus diff\u00e9rents, avec chacun sa propre configuration et ses propres param\u00e8tres. Spring Cloud Config fournit un support c\u00f4t\u00e9 serveur et c\u00f4t\u00e9 client pour externaliser les configurations dans un syst\u00e8me distribu\u00e9. Gr\u00e2ce au service de configuration, il est possible d'avoir un endroit centralis\u00e9 pour g\u00e9rer les propri\u00e9t\u00e9s de chacun de ces services.   Pour cela:   Commencer par cr\u00e9er un service ConfigService dans  Spring Initializr , avec les d\u00e9pendances appropri\u00e9es, comme indiqu\u00e9 sur la figure suivante:     Ouvrir le projet dans une autre instance d'IntelliJ IDEA.  Pour exposer un service de configuration, utiliser l'annotation  @EnableConfigServer  pour la classe  ConfigServiceApplication , comme suit:   package   tn.insat.tpmicro.configservice ;  import   org.springframework.boot.SpringApplication ;  import   org.springframework.boot.autoconfigure.SpringBootApplication ;  import   org.springframework.cloud.config.server.EnableConfigServer ;  @EnableConfigServer  @SpringBootApplication  public   class   ConfigServiceApplication   { \n\n     public   static   void   main ( String []   args )   { \n\n         SpringApplication . run ( ConfigServiceApplication . class ,   args ); \n     }  }    Pour param\u00e9trer ce service de configuration, ajouter dans son fichier  application.properties  les valeurs suivantes:     server.port = 8888    spring.cloud.config.server.git.uri = file:./src/main/resources/myConfig   Ceci indique que le service de configuration sera lanc\u00e9 sur le port 8888 et que le r\u00e9pertoire contenant les fichiers de configuration se trouve dans le r\u00e9pertoire  src/main/resources/myConfig . Il suffit maintenant de cr\u00e9er ce r\u00e9pertoire.   Tip  Pour pouvoir r\u00e9f\u00e9rencer un r\u00e9pertoire avec son chemin absolu, utiliser plut\u00f4t  file:/// chemin_absolu> .    Cr\u00e9er le r\u00e9pertoire  myConfig  \u00e0 l'arborescence  src/main/resources  Cr\u00e9er dans ce r\u00e9pertoire le fichier  application.properties  dans lequel vous ins\u00e9rez l'instruction suivante:   global = xxxxx   Ce fichier sera partag\u00e9 entre tous les microservices utilisant ce service de configuration.   Le r\u00e9pertoire de configuration doit \u00eatre un r\u00e9pertoire git. Pour cela:  Ouvrir le terminal avec IntelliJ et naviguer vers ce r\u00e9pertoire.  Initialiser votre r\u00e9pertoire:  git init  Cr\u00e9er une entr\u00e9e racine dans le repository:  git add .  Faire un commit:  git commit -m  add .     Revenir vers le projet  ProductService  et ajouter dans le fichier de configuration  application.properties :  spring.application.name   =   product-service  spring.cloud.config.uri   =   http://localhost:8888   Red\u00e9marrer vos services. Pour consulter le service de configuration, aller \u00e0  http://localhost:8888/product-service/master .  Vous verrez le fichier JSON suivant:  { \n   name :   product-service , \n   profiles :   [ \n     master \n   ], \n   label :   null , \n   version :   6e1ea61d706133e2d8b62f40c6b784192fb58e8a , \n   state :   null , \n   propertySources :   [ \n     { \n       name :   file:./src/main/resources/myConfig/application.properties , \n       source :   { \n         global :   xxxxx \n       } \n     } \n   ]  }   Comme le fichier  application.properties  contient toutes les propri\u00e9t\u00e9s partag\u00e9es des diff\u00e9rents microservices, nous aurons besoins d'autres fichiers pour les propri\u00e9t\u00e9s sp\u00e9cifiques \u00e0 un microservice. Pour cela:   Cr\u00e9er dans le r\u00e9pertoire  myConfig  un fichier  product-service.properties  pour le service  ProductService .    Attention  Le nom du fichier doit correspondre \u00e0 la propri\u00e9t\u00e9  spring.application.name  que vous avez saisi dans le fichier  application.properties  de votre microservices!    Ajouter les propri\u00e9t\u00e9s de votre service, \u00e0 savoir, par exemple:     me = lilia.sfaxi@insat.rnu.tn   Relancer le microservice de configuration. En consultant l'url  http://localhost:8888/product-service/master , nous remarquons l'ajout de la nouvelle propri\u00e9t\u00e9.  { \n   name :   product-service , \n   profiles :   [ \n     master \n   ], \n   label :   null , \n   version :   6e1ea61d706133e2d8b62f40c6b784192fb58e8a , \n   state :   null , \n   propertySources :   [ \n     { \n       name :   file:./src/main/resources/myConfig/product-service.properties , \n       source :   {           me :   lilia.sfaxi@insat.rnu.tn         } \n     }, \n     { \n       name :   file:./src/main/resources/myConfig/application.properties , \n       source :   { \n         global :   xxxxx \n       } \n     } \n   ]  }   Nous allons maintenant d\u00e9finir un appel REST \u00e0 cette propri\u00e9t\u00e9. Pour cela:   Cr\u00e9er la classe  ProductRestService  dans le projet  product-service . Son code ressemblera \u00e0 ce qui suit:   package   tn.insat.tpmicro.productservice ;  import   org.springframework.beans.factory.annotation.Value ;  import   org.springframework.web.bind.annotation.RequestMapping ;  import   org.springframework.web.bind.annotation.RestController ;  @RestController  public   class   ProductRestService   { \n\n   @Value ( ${me} ) \n   private   String   me ; \n\n   @RequestMapping ( /messages ) \n   public   String   tellMe (){ \n       System . out . println ( c est moi qui ait r\u00e9pondu! ); \n       return   me ; \n   }  }    Red\u00e9marrer les trois instances du service, puis appeler dans votre navigateur le service en tapant:  http://localhost:8080/messages . Vous verrez le r\u00e9sultat suivant sur le navigateur:     Consulter votre Spring Dashboard, vous verrez le message suivant dans la console de l'instance du service lanc\u00e9e sur le port 8080:", 
            "title": "Microservice ConfigService"
        }, 
        {
            "location": "/tp4/#microservice-discoveryservice", 
            "text": "Pour \u00e9viter un couplage fort entre microservices, il est fortement recommand\u00e9 d'utiliser un service de d\u00e9couverte qui permet d'enregistrer les propri\u00e9t\u00e9s des diff\u00e9rents services et d'\u00e9viter ainsi d'avoir \u00e0 appeler un service directement. Au lieu de cela, le service de d\u00e9couverte fournira dynamiquement les informations n\u00e9cessaires, ce qui permet d'assurer l'\u00e9lasticit\u00e9 et la dynamicit\u00e9 propres \u00e0 une architecture microservices.   Pour r\u00e9aliser cela, Netflix offre le service  Eureka Service Registration and Discovery , que nous allons utiliser dans notre application.   Revenir \u00e0  Spring Initializr  et cr\u00e9er un nouveau projet Spring Boot intitul\u00e9  discovery-service  avec les d\u00e9pendances  Eureka Server  et  Config Client .  Lancer le projet avec IntelliJ.  Dans la classe  DiscoveryServiceApplication , ajouter l'annotation  EnableEurekaServer .   package   tn.insat.tpmicro.discoveryservice ;  import   org.springframework.boot.SpringApplication ;  import   org.springframework.boot.autoconfigure.SpringBootApplication ;  import   org.springframework.cloud.netflix.eureka.server.EnableEurekaServer ;  @EnableEurekaServer  @SpringBootApplication  public   class   DiscoveryServiceApplication   { \n\n     public   static   void   main ( String []   args )   { \n         SpringApplication . run ( DiscoveryServiceApplication . class ,   args ); \n     }  }    Ajouter les propri\u00e9t\u00e9s suivantes dans son fichier  application.properties .   spring.application.name = discovery-service  spring.cloud.config.uri = http://localhost:8888    Dans le projet  config-service , cr\u00e9er un fichier  discovery-service.properties  sous le r\u00e9pertoire  myConfig .  Ajouter les propri\u00e9t\u00e9s suivantes pour (1) d\u00e9finir le port par d\u00e9faut du service de d\u00e9couverte et (2) emp\u00eacher un auto-enregistrement du service Eureka.   server.port   =   8761  eureka.client.fetch-registry   =   false  eureka.client.register-with-eureka   =   false   Pour consulter le service Eureka, aller \u00e0  http://localhost:8761 , l'interface suivante s'affiche:   Nous remarquons qu'aucune instance n'est inscrite dans le serveur de d\u00e9couverte. Nous allons donc modifier le code de la classe  ProductServiceApplication  pour que le microservice  ProductService  s'enregistre:  package   tn.insat.tpmicro.productservice ;  import   org.springframework.boot.SpringApplication ;  import   org.springframework.boot.autoconfigure.SpringBootApplication ;  import   org.springframework.cloud.client.discovery.EnableDiscoveryClient ;  @EnableDiscoveryClient  @SpringBootApplication  public   class   ProductServiceApplication   { \n\n     public   static   void   main ( String []   args )   { \n         SpringApplication . run ( ProductServiceApplication . class ,   args ); \n     }  }   Red\u00e9marrer les trois instances de services  ProductService  et actualiser la fen\u00eatre de  Eureka , vous verrez qu'un seul service est d\u00e9clar\u00e9, avec trois adresses diff\u00e9rentes.", 
            "title": "Microservice DiscoveryService"
        }, 
        {
            "location": "/tp4/#microservice-proxyservice", 
            "text": "L'architecture microservice, en fournissant un ensemble de services ind\u00e9pendants et faiblement coupl\u00e9s, se trouve confront\u00e9e au challenge de fournir une interface unifi\u00e9e pour les consommateurs, de mani\u00e8re \u00e0 ce qu'ils ne voient pas la d\u00e9composition \u00e0 faible granularit\u00e9 de vos services. C'est pour cela que l'utilisation d'un service proxy, responsable du routage des requ\u00eates et de la r\u00e9partition de charge, est important.   Netflix offre le service  Zuul  pour r\u00e9aliser cela. Pour cr\u00e9er votre microservice Proxy:   Aller \u00e0  Spring Initializr .  Cr\u00e9er le projet  proxy-service  avec les d\u00e9pendances suivantes: Zuul, Web, HATEOAS, Actuator, Config Client et Eureka Discovery.  Ouvrir le service avec IntelliJ IDEA.  Ajouter \u00e0 la classe  ProxyServiceApplication  l'annotation  @EnableZuulProxy , ainsi que  @EnableDiscoveryClient  pour que le proxy soit \u00e9galement enregistr\u00e9 dans le service ce d\u00e9couverte.  Ajouter les propri\u00e9t\u00e9s  spring.application.name   et  spring.cloud.config.uri  dans le fichier  application.properties  du service proxy.  Cr\u00e9er le fichier  proxy-service.properties  dans le r\u00e9pertoire  myConfig  du service de configuration, dans lequel vous allez fixer le port du service proxy \u00e0 9999.   En lan\u00e7ant le service Proxy, vous remarquerez qu'il est rajout\u00e9 dans Eureka.   Si vous ex\u00e9cutez la requ\u00eate  http://localhost:9999/product-service/messages  plusieurs fois, vous remarquerez que l'affichage  c'est moi qui ait r\u00e9pondu!  s'affichera sur les consoles des trois instances respectivement, \u00e0 tour de r\u00f4le.", 
            "title": "Microservice ProxyService"
        }, 
        {
            "location": "/tp4/#homework", 
            "text": "Le concept de microservices est tr\u00e8s fortement li\u00e9 \u00e0 la culture DevOps, et \u00e0 la conteneurisation. Gr\u00e2ce aux conteneurs, vous n\u2019avez pas besoin de d\u00e9velopper et de configurer enti\u00e8rement un nouveau serveur physique, ni de mettre sur pied un nouvel environnement virtuel, ce qui requiert une \u00e9mulation de processeur, un syst\u00e8me d\u2019exploitation et des logiciels install\u00e9s. Le conteneur vous permet de faire tenir un environnement complet dans une seule image l\u00e9g\u00e8re.  C'est pour cela que votre t\u00e2che pour la s\u00e9ance prochaine sera de  dockeriser  les diff\u00e9rents microservices que nous venons de cr\u00e9er, au lieu de les lancer sur notre machine physique (localhost). Les trois instances du service ProductService, ainsi que les trois autres services (Discovery, Config et Proxy) doivent tourner ind\u00e9pendamment, chacun dans soon propre contenaire.  Vous devez fournir chacun un lien vers un projet  Github  contenant vos projets, ainsi qu'un  Readme  en bonne et due forme (respecter la norme Markdown svp) montrant les \u00e9tapes de conteneurisation des services. Chaque bin\u00f4me devra fournir son lien dans le fichier excel intitul\u00e9  Homework  que vous trouverez dans  Piazza .", 
            "title": "Homework"
        }, 
        {
            "location": "/tp5/", 
            "text": "TP5 - API Management avec Atom et Anypoint\n\n\n\n\nT\u00e9l\u00e9charger PDF\n\n\n\n\nObjectifs du TP\n\n\n\n\nG\u00e9n\u00e9ration d\u2019API avec Atom et le langage RAML\n\n\nGestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft\n\n\n\n\nOutils et Versions\n\n\n\n\nAtom\n Version: 1.22.1\n\n\nAPI Workbench\n: Plugin Atom. Version: 0.8.47\n\n\nAnypoint Studio\n Version: 6.4.1\n\n\nMySQL\n Version 5.7.20 (ou tout autre SGBD de votre choix)\n\n\n\n\nG\u00e9n\u00e9ration d'API avec RAML\n\n\nRAML\n\n\nRAML\n (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful.\n\n\nRAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles  technologie, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage.\n\n\nAPI Workbench\n\n\nPour \u00e9crire un document RAML de mani\u00e8re simple et intuitive, un outil de travail est fourni, sous la forme d\u2019un plugin pour \nAtom\n, l'\u00e9diteur de texte open source, appel\u00e9 \nAPI Workbench\n.\n\n\nPour l\u2019installer:\n\n\n\n\nT\u00e9l\u00e9charger et installer Atom: \nhttps://atom.io/\n\n\nDans le menu Pr\u00e9f\u00e9rences, choisir l\u2019option \nPackages\n, et taper dans la barre de recherche:  \napi-workbench\n.\n\n\nUne fois le package install\u00e9, on devrait trouver dans le menu Packages, un nouvel \u00e9l\u00e9ment \nAPI Workbench\n.\n\n\n\n\nCr\u00e9ation d\u2019un document RAML\n\n\nDans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations d\u00e9crites dans le cours.\n\n\nCr\u00e9ation d\u2019une API RAML\n\n\nPour cr\u00e9er un nouveau projet RAML, aller vers \nPackages -\n API Workbench -\n Create RAML Project\n . Indiquer :\n\n\n\n\nLe r\u00e9pertoire de travail\n\n\nLe titre de l\u2019API : Par exemple Pet Shop\n\n\nLa version : v1\n\n\nL\u2019URI de base l\u2019API : /petshop\n\n\nCocher uniquement Use RAML 1.0\n\n\n\n\nLe projet obtenu aura l\u2019allure suivante:\n\n\n\n\nAjout de Ressources et M\u00e9thodes\n\n\n\n\nSous l\u2019onglet Palette de la rubrique D\u00e9tails, cliquer sur \nAdd new ressource\n pour ajouter une nouvelle ressource.\n\n\nAppeler la ressource \n/pets\n\n\nS\u00e9lectionner les m\u00e9thodes \nget\n et \npost\n\n\n\n\nLa ressource est d\u00e9sormais cr\u00e9\u00e9e avec deux m\u00e9thodes vides.\n\n\nRemplir les corps et r\u00e9ponses des m\u00e9thodes\n\n\n\n\nMettre le focus sur la m\u00e9thode \nget:\n\n\nDans la Palette, cliquer sur \nCreate new response\n\n\nGarder le code 200 pour la r\u00e9ponse et cliquer sur OK\n\n\nUne fois le code de la r\u00e9ponse g\u00e9n\u00e9r\u00e9, mettre le focus sur \n200:\n\n\nCliquer sur \nCreate new Response Body\n, puis dans la fen\u00eatre qui apparait cliquer sur OK, pour g\u00e9n\u00e9rer une r\u00e9ponse de type par d\u00e9faut \napplication/json\n\n\nPour la m\u00e9thode post, g\u00e9n\u00e9rer directement un corps, en cliquant sur \nCreate new body\n.\n\n\n\n\nLe r\u00e9sultat appara\u00eet comme suit:\n\n\n\n\nAjouter des sous-ressources\n\n\nPour d\u00e9finir le reste des m\u00e9thodes (put et delete), destin\u00e9es \u00e0 agir sur un \u00e9l\u00e9ment unique de la ressource pets, et les associer \u00e0 une sous-ressource:\n\n\n\n\nMettre le focus sur \n/pets\n\n\nCliquer sur \nAdd new resource\n\n\nTaper \n/{id}\n comme ressource URL, et s\u00e9lectionner les m\u00e9thodes put et delete.\n\n\nAjouter un body \u00e0 put de type application/json\n\n\nAjouter une r\u00e9ponse \u00e0 delete de type 204\n\n\n\n\nD\u00e9finir des types\n\n\nPour d\u00e9finir le contenu des messages JSON manipul\u00e9s, d\u00e9finir un type comme suit:\n\n\n\n\nDans une nouvelle ligne au dessus de \n/pets\n, taper \nty\n, puis cliquer sur entr\u00e9e\n\n\nAppeler le type \nPet\n, puis d\u00e9finir les propri\u00e9t\u00e9s name, kind et price, comme suit:\n\n\n\n\ntypes\n:\n\n\n  Pet\n:\n\n\n    properties\n:\n\n\n      name\n:\n \nstring\n\n\n      kind\n:\n \nstring\n\n\n      price\n:\n \nnumber\n\n\n\n\n\n\n\nD\u00e9finir \nPet\n comme type pour le corps de la m\u00e9thode \npost\n, en \u00e9crivant: \ntype: Pet\n au dessous de \napplication/json\n de la m\u00e9thode post\n\n\nAjouter de m\u00eame \nPet\n comme type pour la m\u00e9thode put, et \nPet[]\n pour la m\u00e9thode get.\n\n\n\n\nExtraction d\u2019un type de ressources\n\n\nPour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante:\n\n\n\n\nMettre le focus sur la ressource \n/pets\n\n\nCliquer sur \nExtract Resource Type\n (si vous ne la trouvez pas, appuyer sur \nentr\u00e9e\n)\n\n\nTaper \nCollection\n comme nom de type de ressource et d\u00e9placer les m\u00e9thodes get et post de la fen\u00eatre de gauche vers celle de droite\n\n\nUn nouveau \nresourceType\n, appel\u00e9 \nCollection\n, est cr\u00e9\u00e9, contenant les m\u00e9thodes get et post comme elles ont \u00e9t\u00e9 d\u00e9finies sous la ressource \n/pets\n. De plus, \n/pets\n est d\u00e9sormais de type \nCollection\n.\n\n\nR\u00e9p\u00e9ter la proc\u00e9dure pour la ressource /{id}. On appellera le type \nMember\n.\n\n\n\n\nLe r\u00e9sultat devra ressembler \u00e0 ce qui suit:\n\n\n\n\nAjout de param\u00e8tres au type de ressource\n\n\nPour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela:\n\n\n\n\nRemplacer le terme \nPet\n dans \nCollection\n et \nMember\n par \nitem\n.\n\n\nCorriger les erreurs qui s\u2019affichent dans les ressources \nCollection\n et \nMember\n respectivement par \n{ Collection: {item : Pet} }\n et \n{ Member: {item : Pet} }\n\n\n\n\nAjout d\u2019un exemple\n\n\nPour ajouter un exemple d\u2019animal, modifier le type \nPet\n pour qu\u2019il soit comme suit:\n\n\ntypes\n:\n\n\n  Pet\n:\n\n\n    properties\n:\n\n\n      name\n:\n \nstring\n\n\n      kind\n:\n \nstring\n\n\n      price\n:\n \nnumber\n\n\n    example\n:\n\n\n      name\n:\n \nSnoopy\n\n\n      kind\n:\n \nDog\n\n\n      price\n:\n \n1000\n\n\n\n\n\nD\u00e9finir des param\u00e8tres pour les m\u00e9thodes\n\n\nNous nous proposons d\u2019ajouter une autre m\u00e9thode de type \nget\n, qui d\u00e9finit plusieurs param\u00e8tres.\n\n\n\n\nSous (et au m\u00eame niveau que) \ntype\n de \n/pets\n, taper: \nget:\n\n\nMettre le focus sur le \nget\n nouvellement cr\u00e9\u00e9\n\n\nCliquer sur \nCreate new query parameter\n\n\nCr\u00e9er trois param\u00e8tres:\n\n\npriceLessThan\n de type \nnumber\n\n\npriceMoreThan\n de type \nnumber\n\n\npetKind\n, de type \nenum;[bird, dog]\n\n\n\n\n\n\n\n\nCela devra ressembler \u00e0 ce qui suit:\n\n\nget\n:\n\n\n    queryParameters\n:\n\n\n      priceLessThan\n:\n \nnumber\n\n\n      priceMoreThan\n:\n \nnumber\n\n\n      petKind\n:\n\n\n        enum\n:\n\n          \n-\n \nbird\n\n          \n-\n \ndog\n\n\n\n\nIl est possible d\u2019extraire certains des param\u00e8tres comme \nTrait\n, c\u2019est \u00e0 dire un crit\u00e8re de filtrage. Pour cela:\n\n\n\n\nMettre le focus sur le \nget\n\n\nCliquer sur \nExtract trait\n\n\nNommer le trait \nFiltrableByPrice\n, et d\u00e9placer les m\u00e9thodes \npriceLessThan\n et \npriceMoreThan\n vers la droite.\n\n\n\n\nVous remarquerez que les deux param\u00e8tres choisis ont \u00e9t\u00e9 enlev\u00e9s de la m\u00e9thode \nget\n, et remplac\u00e9s par \nis: [FilterableByPrice]\n.\n\n\nVoici donc le r\u00e9sultat final du fichier RAML:\n\n\n#%RAML 1.0\n\n\ntraits\n:\n\n\n  FiltrableByPrice\n:\n\n\n    queryParameters\n:\n\n\n      priceLessThan\n:\n \nnumber\n\n\n      priceMoreThan\n:\n \nnumber\n\n\nresourceTypes\n:\n\n\n  Collection\n:\n\n\n    get\n:\n\n\n      responses\n:\n\n\n        200\n:\n\n\n          body\n:\n\n\n            application/json\n:\n\n\n              type\n:\n \nitem\n\n\n    post\n:\n\n\n      body\n:\n\n\n        application/json\n:\n\n\n          type\n:\n \nitem\n\n\n  Member\n:\n\n\n    delete\n:\n\n\n      responses\n:\n\n\n        204\n:\n\n\n    put\n:\n\n\n      body\n:\n\n\n        application/json\n:\n\n\n          type\n:\n \nitem\n\n\ntitle\n:\n \nPet Shop\n\n\nversion\n:\n \nv1\n\n\nbaseUri\n:\n \n/petshop\n\n\ntypes\n:\n\n\n  Pet\n:\n\n\n    properties\n:\n\n\n      name\n:\n \nstring\n\n\n      kind\n:\n \nstring\n\n\n      price\n:\n \nnumber\n\n\n    example\n:\n\n\n      name\n:\n \nSnoopy\n\n\n      kind\n:\n \nDog\n\n\n      price\n:\n \n1000\n\n\n/pets\n:\n\n\n  type\n:\n \n{ Collection: {item : Pet} }\n\n\n  get\n:\n\n\n    queryParameters\n:\n\n\n      petKind\n:\n\n\n        enum\n:\n\n          \n-\n \nbird\n\n          \n-\n \ndog\n\n\n    is\n:\n \n[FiltrableByPrice]\n\n\n  /{id}\n:\n\n\n    type\n:\n \n{ Member: {item : Pet} }\n\n\n\n\nExtraction de la librairie\n\n\nPour extraire les types d\u00e9finis et les repr\u00e9senter dans une entit\u00e9 r\u00e9utilisable:\n\n\n\n\nMettre le focus en dehors de toutes les structures, par exemple sur \ntitle\n\n\nCliquer sur \nExtract Library\n\n\nAppeler la librarie \nPetTypes\n\n\nD\u00e9placer \nPet\n, \nCollection\n et \nMember\n vers le panel de droite\n\n\nCliquer sur \nExtract\n\n\n\n\nUn nouveau fichier contenant les trois types s\u00e9lectionn\u00e9s a \u00e9t\u00e9 cr\u00e9\u00e9, puis inclus comme r\u00e9f\u00e9rence dans notre fichier principal.\n\n\nAPI Management avec Anypoint Studio\n\n\nAnypoint Platform\n\n\nAnypoint\n est une plateforme d\u00e9velopp\u00e9e par l\u2019entreprise Mulesoft qui offre les outils n\u00e9cessaires pour la gestion d\u2019APIs. Anypoint est class\u00e9e par Gartner dans son Magic Quadrant dans la rubrique \u201cApplication Services Governance\u201d d\u2019Avril 2015 parmi les leaders du march\u00e9 du API Management.\n\n\n\n\nPremi\u00e8re Application\n\n\nUne fois Anypoint Studio t\u00e9l\u00e9charg\u00e9 et install\u00e9, cr\u00e9er un nouveau projet, qu\u2019on appellera \nPremiereApplication\n, et choisir Mule Server comme \nRuntime Environment\n.\n\nLa fen\u00eatre obtenue a l\u2019allure suivante:\n\n\n\n\n\n\nAttention\n\n\nAnypoint Studio version 6.4.1 ne fonctionne qu'avec au plus JDK 1.8.0_151!\n\n\n\n\nNous allons commencer par cr\u00e9er une simple application qui affiche un message dans un navigateur.\n\n\n\n\n\u00c0 partir de la palette, glisser-d\u00e9placer les \u00e9l\u00e9ments graphiques suivants dans le canevas:\n\n\nHTTP\n: permet de se connecter aux ressources web via HTTP ou HTTPS.\n\n\nSet Payload\n: modifie le message affich\u00e9 (payload) en \"Hello World!\".\n\n\n\n\n\n\n\n\nVotre flux aura l\u2019allure suivante:\n\n\n\n\nConfigurer votre composant HTTP :\n\n\n\n\nAjouter une nouvelle \nConnector Configuration\n\n\nGarder les options par d\u00e9faut. Votre h\u00f4te se lancera \u00e0 l\u2019URL 0.0.0.0:8081\n\n\n\n\nConfigurer le composant Set Payload:\n\n\n\n\nRemplacer la valeur de l\u2019\u00e9l\u00e9ment \nValue\n par \nHello World!\n\n\nLancer votre application : Run -\n Run As -\n Mule Application. La console devrait afficher un message comme suit:\n\n\n\n\n\n\nDans un navigateur, taper l'adresse: 0.0.0.0:8081. Le message suivant devra s'afficher:\n\n\n\n\nGestion des APIs avec APIKit\n\n\nAPIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs.\n\n\nNous allons pour cela exposer l'API REST que nous avons cr\u00e9\u00e9 dans le \nTP pr\u00e9c\u00e9dent\n, gr\u00e2ce aux microservices Spring.\n\n\nCr\u00e9ation d'un fichier RAML pour le microservice\n\n\nPour repr\u00e9senter le microservice \"ProductService\", cr\u00e9er le fichier \napi.raml\n suivant avec Atom:\n\n\n#%RAML 1.0\n\n\ntitle\n:\n \nMicro-API\n\n\nversion\n:\n \nv1\n\n\nbaseUri\n:\n \nhttp://products.tn\n\n\n/products\n:\n\n\n  get\n:\n\n\n    description\n:\n \nList of all the products\n\n\n    responses\n:\n\n\n      200\n:\n\n\n        body\n:\n\n\n          application/json\n:\n\n\n            example\n:\n \n!include products-example.json\n\n\n\n\n\nRajouter \u00e9galement (dans le m\u00eame r\u00e9pertoire) un fichier \nproducts-example.json\n, o\u00f9 vous allez trouver un exemple de produits, tel qu'ils sont repr\u00e9sent\u00e9s par votre service sur \nhttp://localhost:9999/product-service/products\n. Cela devrait ressembler \u00e0 ce qui suit:\n\n\n{\n\n  \n_embedded\n:\n \n{\n\n    \nproducts\n:\n \n[\n\n      \n{\n\n        \nname\n:\n \nSample Product\n,\n\n        \n_links\n:\n \n{\n\n          \nself\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/1\n\n          \n},\n\n          \nproduct\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/1\n\n          \n}\n\n        \n}\n\n      \n}\n\n    \n]\n\n  \n},\n\n  \n_links\n:\n \n{\n\n    \nself\n:\n \n{\n\n      \nhref\n:\n \nhttp://localhost:9999/product-service/products{?page,size,sort}\n,\n\n      \ntemplated\n:\n \ntrue\n\n    \n},\n\n    \nprofile\n:\n \n{\n\n      \nhref\n:\n \nhttp://localhost:9999/product-service/profile/products\n\n    \n},\n\n    \nsearch\n:\n \n{\n\n      \nhref\n:\n \nhttp://localhost:9999/product-service/products/search\n\n    \n}\n\n  \n},\n\n  \npage\n:\n \n{\n\n    \nsize\n:\n \n20\n,\n\n    \ntotalElements\n:\n \n3\n,\n\n    \ntotalPages\n:\n \n1\n,\n\n    \nnumber\n:\n \n0\n\n  \n}\n\n\n}\n\n\n\n\n\nNouveau Projet de API Management\n\n\nCr\u00e9er un nouveau projet qu\u2019on appellera \nAPI_Project\n:\n\n\n\n\nChoisir comme environnement d\u2019ex\u00e9cution Mule Server.\n\n\nCocher la case \nAdd APIKit components\n et entrer votre fichier api.raml.\n\n\n\n\nUn nouveau projet sera cr\u00e9\u00e9 avec les fichiers \napi.raml\n et \nproducts-example.json\n ajout\u00e9 sous le r\u00e9pertoire \nsrc/main/api\n, ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment:\n\n\n\n\n\n\n\n\nFlux\n\n\nDescription\n\n\nFigure\n\n\n\n\n\n\n\n\n\n\napi-main\n\n\nFlux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception\n\n\n\n\n\n\n\n\naction:/ressource:api-config\n\n\nUn Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products\n\n\n\n\n\n\n\n\nException Strategy Mapping\n\n\nFlux fournis par Studio pour configurer les messages d\u2019erreur dans un format HTTP-status-code-friendly\n\n\n\n\n\n\n\n\n\n\nConfiguration du flux principal\n\n\n\n\nDans les propri\u00e9t\u00e9s du composant HTTP, d\u00e9finir le Path par: /prod-services/*.\n\n\nDans le \nConnector Configuration\n, cliquer sur l'ic\u00f4ne \n, puis cliquer sur \nOK\n pour valider le host (0.0.0.0) et le port (8081)\n\n\n\n\n\n\nRemarque\n\n\nVous pouvez changer ici le port d\u00e9fini par d\u00e9faut, pour \u00e9viter les conflits avec vos microservices.\n\n\n\n\nLancer le projet comme \nMule Project\n. Une \nAPIKit Console\n s'affiche comme suit:\n\n\n\n\nPour tester votre API, cliquer par exemple sur le bouton \nGET\n devant la ressource \n/products\n. la Console affichera alors la r\u00e9ponse (le produit \nSample Product\n), qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part.\n\n\n\n\nPour visualiser le r\u00e9sultat sur le navigateur, taper le chemin de la requ\u00eate comme suit:\n\n\nhttp://localhost:8081/prod-services/products\n\n\n\n\nVous obtiendrez le r\u00e9sultat suivant:\n\n\n\n\nMapping de l'API avec votre microservice ProductService\n\n\nPour relier votre API cr\u00e9\u00e9e avec le microservice Proxy (cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent), et qui est d\u00e9ploy\u00e9 \u00e0 l'adresse suivante:\n\n\nhttp://localhost:9999/product-service/products\n\n\n\n\n\n\nSupprimer le \nSet Payload\n du flow : \nget:/products:api-config\n\n\nAjouter un connecteur HTTP dans la partie \nSource\n\n\nLe configurer comme suit:\n\n\nPath: /prod-services\n\n\nCliquer sur \n puis sur OK pour valider le h\u00f4te et port.\n\n\n\n\n\n\nAjouter un connecteur HTTP dans la partie \nProcess\n\n\nLe configurer comme suit:\n\n\nDevant \nConnector Configuration\n, cliquer sur \n pour ajouter une nouvelle configuration.\n\n\nCela repr\u00e9sente les informations du service auquel on va acc\u00e9der. D\u00e9finir le Host par \nlocalhost\n, le port par \n9999\n, et le base path par \n/product-service\n\n\nCliquer sur OK pour valider\n\n\n\n\n\n\nDans la partie \nURL Settings\n, d\u00e9finir :\n\n\nPath: /products\n\n\nMethod: Get\n\n\n\n\n\n\nSauvegarder, et lancer le service.\n\n\n\n\nTester le service sur le navigateur avec l'URL:\n\n\nhttp://localhost:8081/prod-services\n. Vous obtiendrez la liste compl\u00e8te des produits, tels que retourn\u00e9s par le service \nProductService\n initial, comme suit:\n\n\n{\n\n  \n_embedded\n:\n \n{\n\n    \nproducts\n:\n \n[\n\n      \n{\n\n        \nname\n:\n \nPencil\n,\n\n        \n_links\n:\n \n{\n\n          \nself\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/1\n\n          \n},\n\n          \nproduct\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/1\n\n          \n}\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \nname\n:\n \nBook\n,\n\n        \n_links\n:\n \n{\n\n          \nself\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/2\n\n          \n},\n\n          \nproduct\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/2\n\n          \n}\n\n        \n}\n\n      \n},\n\n      \n{\n\n        \nname\n:\n \nEraser\n,\n\n        \n_links\n:\n \n{\n\n          \nself\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/3\n\n          \n},\n\n          \nproduct\n:\n \n{\n\n            \nhref\n:\n \nhttp://localhost:9999/product-service/products/3\n\n          \n}\n\n        \n}\n\n      \n}\n\n    \n]\n\n  \n},\n\n  \n_links\n:\n \n{\n\n    \nself\n:\n \n{\n\n      \nhref\n:\n \nhttp://localhost:9999/product-service/products{?page,size,sort}\n,\n\n      \ntemplated\n:\n \ntrue\n\n    \n},\n\n    \nprofile\n:\n \n{\n\n      \nhref\n:\n \nhttp://localhost:9999/product-service/profile/products\n\n    \n},\n\n    \nsearch\n:\n \n{\n\n      \nhref\n:\n \nhttp://localhost:9999/product-service/products/search\n\n    \n}\n\n  \n},\n\n  \npage\n:\n \n{\n\n    \nsize\n:\n \n20\n,\n\n    \ntotalElements\n:\n \n3\n,\n\n    \ntotalPages\n:\n \n1\n,\n\n    \nnumber\n:\n \n0\n\n  \n}\n\n\n}\n\n\n\n\n\nTransformation du r\u00e9sultat du microservice ProductService\n\n\nSi vous d\u00e9sirez retourner un r\u00e9sultat diff\u00e9rent du Microservice initial, en ne laissant par exemple que les noms des produits, sans tous les autres \u00e9l\u00e9ments et liens suppl\u00e9mentaires, utiliser un objet \nTransform Message\n\n\n\n\nCopier le flow get:/products pour cr\u00e9er un autre flow identique\n\n\nModifier le Path du connecteur HTTP source, pour  \n/prod-services/names\n\n\nRajouter un objet \nTransform Message\n juste apr\u00e8s le connecteur HTTP de droite (celui de la partie Process). Le flow devra ressembler \u00e0 ce qui suit:\n\n\n\n\n\n\n\n\n\n\nConfigurer l'objet \nTransform Message\n:\n\n\n\n\nL'interface suivante repr\u00e9sente les mappings \u00e0 faire entre les entr\u00e9es du service et sa sortie.\n\n\n\n\n\n\n\n\nCliquer sur \nDefine Metadata\n du payload en entr\u00e9e (\u00e0 gauche) gauche)\n\n\nCliquer sur \nAdd\n\n\nEntrer le nom du type en entr\u00e9e, par exemple \nproducts\n\n\nIndiquer comme type \nJSON\n\n\nIndiquer dans la liste d\u00e9roulante suivante que le fichier donn\u00e9 est un \nExample\n, puis choisir le fichier \nproducts-example.json\n que vous aviez cr\u00e9\u00e9.\n\n\nCliquer sur Select. Le sch\u00e9ma du fichier donn\u00e9 est charg\u00e9 dans la partie \nInput\n de \nTransform Message\n.\n\n\nPour repr\u00e9senter le format de sortie d\u00e9sir\u00e9, cr\u00e9er un fichier appel\u00e9 \nnames.json\n \u00e0 l'endroit de votre pr\u00e9f\u00e9rence sur votre ordinateur.\n\n\nSaisir le contenu suivant dans \nnames.json\n:\n\n\n  \n{\nname\n:\nprod\n}\n\n\n\n\nCliquer sur \nDefine Metadata\n de sortie (\u00e0 droite).\n\n\nAjouter un nouveau type que vous appellerez \nnames\n\n\nD\u00e9finir comme type \nJson\n et charger le fichier \nnames.json\n que vous venez de cr\u00e9er.\n\n\nValider.\n\n\nMaintenant que les deux sch\u00e9mas (entr\u00e9e et sortie) sont d\u00e9finis, cr\u00e9er les associations de votre choix. Dans notre cas, nous allons associer le champ \n_embedded.products.name\n en entr\u00e9e au champ \nname\n en sortie, comme suit:\n\n\n\n\nSauvegarder, et lancer le service.\n\n\n\n\n\n\n\n\nPour tester le service, lancer dans un navigateur: \nhttp://localhost:8081/prod-services/names\n. Vous obtiendrez le r\u00e9sultat suivant:\n\n\n{\n\n  \nname\n:\n \n[\n\n    \nPencil\n,\n\n    \nBook\n,\n\n    \nEraser\n\n  \n]\n\n\n}", 
            "title": "TP5 - API Management avec Atom et Anypoint"
        }, 
        {
            "location": "/tp5/#tp5-api-management-avec-atom-et-anypoint", 
            "text": "", 
            "title": "TP5 - API Management avec Atom et Anypoint"
        }, 
        {
            "location": "/tp5/#telecharger-pdf", 
            "text": "", 
            "title": "T\u00e9l\u00e9charger PDF"
        }, 
        {
            "location": "/tp5/#objectifs-du-tp", 
            "text": "G\u00e9n\u00e9ration d\u2019API avec Atom et le langage RAML  Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft", 
            "title": "Objectifs du TP"
        }, 
        {
            "location": "/tp5/#outils-et-versions", 
            "text": "Atom  Version: 1.22.1  API Workbench : Plugin Atom. Version: 0.8.47  Anypoint Studio  Version: 6.4.1  MySQL  Version 5.7.20 (ou tout autre SGBD de votre choix)", 
            "title": "Outils et Versions"
        }, 
        {
            "location": "/tp5/#generation-dapi-avec-raml", 
            "text": "", 
            "title": "G\u00e9n\u00e9ration d'API avec RAML"
        }, 
        {
            "location": "/tp5/#raml", 
            "text": "RAML  (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful.  RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles  technologie, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage.", 
            "title": "RAML"
        }, 
        {
            "location": "/tp5/#api-workbench", 
            "text": "Pour \u00e9crire un document RAML de mani\u00e8re simple et intuitive, un outil de travail est fourni, sous la forme d\u2019un plugin pour  Atom , l'\u00e9diteur de texte open source, appel\u00e9  API Workbench .  Pour l\u2019installer:   T\u00e9l\u00e9charger et installer Atom:  https://atom.io/  Dans le menu Pr\u00e9f\u00e9rences, choisir l\u2019option  Packages , et taper dans la barre de recherche:   api-workbench .  Une fois le package install\u00e9, on devrait trouver dans le menu Packages, un nouvel \u00e9l\u00e9ment  API Workbench .", 
            "title": "API Workbench"
        }, 
        {
            "location": "/tp5/#creation-dun-document-raml", 
            "text": "Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations d\u00e9crites dans le cours.", 
            "title": "Cr\u00e9ation d\u2019un document RAML"
        }, 
        {
            "location": "/tp5/#creation-dune-api-raml", 
            "text": "Pour cr\u00e9er un nouveau projet RAML, aller vers  Packages -  API Workbench -  Create RAML Project  . Indiquer :   Le r\u00e9pertoire de travail  Le titre de l\u2019API : Par exemple Pet Shop  La version : v1  L\u2019URI de base l\u2019API : /petshop  Cocher uniquement Use RAML 1.0   Le projet obtenu aura l\u2019allure suivante:", 
            "title": "Cr\u00e9ation d\u2019une API RAML"
        }, 
        {
            "location": "/tp5/#ajout-de-ressources-et-methodes", 
            "text": "Sous l\u2019onglet Palette de la rubrique D\u00e9tails, cliquer sur  Add new ressource  pour ajouter une nouvelle ressource.  Appeler la ressource  /pets  S\u00e9lectionner les m\u00e9thodes  get  et  post   La ressource est d\u00e9sormais cr\u00e9\u00e9e avec deux m\u00e9thodes vides.", 
            "title": "Ajout de Ressources et M\u00e9thodes"
        }, 
        {
            "location": "/tp5/#remplir-les-corps-et-reponses-des-methodes", 
            "text": "Mettre le focus sur la m\u00e9thode  get:  Dans la Palette, cliquer sur  Create new response  Garder le code 200 pour la r\u00e9ponse et cliquer sur OK  Une fois le code de la r\u00e9ponse g\u00e9n\u00e9r\u00e9, mettre le focus sur  200:  Cliquer sur  Create new Response Body , puis dans la fen\u00eatre qui apparait cliquer sur OK, pour g\u00e9n\u00e9rer une r\u00e9ponse de type par d\u00e9faut  application/json  Pour la m\u00e9thode post, g\u00e9n\u00e9rer directement un corps, en cliquant sur  Create new body .   Le r\u00e9sultat appara\u00eet comme suit:", 
            "title": "Remplir les corps et r\u00e9ponses des m\u00e9thodes"
        }, 
        {
            "location": "/tp5/#ajouter-des-sous-ressources", 
            "text": "Pour d\u00e9finir le reste des m\u00e9thodes (put et delete), destin\u00e9es \u00e0 agir sur un \u00e9l\u00e9ment unique de la ressource pets, et les associer \u00e0 une sous-ressource:   Mettre le focus sur  /pets  Cliquer sur  Add new resource  Taper  /{id}  comme ressource URL, et s\u00e9lectionner les m\u00e9thodes put et delete.  Ajouter un body \u00e0 put de type application/json  Ajouter une r\u00e9ponse \u00e0 delete de type 204", 
            "title": "Ajouter des sous-ressources"
        }, 
        {
            "location": "/tp5/#definir-des-types", 
            "text": "Pour d\u00e9finir le contenu des messages JSON manipul\u00e9s, d\u00e9finir un type comme suit:   Dans une nouvelle ligne au dessus de  /pets , taper  ty , puis cliquer sur entr\u00e9e  Appeler le type  Pet , puis d\u00e9finir les propri\u00e9t\u00e9s name, kind et price, comme suit:   types :    Pet :      properties :        name :   string        kind :   string        price :   number    D\u00e9finir  Pet  comme type pour le corps de la m\u00e9thode  post , en \u00e9crivant:  type: Pet  au dessous de  application/json  de la m\u00e9thode post  Ajouter de m\u00eame  Pet  comme type pour la m\u00e9thode put, et  Pet[]  pour la m\u00e9thode get.", 
            "title": "D\u00e9finir des types"
        }, 
        {
            "location": "/tp5/#extraction-dun-type-de-ressources", 
            "text": "Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante:   Mettre le focus sur la ressource  /pets  Cliquer sur  Extract Resource Type  (si vous ne la trouvez pas, appuyer sur  entr\u00e9e )  Taper  Collection  comme nom de type de ressource et d\u00e9placer les m\u00e9thodes get et post de la fen\u00eatre de gauche vers celle de droite  Un nouveau  resourceType , appel\u00e9  Collection , est cr\u00e9\u00e9, contenant les m\u00e9thodes get et post comme elles ont \u00e9t\u00e9 d\u00e9finies sous la ressource  /pets . De plus,  /pets  est d\u00e9sormais de type  Collection .  R\u00e9p\u00e9ter la proc\u00e9dure pour la ressource /{id}. On appellera le type  Member .   Le r\u00e9sultat devra ressembler \u00e0 ce qui suit:", 
            "title": "Extraction d\u2019un type de ressources"
        }, 
        {
            "location": "/tp5/#ajout-de-parametres-au-type-de-ressource", 
            "text": "Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela:   Remplacer le terme  Pet  dans  Collection  et  Member  par  item .  Corriger les erreurs qui s\u2019affichent dans les ressources  Collection  et  Member  respectivement par  { Collection: {item : Pet} }  et  { Member: {item : Pet} }", 
            "title": "Ajout de param\u00e8tres au type de ressource"
        }, 
        {
            "location": "/tp5/#ajout-dun-exemple", 
            "text": "Pour ajouter un exemple d\u2019animal, modifier le type  Pet  pour qu\u2019il soit comme suit:  types :    Pet :      properties :        name :   string        kind :   string        price :   number      example :        name :   Snoopy        kind :   Dog        price :   1000", 
            "title": "Ajout d\u2019un exemple"
        }, 
        {
            "location": "/tp5/#definir-des-parametres-pour-les-methodes", 
            "text": "Nous nous proposons d\u2019ajouter une autre m\u00e9thode de type  get , qui d\u00e9finit plusieurs param\u00e8tres.   Sous (et au m\u00eame niveau que)  type  de  /pets , taper:  get:  Mettre le focus sur le  get  nouvellement cr\u00e9\u00e9  Cliquer sur  Create new query parameter  Cr\u00e9er trois param\u00e8tres:  priceLessThan  de type  number  priceMoreThan  de type  number  petKind , de type  enum;[bird, dog]     Cela devra ressembler \u00e0 ce qui suit:  get :      queryParameters :        priceLessThan :   number        priceMoreThan :   number        petKind :          enum : \n           -   bird \n           -   dog   Il est possible d\u2019extraire certains des param\u00e8tres comme  Trait , c\u2019est \u00e0 dire un crit\u00e8re de filtrage. Pour cela:   Mettre le focus sur le  get  Cliquer sur  Extract trait  Nommer le trait  FiltrableByPrice , et d\u00e9placer les m\u00e9thodes  priceLessThan  et  priceMoreThan  vers la droite.   Vous remarquerez que les deux param\u00e8tres choisis ont \u00e9t\u00e9 enlev\u00e9s de la m\u00e9thode  get , et remplac\u00e9s par  is: [FilterableByPrice] .  Voici donc le r\u00e9sultat final du fichier RAML:  #%RAML 1.0  traits :    FiltrableByPrice :      queryParameters :        priceLessThan :   number        priceMoreThan :   number  resourceTypes :    Collection :      get :        responses :          200 :            body :              application/json :                type :   item      post :        body :          application/json :            type :   item    Member :      delete :        responses :          204 :      put :        body :          application/json :            type :   item  title :   Pet Shop  version :   v1  baseUri :   /petshop  types :    Pet :      properties :        name :   string        kind :   string        price :   number      example :        name :   Snoopy        kind :   Dog        price :   1000  /pets :    type :   { Collection: {item : Pet} }    get :      queryParameters :        petKind :          enum : \n           -   bird \n           -   dog      is :   [FiltrableByPrice]    /{id} :      type :   { Member: {item : Pet} }", 
            "title": "D\u00e9finir des param\u00e8tres pour les m\u00e9thodes"
        }, 
        {
            "location": "/tp5/#extraction-de-la-librairie", 
            "text": "Pour extraire les types d\u00e9finis et les repr\u00e9senter dans une entit\u00e9 r\u00e9utilisable:   Mettre le focus en dehors de toutes les structures, par exemple sur  title  Cliquer sur  Extract Library  Appeler la librarie  PetTypes  D\u00e9placer  Pet ,  Collection  et  Member  vers le panel de droite  Cliquer sur  Extract   Un nouveau fichier contenant les trois types s\u00e9lectionn\u00e9s a \u00e9t\u00e9 cr\u00e9\u00e9, puis inclus comme r\u00e9f\u00e9rence dans notre fichier principal.", 
            "title": "Extraction de la librairie"
        }, 
        {
            "location": "/tp5/#api-management-avec-anypoint-studio", 
            "text": "", 
            "title": "API Management avec Anypoint Studio"
        }, 
        {
            "location": "/tp5/#anypoint-platform", 
            "text": "Anypoint  est une plateforme d\u00e9velopp\u00e9e par l\u2019entreprise Mulesoft qui offre les outils n\u00e9cessaires pour la gestion d\u2019APIs. Anypoint est class\u00e9e par Gartner dans son Magic Quadrant dans la rubrique \u201cApplication Services Governance\u201d d\u2019Avril 2015 parmi les leaders du march\u00e9 du API Management.", 
            "title": "Anypoint Platform"
        }, 
        {
            "location": "/tp5/#premiere-application", 
            "text": "Une fois Anypoint Studio t\u00e9l\u00e9charg\u00e9 et install\u00e9, cr\u00e9er un nouveau projet, qu\u2019on appellera  PremiereApplication , et choisir Mule Server comme  Runtime Environment . \nLa fen\u00eatre obtenue a l\u2019allure suivante:    Attention  Anypoint Studio version 6.4.1 ne fonctionne qu'avec au plus JDK 1.8.0_151!   Nous allons commencer par cr\u00e9er une simple application qui affiche un message dans un navigateur.   \u00c0 partir de la palette, glisser-d\u00e9placer les \u00e9l\u00e9ments graphiques suivants dans le canevas:  HTTP : permet de se connecter aux ressources web via HTTP ou HTTPS.  Set Payload : modifie le message affich\u00e9 (payload) en \"Hello World!\".     Votre flux aura l\u2019allure suivante:   Configurer votre composant HTTP :   Ajouter une nouvelle  Connector Configuration  Garder les options par d\u00e9faut. Votre h\u00f4te se lancera \u00e0 l\u2019URL 0.0.0.0:8081   Configurer le composant Set Payload:   Remplacer la valeur de l\u2019\u00e9l\u00e9ment  Value  par  Hello World!  Lancer votre application : Run -  Run As -  Mule Application. La console devrait afficher un message comme suit:    Dans un navigateur, taper l'adresse: 0.0.0.0:8081. Le message suivant devra s'afficher:", 
            "title": "Premi\u00e8re Application"
        }, 
        {
            "location": "/tp5/#gestion-des-apis-avec-apikit", 
            "text": "APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs.  Nous allons pour cela exposer l'API REST que nous avons cr\u00e9\u00e9 dans le  TP pr\u00e9c\u00e9dent , gr\u00e2ce aux microservices Spring.", 
            "title": "Gestion des APIs avec APIKit"
        }, 
        {
            "location": "/tp5/#creation-dun-fichier-raml-pour-le-microservice", 
            "text": "Pour repr\u00e9senter le microservice \"ProductService\", cr\u00e9er le fichier  api.raml  suivant avec Atom:  #%RAML 1.0  title :   Micro-API  version :   v1  baseUri :   http://products.tn  /products :    get :      description :   List of all the products      responses :        200 :          body :            application/json :              example :   !include products-example.json   Rajouter \u00e9galement (dans le m\u00eame r\u00e9pertoire) un fichier  products-example.json , o\u00f9 vous allez trouver un exemple de produits, tel qu'ils sont repr\u00e9sent\u00e9s par votre service sur  http://localhost:9999/product-service/products . Cela devrait ressembler \u00e0 ce qui suit:  { \n   _embedded :   { \n     products :   [ \n       { \n         name :   Sample Product , \n         _links :   { \n           self :   { \n             href :   http://localhost:9999/product-service/products/1 \n           }, \n           product :   { \n             href :   http://localhost:9999/product-service/products/1 \n           } \n         } \n       } \n     ] \n   }, \n   _links :   { \n     self :   { \n       href :   http://localhost:9999/product-service/products{?page,size,sort} , \n       templated :   true \n     }, \n     profile :   { \n       href :   http://localhost:9999/product-service/profile/products \n     }, \n     search :   { \n       href :   http://localhost:9999/product-service/products/search \n     } \n   }, \n   page :   { \n     size :   20 , \n     totalElements :   3 , \n     totalPages :   1 , \n     number :   0 \n   }  }", 
            "title": "Cr\u00e9ation d'un fichier RAML pour le microservice"
        }, 
        {
            "location": "/tp5/#nouveau-projet-de-api-management", 
            "text": "Cr\u00e9er un nouveau projet qu\u2019on appellera  API_Project :   Choisir comme environnement d\u2019ex\u00e9cution Mule Server.  Cocher la case  Add APIKit components  et entrer votre fichier api.raml.   Un nouveau projet sera cr\u00e9\u00e9 avec les fichiers  api.raml  et  products-example.json  ajout\u00e9 sous le r\u00e9pertoire  src/main/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment:     Flux  Description  Figure      api-main  Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception     action:/ressource:api-config  Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products     Exception Strategy Mapping  Flux fournis par Studio pour configurer les messages d\u2019erreur dans un format HTTP-status-code-friendly", 
            "title": "Nouveau Projet de API Management"
        }, 
        {
            "location": "/tp5/#configuration-du-flux-principal", 
            "text": "Dans les propri\u00e9t\u00e9s du composant HTTP, d\u00e9finir le Path par: /prod-services/*.  Dans le  Connector Configuration , cliquer sur l'ic\u00f4ne  , puis cliquer sur  OK  pour valider le host (0.0.0.0) et le port (8081)    Remarque  Vous pouvez changer ici le port d\u00e9fini par d\u00e9faut, pour \u00e9viter les conflits avec vos microservices.   Lancer le projet comme  Mule Project . Une  APIKit Console  s'affiche comme suit:   Pour tester votre API, cliquer par exemple sur le bouton  GET  devant la ressource  /products . la Console affichera alors la r\u00e9ponse (le produit  Sample Product ), qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part.   Pour visualiser le r\u00e9sultat sur le navigateur, taper le chemin de la requ\u00eate comme suit:  http://localhost:8081/prod-services/products  Vous obtiendrez le r\u00e9sultat suivant:", 
            "title": "Configuration du flux principal"
        }, 
        {
            "location": "/tp5/#mapping-de-lapi-avec-votre-microservice-productservice", 
            "text": "Pour relier votre API cr\u00e9\u00e9e avec le microservice Proxy (cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent), et qui est d\u00e9ploy\u00e9 \u00e0 l'adresse suivante:  http://localhost:9999/product-service/products   Supprimer le  Set Payload  du flow :  get:/products:api-config  Ajouter un connecteur HTTP dans la partie  Source  Le configurer comme suit:  Path: /prod-services  Cliquer sur   puis sur OK pour valider le h\u00f4te et port.    Ajouter un connecteur HTTP dans la partie  Process  Le configurer comme suit:  Devant  Connector Configuration , cliquer sur   pour ajouter une nouvelle configuration.  Cela repr\u00e9sente les informations du service auquel on va acc\u00e9der. D\u00e9finir le Host par  localhost , le port par  9999 , et le base path par  /product-service  Cliquer sur OK pour valider    Dans la partie  URL Settings , d\u00e9finir :  Path: /products  Method: Get    Sauvegarder, et lancer le service.   Tester le service sur le navigateur avec l'URL:  http://localhost:8081/prod-services . Vous obtiendrez la liste compl\u00e8te des produits, tels que retourn\u00e9s par le service  ProductService  initial, comme suit:  { \n   _embedded :   { \n     products :   [ \n       { \n         name :   Pencil , \n         _links :   { \n           self :   { \n             href :   http://localhost:9999/product-service/products/1 \n           }, \n           product :   { \n             href :   http://localhost:9999/product-service/products/1 \n           } \n         } \n       }, \n       { \n         name :   Book , \n         _links :   { \n           self :   { \n             href :   http://localhost:9999/product-service/products/2 \n           }, \n           product :   { \n             href :   http://localhost:9999/product-service/products/2 \n           } \n         } \n       }, \n       { \n         name :   Eraser , \n         _links :   { \n           self :   { \n             href :   http://localhost:9999/product-service/products/3 \n           }, \n           product :   { \n             href :   http://localhost:9999/product-service/products/3 \n           } \n         } \n       } \n     ] \n   }, \n   _links :   { \n     self :   { \n       href :   http://localhost:9999/product-service/products{?page,size,sort} , \n       templated :   true \n     }, \n     profile :   { \n       href :   http://localhost:9999/product-service/profile/products \n     }, \n     search :   { \n       href :   http://localhost:9999/product-service/products/search \n     } \n   }, \n   page :   { \n     size :   20 , \n     totalElements :   3 , \n     totalPages :   1 , \n     number :   0 \n   }  }", 
            "title": "Mapping de l'API avec votre microservice ProductService"
        }, 
        {
            "location": "/tp5/#transformation-du-resultat-du-microservice-productservice", 
            "text": "Si vous d\u00e9sirez retourner un r\u00e9sultat diff\u00e9rent du Microservice initial, en ne laissant par exemple que les noms des produits, sans tous les autres \u00e9l\u00e9ments et liens suppl\u00e9mentaires, utiliser un objet  Transform Message   Copier le flow get:/products pour cr\u00e9er un autre flow identique  Modifier le Path du connecteur HTTP source, pour   /prod-services/names  Rajouter un objet  Transform Message  juste apr\u00e8s le connecteur HTTP de droite (celui de la partie Process). Le flow devra ressembler \u00e0 ce qui suit:      Configurer l'objet  Transform Message :   L'interface suivante repr\u00e9sente les mappings \u00e0 faire entre les entr\u00e9es du service et sa sortie.     Cliquer sur  Define Metadata  du payload en entr\u00e9e (\u00e0 gauche) gauche)  Cliquer sur  Add  Entrer le nom du type en entr\u00e9e, par exemple  products  Indiquer comme type  JSON  Indiquer dans la liste d\u00e9roulante suivante que le fichier donn\u00e9 est un  Example , puis choisir le fichier  products-example.json  que vous aviez cr\u00e9\u00e9.  Cliquer sur Select. Le sch\u00e9ma du fichier donn\u00e9 est charg\u00e9 dans la partie  Input  de  Transform Message .  Pour repr\u00e9senter le format de sortie d\u00e9sir\u00e9, cr\u00e9er un fichier appel\u00e9  names.json  \u00e0 l'endroit de votre pr\u00e9f\u00e9rence sur votre ordinateur.  Saisir le contenu suivant dans  names.json :     { name : prod }   Cliquer sur  Define Metadata  de sortie (\u00e0 droite).  Ajouter un nouveau type que vous appellerez  names  D\u00e9finir comme type  Json  et charger le fichier  names.json  que vous venez de cr\u00e9er.  Valider.  Maintenant que les deux sch\u00e9mas (entr\u00e9e et sortie) sont d\u00e9finis, cr\u00e9er les associations de votre choix. Dans notre cas, nous allons associer le champ  _embedded.products.name  en entr\u00e9e au champ  name  en sortie, comme suit:   Sauvegarder, et lancer le service.     Pour tester le service, lancer dans un navigateur:  http://localhost:8081/prod-services/names . Vous obtiendrez le r\u00e9sultat suivant:  { \n   name :   [ \n     Pencil , \n     Book , \n     Eraser \n   ]  }", 
            "title": "Transformation du r\u00e9sultat du microservice ProductService"
        }
    ]
}