{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Travaux Pratiques eServices \u00b6 Ce(tte) \u0153uvre est mise \u00e0 disposition selon les termes de la Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International . GL5 - INSAT \u00b6 Cours Disponible ici: http://liliasfaxi.wix.com/liliasfaxi/eservices Piazza : https://piazza.com/class/j3k0yr6cyex4n8 Repo Github : https://github.com/INSATunisia Overview \u00b6 Vous trouverez sur mon site officiel le cours Big Data associ\u00e9 \u00e0 ces TPs.L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures \u00e0 base de services en g\u00e9n\u00e9ral. Le cours va concerner principalement les points suivants: L'architecture orient\u00e9e services (SOA: Service-Oriented Architecture) La composition de services: orchestration et chor\u00e9graphie Les bus de services (ESB: Enterprise Service Bus) Les Microservices Le API Management L'architecture orient\u00e9e web (WOA: Web-Oriented Architecture) Ce cours comporte cinq s\u00e9ances de travaux pratiques: TP1 : Manipulation des services SOAP et REST avec Talend TP2 : Orchestration des services avec Camunda TP3 : Mise en place d'un ESB avec Talend ESB TP4 : Microservices avec Spring Boot et Spring Cloud TP5 : API Management avec Anypoint","title":"Travaux Pratiques eServices"},{"location":"#travaux-pratiques-eservices","text":"Ce(tte) \u0153uvre est mise \u00e0 disposition selon les termes de la Licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International .","title":"Travaux Pratiques eServices"},{"location":"#gl5-insat","text":"Cours Disponible ici: http://liliasfaxi.wix.com/liliasfaxi/eservices Piazza : https://piazza.com/class/j3k0yr6cyex4n8 Repo Github : https://github.com/INSATunisia","title":"GL5 - INSAT"},{"location":"#overview","text":"Vous trouverez sur mon site officiel le cours Big Data associ\u00e9 \u00e0 ces TPs.L'objectif de ce cours est d'initier les \u00e9tudiants aux architectures \u00e0 base de services en g\u00e9n\u00e9ral. Le cours va concerner principalement les points suivants: L'architecture orient\u00e9e services (SOA: Service-Oriented Architecture) La composition de services: orchestration et chor\u00e9graphie Les bus de services (ESB: Enterprise Service Bus) Les Microservices Le API Management L'architecture orient\u00e9e web (WOA: Web-Oriented Architecture) Ce cours comporte cinq s\u00e9ances de travaux pratiques: TP1 : Manipulation des services SOAP et REST avec Talend TP2 : Orchestration des services avec Camunda TP3 : Mise en place d'un ESB avec Talend ESB TP4 : Microservices avec Spring Boot et Spring Cloud TP5 : API Management avec Anypoint","title":"Overview"},{"location":"tp1/","text":"TP1 - Services Web REST et SOAP avec Talend \u00b6 T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend. Outils et Versions \u00b6 Talend Open Studio for ESB Version: 7.2 Java Version 1.8 MySQL Version 5.7 SOAPUI Version 5.3 Talend ESB \u00b6 Talend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services web s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes. Talend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9 Apache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache et a fait plusieurs contributions aux projets Apache. Talend fournit: Un courtier de messages \u00e0 haute performance. Des options de d\u00e9ploiement flexibles Des outils de d\u00e9veloppement pour Eclipse Une interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications Support pour les services web SOAP et REST La m\u00e9diation et le routage Support pour le failover, le monitoring et la s\u00e9curit\u00e9 L\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi. L\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox comme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les diff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es. Talend Open Studio for ESB \u00b6 Talend Open Studio for ESB (TOS-ESB) fournit une interface graphique de d\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des applications REST, des services de donn\u00e9es et des routes de messages. Le d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs repr\u00e9sent\u00e9s dans cette figure: Le bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des donn\u00e9es, des services ou des applications Les blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend d\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et d\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est possible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez basculer gr\u00e2ce \u00e0 Talend Service Locator. Le bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les informations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services. L\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit: Composant Fonctionnalit\u00e9 Le traditionnel Repository contenant vos Jobs, services, fichiers, routes\u2026 La fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes La fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026 La palette des composants \u00e0 utiliser Les onglets pour le choix de la perspective \u00e0 utiliser Service Web SOAP : Helloworld \u00b6 Nous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des services web avec les outils Talend ESB. Nous allons donc commencer avec le traditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix. Dans toute cette partie, nous nous trouverons dans la perspective Integration. Cr\u00e9er le service SOAP \u00b6 Pour cr\u00e9er un nouveau service de type SOAP: Clic-droit sur Services de votre Repository, et choisir Create Service . Appeler le service HelloWorldService . Cliquer sur Suivant. On vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer. Un service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est cr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche. Configurer le service SOAP \u00b6 Pour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord: Importer le WSDL de votre service dans votre repository. Pour cela, clic droit sur HelloWorldService , et choisir Importer les sch\u00e9mas WSDL . Vous retrouverez votre WSDL dans la partie Metadonn\u00e9es -> Fichier XML . Cr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration HelloWorldServiceOperation (sous Services) et choisir Assign Job . Modifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le tLogRow nous permettra d\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au consommateur): Astuce Il est conseill\u00e9 de relier d'abord les composants tXMLMap et tESBProviderResponse_1 , puis d'ins\u00e9rer le tLogRow . On vous demandera en reliant les deux premiers composants : R\u00e9cup\u00e9rer le sch\u00e9ma du composant cible? . Cliquer sur Oui . Configurer votre tXMLMap pour que le in de la requ\u00eate soit transmise au out de la r\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela: Double clic sur votre XML Map. Clic-droit sur payload de l\u2019entr\u00e9e, et cliquer sur Import from Repository . Choisir le HelloWorldServiceOperationRequest correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9. Refaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant HelloWorldServiceOperationResponse . Relier le in de la requ\u00eate avec le out de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse) Modifier l\u2019expression du out en ajoutant la cha\u00eene \u201cHello \u201c avant la valeur in de l\u2019entr\u00e9e. Le r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit: Sauvegarder et quitter. Lancer votre Job (cela permettra de publier votre service web sur le port 8090). V\u00e9rifier que votre fichier WSDL existe bien. Tester le service SOAP \u00b6 Il est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9 SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale Donner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit: Double cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le ? par un nom de votre choix. Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant: Consommateur du WebService SOAP \u00b6 Nous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela: Cr\u00e9er un nouveau Job, que vous appellerez HelloWorldServiceConsumer . Concevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante: Voici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 : tFixedFlowInput : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service tXMLMap : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service tESBConsumer : consommateur du service tLogRow : afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a) Configurer votre composant tFixedFlowInput . Pour cela: Cliquer sur Modifier le sch\u00e9ma et ajouter une colonne appel\u00e9e Nom de type String . Utiliser une Inline Table pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d. Configurer votre tESBConsumer en lui donnant comme WSDL celui du service que vous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090. Configurer votre tXMLMap pour que la variable Nom soit associ\u00e9e au in de votre service. Ex\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant: Service Web REST : Interrogation d'une base de donn\u00e9es \u00b6 Nous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es. Cr\u00e9ation de la base de donn\u00e9es \u00b6 Nous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e eservices-tp1 avec une table, que nous appellerons user . Cette table contient les champs id , firstname et lastname . Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es. Elle devra ressembler \u00e0 ce qui suit: Ajout de la connexion \u00e0 la base avec Talend \u00b6 Pour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes: Dans les M\u00e9tadonn\u00e9es, sous Connexions aux bases de donn\u00e9es , clic-droit, puis choisir: Cr\u00e9er une connexion . Configurer votre connexion. Voici un exemple: Une fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -> Connexions... -> et choisir: R\u00e9cup\u00e9rer le sch\u00e9ma . S\u00e9lectionner la table user , et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma. Cr\u00e9ation du service REST \u00b6 Nous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera DBService , puis glisser les composants suivants: tRestRequest : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler user : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous Sch\u00e9mas des tables , glisser la table user vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet. Remarque Je choisis tMySQLInput car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le Input ). tFlowToIterate : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales. tXMLMap : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate. tRestResponse : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate. tLogRow : Pour le log, bien s\u00fbr. Le job aura l'allure suivante: Configuration du service REST \u00b6 Nous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI: http://localhost:8088/users?from=1&to=3 , le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3. Configuration de tRestRequest \u00b6 tRestRequest devra \u00eatre configur\u00e9 comme suit: La valeur de Endpoint URL devra \u00eatre: \"http://localhost:8088/users\" Si vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9 getUsers , vous devriez le retrouver dans la case REST API Mapping . Sinon, cr\u00e9ez-le. Garder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON). En cliquant sur getUsers , un bouton avec trois petits points appara\u00eet. Cliquez dessus. Ajouter les deux colonnes from et to repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que: Leur type soit int Leurs valeurs par d\u00e9faut soient respectivement 1 et 3. Remarque Ces valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres. Leur commentaire ait la valeur: query Remarque Cela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path. Configuration de user \u00b6 Puisque le composant user a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires. Il suffira dans notre cas de: Cliquer sur Guess Schema pour charger le sch\u00e9ma de la base. Changer la requ\u00eate pour qu'elle soit comme suit: \"SELECT * FROM `user` where id>=\" + globalMap . get ( \"getUsers.from\" ) + \" and id<=\" + globalMap . get ( \"getUsers.to\" ) Remarque globalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres. Configuration de tXMLMap \u00b6 Cliquer deux fois sur la tXMLMap pour la configurer. Dans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e body dont le type est Document . Cette colonne contient un \u00e9l\u00e9ment root . Renommer cet \u00e9l\u00e9ment pour users . Ajouter un sous-\u00e9l\u00e9ment \u00e0 users appel\u00e9 user . D\u00e9finir cet \u00e9l\u00e9ment comme loop Element . Glisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le user . Cr\u00e9ez-le comme attribut du noeud cible. De m\u00eame pour le firstname et lastname , qui seront, eux, des sous-\u00e9l\u00e9ments du noeud user . Dans la colonne de droite, cliquer sur la petite clef \u00e0 molette ( ). Mettre la valeur de \"All in one\" \u00e0 true . Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux. La configuration finale sera donc comme suit: Indication La configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante: <users> <user id= 1 > <firstname> flen </firstname> <lastname> fouleni </lastname> </user> <user id= 2 > <firstname> flena </firstname> <lastname> foulenia </lastname> </user> <users> Les autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur Ex\u00e9cuter . Tester le Service \u00b6 Dans un navigateur \u00b6 Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix. Par exemple, la requ\u00eate suivante : http://localhost:8088/users?from=2&to=4 donnera: <users> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> <user id= \"4\" > <firstname> Monia </firstname> <lastname> Landolsi </lastname> </user> </users> Si aucun param\u00e8tre n'est indiqu\u00e9: http://localhost:8088/users cela donnera: <users> <user id= \"1\" > <firstname> Ahmed </firstname> <lastname> Ramzi </lastname> </user> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> </users> Avec SOAPUI \u00b6 Tester le service SOAP \u00b6 Il est possible de tester votre service REST avec SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale Entrer l'URI que vous d\u00e9sirez tester: http://localhost:8088/users?from=2&to=4 La fen\u00eatre suivante devrait appara\u00eetre: Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant: Consommateur du WebService REST \u00b6 Pour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant: Configurer le tRestClient comme suit: Ex\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:","title":"TP1 - Services Web REST et SOAP avec Talend"},{"location":"tp1/#tp1-services-web-rest-et-soap-avec-talend","text":"","title":"TP1 - Services Web REST et SOAP avec Talend"},{"location":"tp1/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp1/#objectifs-du-tp","text":"Cr\u00e9ation et consommation de web services SOAP et REST en utilisant l'outil Talend.","title":"Objectifs du TP"},{"location":"tp1/#outils-et-versions","text":"Talend Open Studio for ESB Version: 7.2 Java Version 1.8 MySQL Version 5.7 SOAPUI Version 5.3","title":"Outils et Versions"},{"location":"tp1/#talend-esb","text":"Talend ESB est une solution l\u00e9g\u00e8re, robuste et modulaire pour la cr\u00e9ation de services web s\u00e9curis\u00e9s ainsi que pour l\u2019int\u00e9gration d\u2019applications nouvelles ou existantes. Talend participe au d\u00e9veloppement des composants ESB \u00e0 travers la communaut\u00e9 Apache. Il collabore avec un grand nombre de d\u00e9veloppeurs de la communaut\u00e9 Apache et a fait plusieurs contributions aux projets Apache. Talend fournit: Un courtier de messages \u00e0 haute performance. Des options de d\u00e9ploiement flexibles Des outils de d\u00e9veloppement pour Eclipse Une interface utilisateur pour l\u2019int\u00e9gration et la m\u00e9diation d\u2019applications Support pour les services web SOAP et REST La m\u00e9diation et le routage Support pour le failover, le monitoring et la s\u00e9curit\u00e9 L\u2019environnement d\u2019ex\u00e9cution standard de Talend ESB est un conteneur OSGi. L\u2019impl\u00e9mentation OSGi fournie avec Talend ESB est Apache Karaf, avec Eclipse Equinox comme environnement d\u2019ex\u00e9cution OSGi. Elle fournit un conteneur l\u00e9ger dans lequel les diff\u00e9rents composants et applications peuvent \u00eatre d\u00e9ploy\u00e9es.","title":"Talend ESB"},{"location":"tp1/#talend-open-studio-for-esb","text":"Talend Open Studio for ESB (TOS-ESB) fournit une interface graphique de d\u00e9veloppement pour impl\u00e9menter, compiler, tester et publier des services Web Java, des applications REST, des services de donn\u00e9es et des routes de messages. Le d\u00e9ploiement d\u2019applications avec TOS-ESB utilise principalement les trois blocs repr\u00e9sent\u00e9s dans cette figure: Le bloc bleu repr\u00e9sente l\u2019API Talend Studio, o\u00f9 il est possible d\u2019int\u00e9grer des donn\u00e9es, des services ou des applications Les blocs rouges repr\u00e9sentent un ou plusieurs environnements d\u2019ex\u00e9cution Talend d\u00e9ploy\u00e9s dans votre syst\u00e8me d\u2019information. Il vous permet de d\u00e9ployer et d\u2019ex\u00e9cuter les Jobs, les routes et les services cr\u00e9\u00e9s dans Talend Studio. Il est possible d\u2019avoir plusieurs environnements d\u2019ex\u00e9cution, entre lesquels vous pouvez basculer gr\u00e2ce \u00e0 Talend Service Locator. Le bloc orange est une base de donn\u00e9es de monitoring, permettant de stocker les informations d\u2019ex\u00e9cution des processus et de l\u2019activit\u00e9 des services. L\u2019interface utilisateur de TOS-ESB se pr\u00e9sente comme suit: Composant Fonctionnalit\u00e9 Le traditionnel Repository contenant vos Jobs, services, fichiers, routes\u2026 La fen\u00eatre principale, repr\u00e9sentant graphiquement la composition de vos jobs et routes La fen\u00eatre contenant les propri\u00e9t\u00e9s, la console d\u2019ex\u00e9cution\u2026 La palette des composants \u00e0 utiliser Les onglets pour le choix de la perspective \u00e0 utiliser","title":"Talend Open Studio for ESB"},{"location":"tp1/#service-web-soap-helloworld","text":"Nous ne pouvons pas configurer un ESB avant de savoir cr\u00e9er, d\u00e9ployer et ex\u00e9cuter des services web avec les outils Talend ESB. Nous allons donc commencer avec le traditionnel Hello World. Pour cela, il faut commencer par cr\u00e9er un projet de votre choix. Dans toute cette partie, nous nous trouverons dans la perspective Integration.","title":"Service Web SOAP : Helloworld"},{"location":"tp1/#creer-le-service-soap","text":"Pour cr\u00e9er un nouveau service de type SOAP: Clic-droit sur Services de votre Repository, et choisir Create Service . Appeler le service HelloWorldService . Cliquer sur Suivant. On vous propose soit de cr\u00e9er un nouveau WSDL, soit de choisir un WSDL existant. Dans notre cas, nous cr\u00e9ons un nouveau WSDL. Cliquer sur Terminer. Un service simple qui re\u00e7oit une cha\u00eene de caract\u00e8res et en produit une autre est cr\u00e9\u00e9. Une vue graphique de son WSDL s\u2019affiche.","title":"Cr\u00e9er le service SOAP"},{"location":"tp1/#configurer-le-service-soap","text":"Pour pouvoir configurer votre service, il faut cr\u00e9er un Job. Mais d\u2019abord: Importer le WSDL de votre service dans votre repository. Pour cela, clic droit sur HelloWorldService , et choisir Importer les sch\u00e9mas WSDL . Vous retrouverez votre WSDL dans la partie Metadonn\u00e9es -> Fichier XML . Cr\u00e9er un nouveau Job pour votre service. Pour cela, clic-droit sur l\u2019op\u00e9ration HelloWorldServiceOperation (sous Services) et choisir Assign Job . Modifier votre Job pour qu\u2019il ait l\u2019allure suivante (Le tLogRow nous permettra d\u2019afficher le r\u00e9sultat du service ex\u00e9cut\u00e9 sur la console avant de l\u2019envoyer au consommateur): Astuce Il est conseill\u00e9 de relier d'abord les composants tXMLMap et tESBProviderResponse_1 , puis d'ins\u00e9rer le tLogRow . On vous demandera en reliant les deux premiers composants : R\u00e9cup\u00e9rer le sch\u00e9ma du composant cible? . Cliquer sur Oui . Configurer votre tXMLMap pour que le in de la requ\u00eate soit transmise au out de la r\u00e9ponse, en lui concat\u00e9nant le c\u00e9l\u00e8bre \"Hello\". Pour cela: Double clic sur votre XML Map. Clic-droit sur payload de l\u2019entr\u00e9e, et cliquer sur Import from Repository . Choisir le HelloWorldServiceOperationRequest correspondant au fichier WSDL que vous avez g\u00e9n\u00e9r\u00e9. Refaire les m\u00eames \u00e9tapes pour le payload de la sortie, en choisissant HelloWorldServiceOperationResponse . Relier le in de la requ\u00eate avec le out de la r\u00e9ponse (cr\u00e9er l\u2019entr\u00e9e comme sous-\u00e9l\u00e9ment de la r\u00e9ponse) Modifier l\u2019expression du out en ajoutant la cha\u00eene \u201cHello \u201c avant la valeur in de l\u2019entr\u00e9e. Le r\u00e9sultat de la XMLMap devrait ressembler \u00e0 ce qui suit: Sauvegarder et quitter. Lancer votre Job (cela permettra de publier votre service web sur le port 8090). V\u00e9rifier que votre fichier WSDL existe bien.","title":"Configurer le service SOAP"},{"location":"tp1/#tester-le-service-soap","text":"Il est possible de tester votre service de plusieurs mani\u00e8res. L'une d'elles est d'utiliser un outil l\u00e9ger de test appel\u00e9 SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne SOAP en haut de la fen\u00eatre principale Donner un nom au projet (par exemple Helloworld) et entrer l'adresse du fichier WSDL du service, comme suit: Double cliquer sur la requ\u00eate g\u00e9n\u00e9r\u00e9e, et remplir le ? par un nom de votre choix. Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:","title":"Tester le service SOAP"},{"location":"tp1/#consommateur-du-webservice-soap","text":"Nous allons maintenant cr\u00e9er un consommateur pour notre service avec talend open studio. Pour cela: Cr\u00e9er un nouveau Job, que vous appellerez HelloWorldServiceConsumer . Concevez votre job de mani\u00e8re \u00e0 ce qu\u2019il ait l\u2019allure suivante: Voici les r\u00f4les des \u00e9l\u00e9ments que vous avez ajout\u00e9 : tFixedFlowInput : d\u00e9finir les entr\u00e9es \u00e0 envoyer \u00e0 votre service tXMLMap : associer les entr\u00e9es d\u00e9finies aux entr\u00e9es du service tESBConsumer : consommateur du service tLogRow : afficher les r\u00e9ponses et/ou les fautes (s\u2019il y\u2019en a) Configurer votre composant tFixedFlowInput . Pour cela: Cliquer sur Modifier le sch\u00e9ma et ajouter une colonne appel\u00e9e Nom de type String . Utiliser une Inline Table pour ajouter les trois cha\u00eenes en entr\u00e9e: \u201cAlice\u201d, \u201cBob\u201d et \u201cChuck\u201d. Configurer votre tESBConsumer en lui donnant comme WSDL celui du service que vous avez cr\u00e9\u00e9. V\u00e9rifiez bien que le Endpoint soit sur le port 8090. Configurer votre tXMLMap pour que la variable Nom soit associ\u00e9e au in de votre service. Ex\u00e9cuter le Job, et observez le r\u00e9sultat. Votre console devrait afficher le r\u00e9sultat suivant:","title":"Consommateur du WebService SOAP"},{"location":"tp1/#service-web-rest-interrogation-dune-base-de-donnees","text":"Nous allons maintenant montrer comment exposer un service REST pour interroger une base de donn\u00e9es.","title":"Service Web REST : Interrogation d'une base de donn\u00e9es"},{"location":"tp1/#creation-de-la-base-de-donnees","text":"Nous allons commencer par cr\u00e9er une base de donn\u00e9es (MySQL dans mon cas), appel\u00e9e eservices-tp1 avec une table, que nous appellerons user . Cette table contient les champs id , firstname et lastname . Remplir ensuite la base \u00e0 votre guise, de mani\u00e8re \u00e0 avoir au moins 4 entr\u00e9es. Elle devra ressembler \u00e0 ce qui suit:","title":"Cr\u00e9ation de la base de donn\u00e9es"},{"location":"tp1/#ajout-de-la-connexion-a-la-base-avec-talend","text":"Pour configurer une connexion \u00e0 cette base de donn\u00e9es avec Talend, suivre les \u00e9tapes suivantes: Dans les M\u00e9tadonn\u00e9es, sous Connexions aux bases de donn\u00e9es , clic-droit, puis choisir: Cr\u00e9er une connexion . Configurer votre connexion. Voici un exemple: Une fois la connexion cr\u00e9\u00e9e, importer son sch\u00e9ma. Pour cela, clic-droit sur Metadonn\u00e9es -> Connexions... -> et choisir: R\u00e9cup\u00e9rer le sch\u00e9ma . S\u00e9lectionner la table user , et v\u00e9rifier que les champs sont bien charg\u00e9s dans la partie Sch\u00e9ma.","title":"Ajout de la connexion \u00e0 la base avec Talend"},{"location":"tp1/#creation-du-service-rest","text":"Nous allons maintenant cr\u00e9er le service REST. Pour cela, cr\u00e9er un nouveau job, qu'on appellera DBService , puis glisser les composants suivants: tRestRequest : Pour d\u00e9finir la requ\u00eate REST que le client doit appeler user : Table de la base de donn\u00e9es. Dans la nouvelle connexion \u00e0 la base de donn\u00e9es que vous avez cr\u00e9\u00e9, sous Sch\u00e9mas des tables , glisser la table user vers le Job, puis choisir tMySQLInput dans la fen\u00eatre de choix qui appara\u00eet. Remarque Je choisis tMySQLInput car, dans mon cas, c'est une base de donn\u00e9es MySQL, et je veux juste lire son contenu, je vais donc y acc\u00e9der en entr\u00e9e (d'o\u00f9 le Input ). tFlowToIterate : Pour effectuer une it\u00e9ration sur les donn\u00e9es d'entr\u00e9e et g\u00e9n\u00e8rer des variables globales. tXMLMap : Permet de router et transformer les flux entrants de la base de donn\u00e9es vers le r\u00e9sultat de la requ\u00eate. tRestResponse : Pour d\u00e9finir la r\u00e9ponse \u00e0 envoyer \u00e0 l'utilisateur suite \u00e0 sa requ\u00eate. tLogRow : Pour le log, bien s\u00fbr. Le job aura l'allure suivante:","title":"Cr\u00e9ation du service REST"},{"location":"tp1/#configuration-du-service-rest","text":"Nous d\u00e9sirons configurer le service de mani\u00e8re \u00e0 ce que, quand un consommateur appelle l'URI: http://localhost:8088/users?from=1&to=3 , le service retourne une r\u00e9ponse contenant les utilisateurs (id, nom et pr\u00e9nom) de la base de donn\u00e9es dont les ids figurent entre 1 et 3.","title":"Configuration du service REST"},{"location":"tp1/#configuration-de-trestrequest","text":"tRestRequest devra \u00eatre configur\u00e9 comme suit: La valeur de Endpoint URL devra \u00eatre: \"http://localhost:8088/users\" Si vous avez connect\u00e9 le tRestRequest avec le tFlowToIterate avec un lien appel\u00e9 getUsers , vous devriez le retrouver dans la case REST API Mapping . Sinon, cr\u00e9ez-le. Garder les informations par d\u00e9faut de ce mapping (m\u00e9thode GET, URI /, Produit XML ou JSON). En cliquant sur getUsers , un bouton avec trois petits points appara\u00eet. Cliquez dessus. Ajouter les deux colonnes from et to repr\u00e9sentant les deux param\u00e8tres de la requ\u00eate. Prenez soin \u00e0 ce que: Leur type soit int Leurs valeurs par d\u00e9faut soient respectivement 1 et 3. Remarque Ces valeurs seront utilis\u00e9es dans le cas o\u00f9 le consommateur n'introduit pas de param\u00e8tres. Leur commentaire ait la valeur: query Remarque Cela indique que ces champs sont des param\u00e8tres de requ\u00eate, pas d\u00e9finies dans le Path.","title":"Configuration de tRestRequest"},{"location":"tp1/#configuration-de-user","text":"Puisque le composant user a \u00e9t\u00e9 cr\u00e9\u00e9 \u00e0 partir de la connexion \u00e0 votre base MySQL, il contient d\u00e9j\u00e0 les informations de connexion n\u00e9cessaires. Il suffira dans notre cas de: Cliquer sur Guess Schema pour charger le sch\u00e9ma de la base. Changer la requ\u00eate pour qu'elle soit comme suit: \"SELECT * FROM `user` where id>=\" + globalMap . get ( \"getUsers.from\" ) + \" and id<=\" + globalMap . get ( \"getUsers.to\" ) Remarque globalMap est une variable globale permettant de stocker les informations de la requ\u00eate, comme par exemple ses param\u00e8tres.","title":"Configuration de user"},{"location":"tp1/#configuration-de-txmlmap","text":"Cliquer deux fois sur la tXMLMap pour la configurer. Dans la colonne de droite, ajouter (si ce n'est d\u00e9j\u00e0 fait) une colonne intitul\u00e9e body dont le type est Document . Cette colonne contient un \u00e9l\u00e9ment root . Renommer cet \u00e9l\u00e9ment pour users . Ajouter un sous-\u00e9l\u00e9ment \u00e0 users appel\u00e9 user . D\u00e9finir cet \u00e9l\u00e9ment comme loop Element . Glisser-d\u00e9placer l'id de la colonne en entr\u00e9e vers le user . Cr\u00e9ez-le comme attribut du noeud cible. De m\u00eame pour le firstname et lastname , qui seront, eux, des sous-\u00e9l\u00e9ments du noeud user . Dans la colonne de droite, cliquer sur la petite clef \u00e0 molette ( ). Mettre la valeur de \"All in one\" \u00e0 true . Cela permettra \u00e0 toutes les donn\u00e9es XML d'\u00eatre \u00e9crites dans un seul flux. La configuration finale sera donc comme suit: Indication La configuration pr\u00e9c\u00e9dente va g\u00e9n\u00e9rer une r\u00e9ponse de la forme suivante: <users> <user id= 1 > <firstname> flen </firstname> <lastname> fouleni </lastname> </user> <user id= 2 > <firstname> flena </firstname> <lastname> foulenia </lastname> </user> <users> Les autres composants devront rester tels qu'ils sont par d\u00e9faut. Il suffira maintenant de lancer le service, en cliquant sur Ex\u00e9cuter .","title":"Configuration de tXMLMap"},{"location":"tp1/#tester-le-service","text":"","title":"Tester le Service"},{"location":"tp1/#dans-un-navigateur","text":"Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requ\u00eate de votre choix. Par exemple, la requ\u00eate suivante : http://localhost:8088/users?from=2&to=4 donnera: <users> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> <user id= \"4\" > <firstname> Monia </firstname> <lastname> Landolsi </lastname> </user> </users> Si aucun param\u00e8tre n'est indiqu\u00e9: http://localhost:8088/users cela donnera: <users> <user id= \"1\" > <firstname> Ahmed </firstname> <lastname> Ramzi </lastname> </user> <user id= \"2\" > <firstname> Souad </firstname> <lastname> Mezghenni </lastname> </user> <user id= \"3\" > <firstname> Mourad </firstname> <lastname> Lahwel </lastname> </user> </users>","title":"Dans un navigateur"},{"location":"tp1/#avec-soapui","text":"","title":"Avec SOAPUI"},{"location":"tp1/#tester-le-service-soap_1","text":"Il est possible de tester votre service REST avec SOAPUI . Lancer SOAPUI Cliquer sur l'ic\u00f4ne REST en haut de la fen\u00eatre principale Entrer l'URI que vous d\u00e9sirez tester: http://localhost:8088/users?from=2&to=4 La fen\u00eatre suivante devrait appara\u00eetre: Cliquer sur la fl\u00e8che verte. Le r\u00e9sultat devra ressembler au suivant:","title":"Tester le service SOAP"},{"location":"tp1/#consommateur-du-webservice-rest","text":"Pour cr\u00e9er un consommateur pour le web service REST avec Talend, il suffit de cr\u00e9er le Job suivant: Configurer le tRestClient comme suit: Ex\u00e9cuter. Le r\u00e9sultat devrait ressembler \u00e0 ceci:","title":"Consommateur du WebService REST"},{"location":"tp2/","text":"TP2 - Orchestration de Services avec Camunda \u00b6 T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda. Outils et Versions \u00b6 Camunda Version: 7.7.0 Java Version 1.8.0_121 (7+ needed). IntelliJ IDEA Version Ultimate 2016.1 (ou tout autre IDE de votre choix) Camunda Modeler Version 1.10.0 Camunda \u00b6 Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support BPMN pour l'automatisation des processus, CMMN pour le Case Management, et DMN pour le Business Decision Management. BPMN 2.0 \u00b6 BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations. Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier. Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti. Installation \u00b6 Pour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes: T\u00e9l\u00e9charger Camunda (Distribution Tomcat), IntelliJ IDEA et Camunda Modeler . D\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter start-camunda.sh (pour les syst\u00e8mes Unix-based) ou start-camunda.bat (pour les syst\u00e8mes Windows). Ouvrir la page d'accueil du serveur d'application dans votre navigateur pr\u00e9f\u00e9r\u00e9. Lancer le Camunda Modeler. Premier Projet Camunda BPMN: Helloworld \u00b6 Cr\u00e9ation du Projet et D\u00e9pendances \u00b6 Vous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus. Ouvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype). Vous pouvez choisir les param\u00e8tres suivants: Group Id: tn.insat.eservices.tp2 Artifact Id: Helloworld Project Name: HelloworldCamunda Dans le fichier pom.xml , indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier war . Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version: <packaging> war </packaging> Ajouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier pom.xml <dependencyManagement> <dependencies> <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-bom </artifactId> <version> 7.7.0 </version> <scope> import </scope> <type> pom </type> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-engine </artifactId> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 3.0.1 </version> <scope> provided </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-war-plugin </artifactId> <version> 2.3 </version> <configuration> <failOnMissingWebXml> false </failOnMissingWebXml> </configuration> </plugin> </plugins> </build> Faire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez maven-install par exemple, et vous \u00e9crirez dans la partie Command Line : install , comme suit: Lancer le build et v\u00e9rifiez bien que vos packages ont bien \u00e9t\u00e9 install\u00e9s. Cr\u00e9ation de la classe principale pour le processus \u00b6 La prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda. package tn.insat.eservices.tp2.helloworld ; import org.camunda.bpm.application.ProcessApplication ; import org.camunda.bpm.application.impl.ServletProcessApplication ; @ProcessApplication ( \"Helloworld App\" ) public class HelloworldApplication extends ServletProcessApplication { // empty implementation } Ajouter ensuite le fichier processes.xml sous le r\u00e9pertoire src/main/resources/META-INF . Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus. <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <process-application xmlns= \"http://www.camunda.org/schema/1.0/ProcessApplication\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" > <process-archive name= \"helloworld\" > <process-engine> default </process-engine> <properties> <property name= \"isDeleteUponUndeploy\" > false </property> <property name= \"isScanForProcessDefinitions\" > true </property> </properties> </process-archive> </process-application> A partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus. Mod\u00e9lisation d'un processus BPMN 2.0 \u00b6 La mod\u00e9lisation du processus se fera gr\u00e2ce au Camunda Modeler . Pour cela: D\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN en cliquant sur File > New File > BPMN Diagram . Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons Dis Bonjour . Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 Ajouter Bonjour . Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel Bonjour <nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir User Task . Rajouter une t\u00e2che de fin au processus. Nous obtenons pour finir le diagramme suivant: Configuration du processus \u00b6 Pour configurer la t\u00e2che utilisateur Ajouter Bonjour , cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). D\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ Assignee , ins\u00e9rer john . John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les. Pour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants: Id: helloworld Name: Helloworld Executable: true Vous obtiendrez le r\u00e9sultat suivant: Sauvegarder le diagramme sous le r\u00e9pertoire src/main/resources du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez helloworld.bpmn D\u00e9ploiement du processus \u00b6 Configurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ: Aller au menu File > Project Structure... Cliquer sur Artifacts . D\u00e9finir le type de l'archive \u00e0 d\u00e9ployer: Web Application: Archive D\u00e9finir comme Output Directory le r\u00e9pertoire webapps , se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire $CAMUNDA_HOME/server/apache-tomcat-<version>/webapps . En bas de la fen\u00eatre, vous trouverez un bouton Create Manifest . Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement. Vous obtiendrez le r\u00e9sultat suivant: Faire un make du projet. Pour cela, aller au menu Build > Make Project ou cliquer sur . Normalement, un nouveau fichier helloworld-1.0-SNAPSHOT.war sera cr\u00e9\u00e9 dans le r\u00e9pertoire webapps du serveur. Pour v\u00e9rifier que le processus a bien \u00e9t\u00e9 d\u00e9ploy\u00e9 sur le serveur Tomcat, consulter le fichier log se trouvant sous $CAMUNDA_HOME/server/apache-tomcat-<version>/logs et ouvrir le fichier catalina.out . Tip Le meilleur moyen de consulter en permanence le fichier log sur les syst\u00e8mes Linux-like est d'ouvrir un terminal, et de taper tail -f catalina.out . Le fichier devra contenir les lignes suivantes: V\u00e9rification du d\u00e9ploiement avec Cockpit \u00b6 Camunda offre l'outil Cockpit pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant: http://localhost:8080/camunda/app/cockpit . Identifiez-vous comme administrateur en tapant les credentials: demo/demo . Cliquer sur le nombre sous Process Definitions (cela devra \u00eatre 2 dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat checked . D\u00e9marrage du processus \u00b6 Aller au Camunda Tasklist ( http://localhost:8080/camunda/app/tasklist ), puis lancer le processus en cliquant sur le bouton Start Process (en haut \u00e0 droite). Cliquer sur votre processus Helloworld . Ajouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable nom de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur Add a variable et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien ): En rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat Running . Configuration des permissions \u00b6 Pour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus Helloworld , il faudra lui rajouter les autorisations. Pour cela: Aller \u00e0 Camunda Admin ( http://localhost:8080/camunda/app/admin/default/#/authorization?resource=0 ). Ajouter une nouvelle autorisation dans la partie Process Definition , pour permettre \u00e0 John de manipuler la d\u00e9finition du processus Helloworld . Dans la partie Process Instance , ajouter la permission de cr\u00e9er une instance de processus \u00e0 John. Vous authentifier comme \u00e9tant John, en utilisant ( john/john ), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus. Cr\u00e9ation d'un formulaire personnalis\u00e9 \u00b6 Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service, suivre les \u00e9tapes suivantes: Revenir vers IntelliJ, et cr\u00e9er un fichier dis-bonjour.html sous le r\u00e9pertoire src/main/webapp/forms . Ajouter le contenu suivant: < form name = \"disBonjour\" > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" /> </ div > </ form > Ouvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation Forms et ins\u00e9rer embedded:app:forms/dis-bonjour.html dans le champ Key . Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application. Sauvegarder, et rafra\u00eechir le projet dans IntelliJ. De m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera bonjour.html . < form name = \"bonjour\" > < div class = \"form-group\" > < label for = \"salutation\" > Salutation </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"salutation\" name = \"salutation\" /> </ div > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" readonly = \"true\" /> </ div > </ form > Affecter ce formulaire \u00e0 la t\u00e2che Ajouter Bonjour de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment. Sauvegarder tout et re-d\u00e9ployer le projet. Lancer maintenant le processus. Saisir votre nom dans la rubrique Nom . Identifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire: Pour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un Service Task . Ajout d'un Service Task Java \u00b6 Pour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes: Utiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette , s\u00e9lectionner l'option Service Task . Appeler le service Dire Bonjour . Vous obtiendrez le r\u00e9sultat suivant: Ajouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e ProcessRequestDelegate qui impl\u00e9mente l'interface JavaDelegate , comme suit: package tn.insat.eservices.tp2.helloworld ; import java.util.logging.Logger ; import org.camunda.bpm.engine.delegate.DelegateExecution ; import org.camunda.bpm.engine.delegate.JavaDelegate ; public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"!\" ); } } Utiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class: tn.insat.eservices.tp2.helloworld.ProcessRequestDelegate . D\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit: Appel d'un Service Web REST \u00b6 Gr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour. Commencer par ajuster le formulaire bonjour.html , en lui ajoutant un autre champs de texte: ville apr\u00e8s le champs nom . Revenir dans le Modeler, et ajouter un Service Task, qu'on appellera Consulter M\u00e9t\u00e9o , entre Ajouter Bonjour et Dire Bonjour . Dans ce service, indiquer que le type d'impl\u00e9mentation est Connector , et vous d\u00e9placer vers l'onglet Connector pour le configurer. Donner les param\u00e8tres suivants \u00e0 votre connecteur; Id : http-connector Input : Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web OpenWeatherMap . Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs ville . Nom Type Valeur url Script / JavaScript / Inline Script var ville=execution.getVariable(\"ville\"); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266&q='+ville; method Text GET headers Map key: accept, value:application/json - key:content-type, value:application/json Output : Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit: { coord : { lon : 10.17 , lat : 36.82 }, weather : [ { id : 801 , main : \"Clouds\" , description : \"few clouds\" , icon : \"02d\" } ], base : \"stations\" , main : { temp : 299.87 , pressure : 1018 , humidity : 39 , temp_min : 299.15 , temp_max : 301.15 }, visibility : 10000 , wind : { speed : 3.6 , deg : 40 }, clouds : { all : 20 }, dt : 1506864600 , sys : { type : 1 , id : 6318 , message : 0.0039 , country : \"TN\" , sunrise : 1506834907 , sunset : 1506877308 }, id : 2464470 , name : \"Tunis\" , cod : 200 } Si l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment main puis \u00e0 son fils temp . L'output de notre service aura donc la forme suivante: Nom Type Valeur WsResponse Script / JavaScript / Inline Script S(response).prop(\"main\").prop(\"temp\").numberValue(); Tip Toujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application! Maintenant, ajouter le code d'exploitation de ce service dans la classe ProcessRequestDelegate , pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate: public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"! La temp\u00e9rature aujourd'hui \u00e0 \" + execution . getVariable ( \"ville\" ) + \" est de \" + execution . getVariable ( \"WsResponse\" ) + \"!\" ); } } Tout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant: L'utilisateur demo saisit son nom: L'utilisateur john rajoute la salutation et la ville: Le processus affiche ce r\u00e9sultat sur le log: TAF Vous remarquerez que le service web REST que nous avons appel\u00e9 rend la temp\u00e9rature en degr\u00e9 Kelvin. Chercher un service web qui fasse la conversion du \u00baK vers le \u00baC, puis appelez-le avant de faire l'affichage.","title":"TP2 - Orchestration de Services avec Camunda"},{"location":"tp2/#tp2-orchestration-de-services-avec-camunda","text":"","title":"TP2 - Orchestration de Services avec Camunda"},{"location":"tp2/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp2/#objectifs-du-tp","text":"Cr\u00e9ation d'un processus m\u00e9tier (Business Process) en utilisant Camunda.","title":"Objectifs du TP"},{"location":"tp2/#outils-et-versions","text":"Camunda Version: 7.7.0 Java Version 1.8.0_121 (7+ needed). IntelliJ IDEA Version Ultimate 2016.1 (ou tout autre IDE de votre choix) Camunda Modeler Version 1.10.0","title":"Outils et Versions"},{"location":"tp2/#camunda","text":"Camunda est une plateforme open source pour la gestion des processus m\u00e9tier. C'est un framework Java qui support BPMN pour l'automatisation des processus, CMMN pour le Case Management, et DMN pour le Business Decision Management.","title":"Camunda"},{"location":"tp2/#bpmn-20","text":"BPMN 2.0 (Business Process Modeling Notation) est un standard d\u00e9velopp\u00e9 par le Object Management Group ( OMG ) pour fournir une notation facilement compr\u00e9hensible par tous les utilisateurs m\u00e9tier: les analystes m\u00e9tier, les d\u00e9veloppeurs impl\u00e9mentant les technologies ex\u00e9cutant ces processus et les personnes g\u00e9rant et supervisant ces processus. BPMN permet d'\u00e9tablir un pont minimisant le gap entre les conceptions des processus et leurs impl\u00e9mentations. Dans sa premi\u00e8re version, la sp\u00e9cification BPMN permettait de fournir uniquement une notation graphique, et est devenue rapidement c\u00e9l\u00e8bre parmi les analystes m\u00e9tier. Elle d\u00e9finissait la mani\u00e8re dont les concepts tels que les t\u00e2ches humaines et les scripts ex\u00e9cutables, pouvaient \u00eatre visualis\u00e9es de mani\u00e8re standard, ind\u00e9pendante d'un constructeur particulier. Cette deuxi\u00e8me version \u00e9tend ce standard en incluant des s\u00e9mantiques d'ex\u00e9cution et un format d'\u00e9change commun. Ce qui veut dire que les mod\u00e8les de processus BPMN 2.0 peuvent \u00eatre \u00e9chang\u00e9s entre des \u00e9diteurs graphiques diff\u00e9rents, et ex\u00e9cut\u00e9s sur n'importe quel moteur compatible avec BPMN 2.0, tel que Camunda et Activiti.","title":"BPMN 2.0"},{"location":"tp2/#installation","text":"Pour installer l'environnement n\u00e9cessaire \u00e0 ce TP, il faut suivre les \u00e9tapes suivantes: T\u00e9l\u00e9charger Camunda (Distribution Tomcat), IntelliJ IDEA et Camunda Modeler . D\u00e9compresser le fichier .zip Camunda t\u00e9l\u00e9charg\u00e9, et ex\u00e9cuter start-camunda.sh (pour les syst\u00e8mes Unix-based) ou start-camunda.bat (pour les syst\u00e8mes Windows). Ouvrir la page d'accueil du serveur d'application dans votre navigateur pr\u00e9f\u00e9r\u00e9. Lancer le Camunda Modeler.","title":"Installation"},{"location":"tp2/#premier-projet-camunda-bpmn-helloworld","text":"","title":"Premier Projet Camunda BPMN: Helloworld"},{"location":"tp2/#creation-du-projet-et-dependances","text":"Vous allez maintenant cr\u00e9er un nouveau projet Java pour d\u00e9finir le comportement de votre processus. Ouvrir IntelliJ et cr\u00e9er un nouveau projet Maven (sans archetype). Vous pouvez choisir les param\u00e8tres suivants: Group Id: tn.insat.eservices.tp2 Artifact Id: Helloworld Project Name: HelloworldCamunda Dans le fichier pom.xml , indiquer que l'application sera d\u00e9ploy\u00e9e plus tard sous la forme d'un fichier war . Pour cela, ajouter la ligne suivante, juste apr\u00e8s la version: <packaging> war </packaging> Ajouter les d\u00e9pendances n\u00e9cessaires vers Camunda dans votre projet. Pour cela, ins\u00e9rer les lignes suivantes dans votre fichier pom.xml <dependencyManagement> <dependencies> <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-bom </artifactId> <version> 7.7.0 </version> <scope> import </scope> <type> pom </type> </dependency> </dependencies> </dependencyManagement> <dependencies> <dependency> <groupId> org.camunda.bpm </groupId> <artifactId> camunda-engine </artifactId> <scope> provided </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 3.0.1 </version> <scope> provided </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-war-plugin </artifactId> <version> 2.3 </version> <configuration> <failOnMissingWebXml> false </failOnMissingWebXml> </configuration> </plugin> </plugins> </build> Faire un build de votre projet. Pour cela, cr\u00e9er une nouvelle configuration de type Maven, que vous appellerez maven-install par exemple, et vous \u00e9crirez dans la partie Command Line : install , comme suit: Lancer le build et v\u00e9rifiez bien que vos packages ont bien \u00e9t\u00e9 install\u00e9s.","title":"Cr\u00e9ation du Projet et D\u00e9pendances"},{"location":"tp2/#creation-de-la-classe-principale-pour-le-processus","text":"La prochaine \u00e9tape permet de construire une classe pour le processus. Cette classe repr\u00e9sente l'interface entre votre application et le moteur de processus Camunda. package tn.insat.eservices.tp2.helloworld ; import org.camunda.bpm.application.ProcessApplication ; import org.camunda.bpm.application.impl.ServletProcessApplication ; @ProcessApplication ( \"Helloworld App\" ) public class HelloworldApplication extends ServletProcessApplication { // empty implementation } Ajouter ensuite le fichier processes.xml sous le r\u00e9pertoire src/main/resources/META-INF . Ce fichier nous permet de fournir une configuration pour le d\u00e9ploiement de ce processus dans le moteur de processus. <?xml version=\"1.0\" encoding=\"UTF-8\" ?> <process-application xmlns= \"http://www.camunda.org/schema/1.0/ProcessApplication\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" > <process-archive name= \"helloworld\" > <process-engine> default </process-engine> <properties> <property name= \"isDeleteUponUndeploy\" > false </property> <property name= \"isScanForProcessDefinitions\" > true </property> </properties> </process-archive> </process-application> A partir de ce point, nous allons commencer \u00e0 mod\u00e9liser le processus.","title":"Cr\u00e9ation de la classe principale pour le processus"},{"location":"tp2/#modelisation-dun-processus-bpmn-20","text":"La mod\u00e9lisation du processus se fera gr\u00e2ce au Camunda Modeler . Pour cela: D\u00e9marrer l'application, et cr\u00e9er un nouveau diagramme BPMN en cliquant sur File > New File > BPMN Diagram . Double-cliquer sur l'\u00e9v\u00e8nement de d\u00e9part (le petit rond) pour modifier son nom. Nous l'appelerons Dis Bonjour . Cliquer sur l'\u00e9v\u00e8nement de d\u00e9part, choisir le rectangle (repr\u00e9sentant une activit\u00e9) \u00e0 partir du menu contextuel qui appara\u00eet, et le glisser vers un emplacement ad\u00e9quat. Nous appellerons le nouvel \u00e9v\u00e8nement ins\u00e9r\u00e9 Ajouter Bonjour . Cette t\u00e2che sera celle o\u00f9 l'utilisateur va indiquer son nom pour l'\u00e9ternel Bonjour <nom>! . Pour cela, nous devons indiquer que le traitement fait ici sera r\u00e9alis\u00e9 par un humain. Pour cela, en cliquant sur l'activit\u00e9 cr\u00e9\u00e9e, cliquer dans le menu contextuel sur la clef \u00e0 molette, puis choisir User Task . Rajouter une t\u00e2che de fin au processus. Nous obtenons pour finir le diagramme suivant:","title":"Mod\u00e9lisation d'un processus BPMN 2.0"},{"location":"tp2/#configuration-du-processus","text":"Pour configurer la t\u00e2che utilisateur Ajouter Bonjour , cliquer dessus, et remplir le panneau des propri\u00e9t\u00e9s (sur la droite). D\u00e9finir l'utilisateur auquel sera destin\u00e9e cette activit\u00e9. Pour cela, dans le champ Assignee , ins\u00e9rer john . John est un utilisateur pr\u00e9d\u00e9fini sur le serveur Camunda. Plus tard, vous pourrez d\u00e9finir votre propre liste d'utilisateurs et de r\u00f4les. Pour configurer le processus en entier, cliquer sur un endroit vide du canevas. Dans le panneau des propri\u00e9t\u00e9s, indiquer les champs suivants: Id: helloworld Name: Helloworld Executable: true Vous obtiendrez le r\u00e9sultat suivant: Sauvegarder le diagramme sous le r\u00e9pertoire src/main/resources du projet que vous avez cr\u00e9\u00e9. Vous l'appellerez helloworld.bpmn","title":"Configuration du processus"},{"location":"tp2/#deploiement-du-processus","text":"Configurer l'application pour qu'elle soit d\u00e9ploy\u00e9e sur le serveur tomcat int\u00e9gr\u00e9 dans votre installation Camunda. Pour cela, dans IntelliJ: Aller au menu File > Project Structure... Cliquer sur Artifacts . D\u00e9finir le type de l'archive \u00e0 d\u00e9ployer: Web Application: Archive D\u00e9finir comme Output Directory le r\u00e9pertoire webapps , se trouvant en g\u00e9n\u00e9ral sous le r\u00e9pertoire $CAMUNDA_HOME/server/apache-tomcat-<version>/webapps . En bas de la fen\u00eatre, vous trouverez un bouton Create Manifest . Cliquer dessus, cela permettra de cr\u00e9er le fichier Manifest responsable du d\u00e9ploiement. Vous obtiendrez le r\u00e9sultat suivant: Faire un make du projet. Pour cela, aller au menu Build > Make Project ou cliquer sur . Normalement, un nouveau fichier helloworld-1.0-SNAPSHOT.war sera cr\u00e9\u00e9 dans le r\u00e9pertoire webapps du serveur. Pour v\u00e9rifier que le processus a bien \u00e9t\u00e9 d\u00e9ploy\u00e9 sur le serveur Tomcat, consulter le fichier log se trouvant sous $CAMUNDA_HOME/server/apache-tomcat-<version>/logs et ouvrir le fichier catalina.out . Tip Le meilleur moyen de consulter en permanence le fichier log sur les syst\u00e8mes Linux-like est d'ouvrir un terminal, et de taper tail -f catalina.out . Le fichier devra contenir les lignes suivantes:","title":"D\u00e9ploiement du processus"},{"location":"tp2/#verification-du-deploiement-avec-cockpit","text":"Camunda offre l'outil Cockpit pour inspecter les processus en cours d'ex\u00e9cution et compl\u00e9t\u00e9s, et g\u00e9rer les diff\u00e9rents incidents. Pour cela, si votre serveur Camunda est bien lanc\u00e9, vous pourrez visualiser vos processus dans le navigateur, en tapant: http://localhost:8080/camunda/app/cockpit . Identifiez-vous comme administrateur en tapant les credentials: demo/demo . Cliquer sur le nombre sous Process Definitions (cela devra \u00eatre 2 dans votre cas), vous devriez retrouver votre processus, avec un \u00e9tat checked .","title":"V\u00e9rification du d\u00e9ploiement avec Cockpit"},{"location":"tp2/#demarrage-du-processus","text":"Aller au Camunda Tasklist ( http://localhost:8080/camunda/app/tasklist ), puis lancer le processus en cliquant sur le bouton Start Process (en haut \u00e0 droite). Cliquer sur votre processus Helloworld . Ajouter autant de variables que n\u00e9cessaire dans le formulaire g\u00e9n\u00e9rique. Nous allons dans notre cas ajouter une variable nom de type cha\u00eene de caract\u00e8res. Pour cela, cliquer sur Add a variable et remplir comme suit (mettez votre nom bien s\u00fbr, pas le mien ): En rafra\u00eechissant maintenant le Cockpit, vous trouverez que le processus est pass\u00e9 \u00e0 l'\u00e9tat Running .","title":"D\u00e9marrage du processus"},{"location":"tp2/#configuration-des-permissions","text":"Pour permettre \u00e0 l'utilisateur John de visualiser et lancer le processus Helloworld , il faudra lui rajouter les autorisations. Pour cela: Aller \u00e0 Camunda Admin ( http://localhost:8080/camunda/app/admin/default/#/authorization?resource=0 ). Ajouter une nouvelle autorisation dans la partie Process Definition , pour permettre \u00e0 John de manipuler la d\u00e9finition du processus Helloworld . Dans la partie Process Instance , ajouter la permission de cr\u00e9er une instance de processus \u00e0 John. Vous authentifier comme \u00e9tant John, en utilisant ( john/john ), de pr\u00e9f\u00e9rence sur un autre navigateur. Vous pourrez ainsi visualiser le processus Helloworld, tel qu'il est visible par John. Il pourra ainsi ajouter les variables de son choix, et compl\u00e9ter le processus.","title":"Configuration des permissions"},{"location":"tp2/#creation-dun-formulaire-personnalise","text":"Pour cr\u00e9er votre propre formulaire, avec des variables en entr\u00e9e qui peuvent \u00eatre manipul\u00e9es par le service, suivre les \u00e9tapes suivantes: Revenir vers IntelliJ, et cr\u00e9er un fichier dis-bonjour.html sous le r\u00e9pertoire src/main/webapp/forms . Ajouter le contenu suivant: < form name = \"disBonjour\" > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" /> </ div > </ form > Ouvrir le processus avec le Modeler, et cliquer sur l'\u00e9v\u00e8nement de d\u00e9part. Dans le panneau des propri\u00e9t\u00e9s, choisir la tabulation Forms et ins\u00e9rer embedded:app:forms/dis-bonjour.html dans le champ Key . Cela indique que nous voulons utiliser un formulaire int\u00e9gr\u00e9 dans la Tasklist, et qu'il sera charg\u00e9 \u00e0 partir de l'application. Sauvegarder, et rafra\u00eechir le projet dans IntelliJ. De m\u00eame, nous allons cr\u00e9er le formulaire qui va permettre \u00e0 John de dire Bonjour. On l'appellera bonjour.html . < form name = \"bonjour\" > < div class = \"form-group\" > < label for = \"salutation\" > Salutation </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"salutation\" name = \"salutation\" /> </ div > < div class = \"form-group\" > < label for = \"nom\" > Nom </ label > < input class = \"form-control\" cam-variable-type = \"String\" cam-variable-name = \"nom\" name = \"nom\" readonly = \"true\" /> </ div > </ form > Affecter ce formulaire \u00e0 la t\u00e2che Ajouter Bonjour de la m\u00eame mani\u00e8re que pr\u00e9c\u00e9demment. Sauvegarder tout et re-d\u00e9ployer le projet. Lancer maintenant le processus. Saisir votre nom dans la rubrique Nom . Identifiez-vous comme John de nouveau, vous trouverez le deuxi\u00e8me formulaire: Pour l'instant, en cliquant sur compl\u00e9ter, rien ne se passe, car nous n'avons indiqu\u00e9 nulle part ce qui doit \u00eatre r\u00e9alis\u00e9 suite \u00e0 la saisie du \"Bonjour\" par John. Cela sera fait gr\u00e2ce \u00e0 un Service Task .","title":"Cr\u00e9ation d'un formulaire personnalis\u00e9"},{"location":"tp2/#ajout-dun-service-task-java","text":"Pour d\u00e9finir le comportement \u00e0 faire de votre service, suivre les \u00e9tapes suivantes: Utiliser le Modeler pour ajouter un service task juste apr\u00e8s le user task. Pour cela, s\u00e9lectionner une activit\u00e9 dans la palette de gauche, et la glisser entre la t\u00e2che utilisateur et l'\u00e9v\u00e8nement de fin. Avec la clef \u00e0 molette , s\u00e9lectionner l'option Service Task . Appeler le service Dire Bonjour . Vous obtiendrez le r\u00e9sultat suivant: Ajouter maintenant l'impl\u00e9mentation du Service Task. Pour cela, ajouter une classe dans le projet IntelliJ appel\u00e9e ProcessRequestDelegate qui impl\u00e9mente l'interface JavaDelegate , comme suit: package tn.insat.eservices.tp2.helloworld ; import java.util.logging.Logger ; import org.camunda.bpm.engine.delegate.DelegateExecution ; import org.camunda.bpm.engine.delegate.JavaDelegate ; public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"!\" ); } } Utiliser le panneau des propri\u00e9t\u00e9s pour r\u00e9f\u00e9rencer la classe dans le processus. Pour cela, cliquer sur le Service Task, et d\u00e9finir son impl\u00e9mentation par la Java Class: tn.insat.eservices.tp2.helloworld.ProcessRequestDelegate . D\u00e9ployer votre application, et observer le r\u00e9sultat. Il sera affich\u00e9 dans le log de votre serveur Tomcat (catalina.out), comme suit:","title":"Ajout d'un Service Task Java"},{"location":"tp2/#appel-dun-service-web-rest","text":"Gr\u00e2ce aux connecteurs, Camunda peut int\u00e9grer des services web REST ou SOAP. Pour cela, nous allons faire appel \u00e0 un service web classique de m\u00e9t\u00e9o. Dans son formulaire, John va saisir le nom d'une ville, et le processus devra retourner la temp\u00e9rature actuelle dans cette ville, en plus de l'usuel Bonjour. Commencer par ajuster le formulaire bonjour.html , en lui ajoutant un autre champs de texte: ville apr\u00e8s le champs nom . Revenir dans le Modeler, et ajouter un Service Task, qu'on appellera Consulter M\u00e9t\u00e9o , entre Ajouter Bonjour et Dire Bonjour . Dans ce service, indiquer que le type d'impl\u00e9mentation est Connector , et vous d\u00e9placer vers l'onglet Connector pour le configurer. Donner les param\u00e8tres suivants \u00e0 votre connecteur; Id : http-connector Input : Les input prendront toutes les informations n\u00e9cessaires pour envoyer la requ\u00eate REST au service web OpenWeatherMap . Ce service prend en param\u00e8tre la ville, qui sera ins\u00e9r\u00e9e dans notre cas \u00e0 partir du formulaire pr\u00e9c\u00e9dent, dans le champs ville . Nom Type Valeur url Script / JavaScript / Inline Script var ville=execution.getVariable(\"ville\"); 'http://api.openweathermap.org/data/2.5/weather?APPID=17db59488cadcad345211c36304a9266&q='+ville; method Text GET headers Map key: accept, value:application/json - key:content-type, value:application/json Output : Le service utilis\u00e9 renvoie un document json qui ressemble \u00e0 ce qui suit: { coord : { lon : 10.17 , lat : 36.82 }, weather : [ { id : 801 , main : \"Clouds\" , description : \"few clouds\" , icon : \"02d\" } ], base : \"stations\" , main : { temp : 299.87 , pressure : 1018 , humidity : 39 , temp_min : 299.15 , temp_max : 301.15 }, visibility : 10000 , wind : { speed : 3.6 , deg : 40 }, clouds : { all : 20 }, dt : 1506864600 , sys : { type : 1 , id : 6318 , message : 0.0039 , country : \"TN\" , sunrise : 1506834907 , sunset : 1506877308 }, id : 2464470 , name : \"Tunis\" , cod : 200 } Si l'objectif est de retourner la valeur de la temp\u00e9rature, on doit naviguer vers l'\u00e9l\u00e9ment main puis \u00e0 son fils temp . L'output de notre service aura donc la forme suivante: Nom Type Valeur WsResponse Script / JavaScript / Inline Script S(response).prop(\"main\").prop(\"temp\").numberValue(); Tip Toujours tester votre web service REST sur navigateur avant de l'utiliser dans une quelconque application! Maintenant, ajouter le code d'exploitation de ce service dans la classe ProcessRequestDelegate , pour lui indiquer d'afficher le r\u00e9sultat de la requ\u00eate: public class ProcessRequestDelegate implements JavaDelegate { private final static Logger LOGGER = Logger . getLogger ( \"Hello-Greetings\" ); public void execute ( DelegateExecution execution ) throws Exception { LOGGER . info ( \"Hey! \" + execution . getVariable ( \"salutation\" ) + \" \" + execution . getVariable ( \"nom\" ) + \"! La temp\u00e9rature aujourd'hui \u00e0 \" + execution . getVariable ( \"ville\" ) + \" est de \" + execution . getVariable ( \"WsResponse\" ) + \"!\" ); } } Tout sauvegarder puis d\u00e9ployer le service. En l'ex\u00e9cutant, vous obtenez le r\u00e9sultat suivant: L'utilisateur demo saisit son nom: L'utilisateur john rajoute la salutation et la ville: Le processus affiche ce r\u00e9sultat sur le log: TAF Vous remarquerez que le service web REST que nous avons appel\u00e9 rend la temp\u00e9rature en degr\u00e9 Kelvin. Chercher un service web qui fasse la conversion du \u00baK vers le \u00baC, puis appelez-le avant de faire l'affichage.","title":"Appel d'un Service Web REST"},{"location":"tp3/","text":"TP3 - Mise en Place d\u2019un ESB avec Talend ESB \u00b6 T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Routage, m\u00e9diation et transformation avec Talend ESB. Gestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB. Outils et Versions \u00b6 Talend Open Studio for ESB Version: 6.3.0 DB Visualizer Version 10.0 Java Version 1.8.0_121 Configuration et Utilisation de l'ESB Talend \u00b6 Lancement de deux instances de l'ESB Talend \u00b6 Pour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire: Aller dans le r\u00e9pertoire <rep_install_talend>/Runtime_ESBSE Copier le r\u00e9pertoire container et le renommer en alternate-container . Nous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans alternate-container ) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela: Lancer l\u2019ESB : dans le r\u00e9pertoire alternate-container que vous venez de cr\u00e9er, aller vers bin et ex\u00e9cuter trun.bash (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire alternate-container/bin et lancer dans un terminal la commande ./trun . La fen\u00eatre suivante devrait s\u2019afficher: Attention Le premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante. Configurer l'ESB : dans l\u2019invite de commande affich\u00e9e, taper: source scripts/configureC1.sh Un affichage tel que le suivant va appara\u00eetre: Vous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh. Arr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau. Lancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040. Publier votre Service dans l'ESB et le Tester \u00b6 Revenir au service web SOAP HelloWorldService que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur Talend Open Studio sur le projet Helloworld , et suivre les \u00e9tapes suivantes: Faire un clic-droit sur le service HelloWorldService et choisir Exporter le service . Choisir comme r\u00e9pertoire de destination le dossier deploy se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB). D\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9. V\u00e9rifier que vos services sont actifs: en tapant list dans vos deux instances d\u2019ESB en affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090. Pour tester votre service web: Dans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040 Lancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB. V\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci: Cr\u00e9ation des Routes \u00b6 Les routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires. Premi\u00e8re Route: Filtrage des Messages \u00b6 Cr\u00e9er une nouvelle route en cliquant-droit sur Routes -> Cr\u00e9er une Route . Nous allons l\u2019appeler FiltrageRoute. D\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit: Les composants utilis\u00e9s sont: cCXF : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS. MessageRouter : route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es. Configurer la condition when , en pr\u00e9cisant que c\u2019est une condition de type simple, dont le texte est : \" ${ bodyAs (String) } contains 'Alice'\" Cela veut dire que, si le corps du message contient Alice , la requ\u00eate sera rout\u00e9e vers le composant cCXF_2 . Configurer le composant cCXF_1: Adresse: http://localhost:8042/services/HelloWorldService WSDL: http://localhost:8040/services/HelloWorldService?WSDL . Remarque Remarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB. Configurer l\u2019adresse de cCXF_2 sur le port 8040, et celle de cCXF_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants. Lancer la route pour la tester. La console devra afficher connected . Pour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous? D\u00e9ploiement des Routes sur l'ESB \u00b6 Dans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes: Faites un clic-droit sur votre route et s\u00e9lectionner: Build Route (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9). Choisir le r\u00e9pertoire deploy du conteneur de votre choix. Tester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur. Attention Vous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse. Deuxi\u00e8me Route : Filtrage et Modification de Messages \u00b6 Dans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela: Dans Talend Studio, dupliquer votre route FiltrageRoute et la nommer ModificationRoute . Ins\u00e9rer un composant cSetBody (permettant de modifier le corps du message re\u00e7u) puis un composant cProcessor (permettant de remanier rapidement du code dans la route) entre le cMessageRouter et le cCXF_3 . Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant: Ins\u00e9rer le code suivant (de type Xpath) dans le cSetBody : \"tns:HelloWorldServiceOperationRequest/in\" Ceci permet de saisir le contenu de la balise in de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace tns ( http://www.talend.org/service/ ). Ins\u00e9rer le code suivant dans le processeur: String name = exchange . getIn (). getBody ( String . class ); String surname ; if ( name . contains ( \"Bob\" )){ surname = \"Bobby\" ; } else { surname = \"Chucky\" ; } exchange . getIn (). setBody ( \"<tns:HelloWorldServiceOperationRequest \" + \"xmlns:tns=\\\"http://www.talend.org/service/\\\"><in>\" + surname + \"</in> </tns:HelloWorldServiceOperationRequest>\" ); Ce code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom. Modifier l'adresse du composant cCXF_1 pour qu'il se lance sur le port 8043. Sauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat. Fonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB \u00b6 Failover et R\u00e9partition de Charge \u00b6 Service Locator \u00b6 Via le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs). Configuration du Service Locator \u00b6 Pour activer le service locator (SL), il faut: D\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend Activer la prise en compte du SL au niveau du service cible Configurer le consommateur du service pour prendre en compte le SL 1. D\u00e9ploiement du SL dans le contenaire \u00b6 Pour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB: tesb : start-locator Il est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes: 2. Activer SL dans le service \u00b6 Pour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio: Clic-droit sur le service Choisir ESB Runtime Options Cocher la case \"Utiliser le Service Locator\" Il faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9. 3. Activer SL dans le consommateur \u00b6 Au niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case Use Service Locator . Test du Service Locator \u00b6 Pour tester la r\u00e9partition de charges : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat. Pour tester la gestion du failover : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper list , puis chercher l'identifiant du service HelloWorldService . Taper ensuite : stop <id_service> . Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat. Service Monitoring \u00b6 Le composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes. Pour configurer le Service Activity Monitoring: D\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper : tesb : start-sam Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services. Activer la prise en compte de SAM au niveau du service cible Configurer le consommateur du service pour prendre en compte le SAM Pour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que Db Visualizer . Pour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants: Database connection configuration (Default) : Derby/JavaDB Driver : JavaDB/Derby Server Database Server : localhost Database Port : 1527 Database : DB DB username : test DB password : test Ex\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat. Authentification \u00b6 Security Token Service (STS) : Impl\u00e9mentation du WS-Trust \u00b6 Dans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust. \"Trust\" veut dire \"Confiance\" : le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur. Pour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service. Le STS ( Security Token Service ) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes: D\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s. V\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification Renouveler un jeton de s\u00e9curit\u00e9 Annuler un jeton de s\u00e9curit\u00e9 Transformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent. L\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames. Configuration des Param\u00e8tres de S\u00e9curit\u00e9 \u00b6 Pour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes: D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur Activer la prise en compte de STS dans votre service Configurer votre client pour saisir les param\u00e8tres d\u2019authentification. 1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution \u00b6 Pour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal: feature : install tesb-sts Si le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande : list . Vous devriez trouver les lignes suivantes: 2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur \u00b6 Comme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame. Pour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier: <conteneur>/etc/users.properties . Dans ce fichier, les informations d'authentification sont sous la forme: user=password,group . Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe admin . 3. Activer STS dans votre service \u00b6 Pour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans ESB Runtime Options , cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas, Identifiant/Mot de passe ) 4. Configurer le client \u00b6 Pour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.","title":"TP3 - Mise en Place d\u2019un ESB avec Talend ESB"},{"location":"tp3/#tp3-mise-en-place-dun-esb-avec-talend-esb","text":"","title":"TP3 - Mise en Place d\u2019un ESB avec Talend ESB"},{"location":"tp3/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp3/#objectifs-du-tp","text":"Routage, m\u00e9diation et transformation avec Talend ESB. Gestion du failover et r\u00e9partition de charges, monitoring et authentification avec Talend ESB.","title":"Objectifs du TP"},{"location":"tp3/#outils-et-versions","text":"Talend Open Studio for ESB Version: 6.3.0 DB Visualizer Version 10.0 Java Version 1.8.0_121","title":"Outils et Versions"},{"location":"tp3/#configuration-et-utilisation-de-lesb-talend","text":"","title":"Configuration et Utilisation de l'ESB Talend"},{"location":"tp3/#lancement-de-deux-instances-de-lesb-talend","text":"Pour les besoins de notre TP, nous allons lancer deux instances de l\u2019ESB Talend. Pour cela, l\u2019environnement nous fournit une mani\u00e8re tr\u00e8s simple de le faire: Aller dans le r\u00e9pertoire <rep_install_talend>/Runtime_ESBSE Copier le r\u00e9pertoire container et le renommer en alternate-container . Nous allons maintenant configurer la deuxi\u00e8me instance de l\u2019ESB (dans alternate-container ) pour qu\u2019elle se lance sur un port diff\u00e9rent de la premi\u00e8re. Pour cela: Lancer l\u2019ESB : dans le r\u00e9pertoire alternate-container que vous venez de cr\u00e9er, aller vers bin et ex\u00e9cuter trun.bash (sur windows). Si vous \u00eates sur Linux ou mac, placez-vous sous le r\u00e9pertoire alternate-container/bin et lancer dans un terminal la commande ./trun . La fen\u00eatre suivante devrait s\u2019afficher: Attention Le premier contenaire ne doit pas \u00eatre en ex\u00e9cution, sinon il y'aura un conflit d'adresses. Il faut d'abord configurer le second contenaire pour qu'il se lance sur un port diff\u00e9rent, ce que nous allons faire dans l'\u00e9tape suivante. Configurer l'ESB : dans l\u2019invite de commande affich\u00e9e, taper: source scripts/configureC1.sh Un affichage tel que le suivant va appara\u00eetre: Vous avez ainsi cr\u00e9\u00e9 un ESB, que vous avez configur\u00e9 pour se lancer sur le port 8041, alors que, par d\u00e9faut, il devrait se lancer sur le port 8040. Si vous voulez cr\u00e9er une troisi\u00e8me instance, vous pouvez la configurer en utilisant le fichier configureC2.sh, de m\u00eame pour une quatri\u00e8me instance\u2026 Pour revenir \u00e0 la configuration par d\u00e9faut, utiliser configureC0.sh. Arr\u00eatez votre ESB, en cliquant sur ctrl-d, et relancez-le de nouveau. Lancez dans un autre terminal l\u2019instance de l\u2019ESB se trouvant sous le r\u00e9pertoire d\u2019origine container. Il est inutile de la configurer, elle se lancera par d\u00e9faut sur le port 8040.","title":"Lancement de deux instances de l'ESB Talend"},{"location":"tp3/#publier-votre-service-dans-lesb-et-le-tester","text":"Revenir au service web SOAP HelloWorldService que vous avez cr\u00e9\u00e9 dans le TP1, et le publier sur l'ESB. Pour cela, ouvrir l'\u00e9diteur Talend Open Studio sur le projet Helloworld , et suivre les \u00e9tapes suivantes: Faire un clic-droit sur le service HelloWorldService et choisir Exporter le service . Choisir comme r\u00e9pertoire de destination le dossier deploy se trouvant dans le conteneur o\u00f9 vous d\u00e9sirez d\u00e9ployer le service. Un fichier archive de type kar sera alors cr\u00e9\u00e9 sous ce r\u00e9pertoire, permettant ainsi son d\u00e9ploiement \u00e0 chaud (pas besoin de red\u00e9marrer l\u2019ESB). D\u00e9ployer votre service sur les deux instances d\u2019ESB que vous avez d\u00e9marr\u00e9. V\u00e9rifier que vos services sont actifs: en tapant list dans vos deux instances d\u2019ESB en affichant les fichiers WSDL du service sur les ports 8040 et 8041 au lieu de 8090. Pour tester votre service web: Dans le job consommateur de service, dans les propri\u00e9t\u00e9s du composant tESBConsumer, modifier le port du endpoint de 8090 \u00e0 8040 Lancer votre job. V\u00e9rifier que l\u2019affichage se fait correctement sur la console du TOS-ESB. V\u00e9rifier que votre service s\u2019ex\u00e9cute bien sur l\u2019ESB principal, en consultant le terminal o\u00f9 il est d\u00e9marr\u00e9. Vous devriez trouver un affichage semblable \u00e0 celui-ci:","title":"Publier votre Service dans l'ESB et le Tester"},{"location":"tp3/#creation-des-routes","text":"Les routes permettent de d\u00e9finir le comportement que doit prendre le message selon son contenu. Dans notre exemple, nous allons d\u00e9finir deux types de routes: une route permettant de filtrer les messages par contenu, en envoyant les messages contenant le nom \u201cAlice\u201d vers un ESB, et le reste vers l\u2019autre ESB. Une deuxi\u00e8me route permettra de modifier le contenu de certains messages avant de les faire parvenir \u00e0 leurs destinataires.","title":"Cr\u00e9ation des Routes"},{"location":"tp3/#premiere-route-filtrage-des-messages","text":"Cr\u00e9er une nouvelle route en cliquant-droit sur Routes -> Cr\u00e9er une Route . Nous allons l\u2019appeler FiltrageRoute. D\u00e9finir votre route de mani\u00e8re \u00e0 ce qu\u2019elle ressemble \u00e0 ce qui suit: Les composants utilis\u00e9s sont: cCXF : fournit l'int\u00e9gration avec Apache CXF pour la connexion aux services JAX-WS. MessageRouter : route des messages dans diff\u00e9rents canaux selon des conditions sp\u00e9cifi\u00e9es. Configurer la condition when , en pr\u00e9cisant que c\u2019est une condition de type simple, dont le texte est : \" ${ bodyAs (String) } contains 'Alice'\" Cela veut dire que, si le corps du message contient Alice , la requ\u00eate sera rout\u00e9e vers le composant cCXF_2 . Configurer le composant cCXF_1: Adresse: http://localhost:8042/services/HelloWorldService WSDL: http://localhost:8040/services/HelloWorldService?WSDL . Remarque Remarquez ici que le port utilis\u00e9 pour l'adresse est 8042: c'est le port choisi pour le service fa\u00e7ade fourni par la route. Le WSDL utilis\u00e9, par contre, est celui du service initial, expos\u00e9 sur le port 8040, donc sur le premier ESB. Configurer l\u2019adresse de cCXF_2 sur le port 8040, et celle de cCXF_3 sur le port 8041, tout en gardant le m\u00eame WSDL pour les trois composants. Lancer la route pour la tester. La console devra afficher connected . Pour utiliser cette route, vous devez reconfigurer votre consommateur pour qu\u2019il lance sa requ\u00eate sur le port 8042. Ex\u00e9cutez-le et observez le r\u00e9sultat sur les terminaux des deux instances d\u2019ESB d\u00e9marr\u00e9es. Que constatez-vous?","title":"Premi\u00e8re Route: Filtrage des Messages"},{"location":"tp3/#deploiement-des-routes-sur-lesb","text":"Dans leur \u00e9tat actuel, vos routes doivent \u00eatre lanc\u00e9es manuellement pour \u00eatre prises en consid\u00e9ration. Pour les d\u00e9ployer sur votre ESB et les garder ainsi toujours actives, suivre les \u00e9tapes suivantes: Faites un clic-droit sur votre route et s\u00e9lectionner: Build Route (veillez \u00e0 ce que le job FiltrageRoute soit bien arr\u00eat\u00e9). Choisir le r\u00e9pertoire deploy du conteneur de votre choix. Tester votre route en ex\u00e9cutant \u00e0 nouveau le consommateur. Attention Vous ne devez en aucun cas d\u00e9ployer votre route sur deux contenaires, sinon, il y'aura un conflit, car deux services fa\u00e7ades seront expos\u00e9s, ayant la m\u00eame adresse.","title":"D\u00e9ploiement des Routes sur l'ESB"},{"location":"tp3/#deuxieme-route-filtrage-et-modification-de-messages","text":"Dans cette nouvelle partie, nous allons modifier le corps du message apr\u00e8s l\u2019avoir filtr\u00e9. Pour cela: Dans Talend Studio, dupliquer votre route FiltrageRoute et la nommer ModificationRoute . Ins\u00e9rer un composant cSetBody (permettant de modifier le corps du message re\u00e7u) puis un composant cProcessor (permettant de remanier rapidement du code dans la route) entre le cMessageRouter et le cCXF_3 . Le but ici est de modifier le corps des messages re\u00e7us, selon leur contenu. Le r\u00e9sultat obtenu ressemblera au suivant: Ins\u00e9rer le code suivant (de type Xpath) dans le cSetBody : \"tns:HelloWorldServiceOperationRequest/in\" Ceci permet de saisir le contenu de la balise in de la requ\u00eate SOAP envoy\u00e9e par le consommateur. Il ne faut pas oublier de d\u00e9finir le Namespace tns ( http://www.talend.org/service/ ). Ins\u00e9rer le code suivant dans le processeur: String name = exchange . getIn (). getBody ( String . class ); String surname ; if ( name . contains ( \"Bob\" )){ surname = \"Bobby\" ; } else { surname = \"Chucky\" ; } exchange . getIn (). setBody ( \"<tns:HelloWorldServiceOperationRequest \" + \"xmlns:tns=\\\"http://www.talend.org/service/\\\"><in>\" + surname + \"</in> </tns:HelloWorldServiceOperationRequest>\" ); Ce code permet de modifier le corps du message entrant en rempla\u00e7ant le nom par un surnom. Modifier l'adresse du composant cCXF_1 pour qu'il se lance sur le port 8043. Sauvegarder et exporter votre route dans l\u2019ESB. Lancer le consommateur de nouveau et observez le r\u00e9sultat.","title":"Deuxi\u00e8me Route : Filtrage et Modification de Messages"},{"location":"tp3/#fonctionnalites-supplementaires-de-lesb","text":"","title":"Fonctionnalit\u00e9s Suppl\u00e9mentaires de l'ESB"},{"location":"tp3/#failover-et-repartition-de-charge","text":"","title":"Failover et R\u00e9partition de Charge"},{"location":"tp3/#service-locator","text":"Via le Service Locator, l'ESB de Talend fournit des fonctionnalit\u00e9s de gestion de failover automatique et transparente ainsi que de r\u00e9partition de charge via le lookup et l'enregistrement d'endpoints dynamiques dans Apache Zookeeper. Le Service Locator maintient la disponibilit\u00e9 du service afin de r\u00e9pondre aux demandes et aux Service Level Agreements (SLAs).","title":"Service Locator"},{"location":"tp3/#configuration-du-service-locator","text":"Pour activer le service locator (SL), il faut: D\u00e9ployer SL au niveau des conteneurs d\u2019ex\u00e9cution Talend Activer la prise en compte du SL au niveau du service cible Configurer le consommateur du service pour prendre en compte le SL","title":"Configuration du Service Locator"},{"location":"tp3/#1-deploiement-du-sl-dans-le-contenaire","text":"Pour tester sa capacit\u00e9 \u00e0 g\u00e9rer le failover et la r\u00e9partition des charges, le SL doit \u00eatre d\u00e9ploy\u00e9 dans les diff\u00e9rents conteneurs de services o\u00f9 sera d\u00e9ploy\u00e9 votre service. Pour cela, taper dans l\u2019invite de commande de chaque conteneur ESB: tesb : start-locator Il est possible de visualiser votre SL dans la liste des services d\u00e9ploy\u00e9s sur le conteneur en tapant list sur votre terminal. Vous devriez trouver les lignes suivantes:","title":"1. D\u00e9ploiement du SL dans le contenaire"},{"location":"tp3/#2-activer-sl-dans-le-service","text":"Pour activer la prise en compte de SL au niveau de notre service utilisateur dans Talend Studio: Clic-droit sur le service Choisir ESB Runtime Options Cocher la case \"Utiliser le Service Locator\" Il faut veiller \u00e0 re-d\u00e9ployer votre service dans les deux conteneurs apr\u00e8s l\u2019activation de la fonctionnalit\u00e9.","title":"2. Activer SL dans le service"},{"location":"tp3/#3-activer-sl-dans-le-consommateur","text":"Au niveau du consommateur du service, dans les propri\u00e9t\u00e9s du composant tESB, cocher la case Use Service Locator .","title":"3. Activer SL dans le consommateur"},{"location":"tp3/#test-du-service-locator","text":"Pour tester la r\u00e9partition de charges : Lancer le consommateur plusieurs fois sur le port 8040 et observez le r\u00e9sultat. Pour tester la gestion du failover : Arr\u00eater le service sur le contenaire principal (8040). Pour cela, dans l'invite de commande du contenaire principal, taper list , puis chercher l'identifiant du service HelloWorldService . Taper ensuite : stop <id_service> . Lancer le consommateur sur le endpoint 8040, et observez le r\u00e9sultat.","title":"Test du Service Locator"},{"location":"tp3/#service-monitoring","text":"Le composant SAM permet le logging et la surveillance des appels de service, r\u00e9alis\u00e9s avec le framework Apache CXF. Il peut \u00eatre utilis\u00e9 pour collecter, par exemple, les statistiques d\u2019usage et le monitoring des fautes. Pour configurer le Service Activity Monitoring: D\u00e9ployer SAM au niveau du conteneur d\u2019ex\u00e9cution Talend. Pour cela, taper : tesb : start-sam Vous remarquerez qu\u2019une base de donn\u00e9es Derby sera \u00e9galement d\u00e9ploy\u00e9e sur le conteneur: elle permet de stocker les informations sur l\u2019activit\u00e9 des services. Activer la prise en compte de SAM au niveau du service cible Configurer le consommateur du service pour prendre en compte le SAM Pour visualiser le r\u00e9sultat de la surveillance, utiliser un visualiseur de bases de donn\u00e9es, tel que Db Visualizer . Pour acc\u00e9der \u00e0 la base de donn\u00e9es de monitoring, utiliser les param\u00e8tres de configuration suivants: Database connection configuration (Default) : Derby/JavaDB Driver : JavaDB/Derby Server Database Server : localhost Database Port : 1527 Database : DB DB username : test DB password : test Ex\u00e9cuter votre service plusieurs fois, et observer le r\u00e9sultat.","title":"Service Monitoring"},{"location":"tp3/#authentification","text":"","title":"Authentification"},{"location":"tp3/#security-token-service-sts-implementation-du-ws-trust","text":"Dans un environnement h\u00e9t\u00e9rog\u00e8ne, les services web doivent authentifier les services clients pour contr\u00f4ler leur acc\u00e8s, gr\u00e2ce \u00e0 la norme WS-Security, et en impl\u00e9mentant le WS-Trust. \"Trust\" veut dire \"Confiance\" : le but ici est donc d\u2019\u00e9tablir un lien de confiance entre le consommateur et le fournisseur. Pour cela, un courtier d\u2019authentification est utilis\u00e9, fournissant un contr\u00f4le d\u2019acc\u00e8s pour les applications. Ce courtier d\u00e9livre des jetons de s\u00e9curit\u00e9 utilis\u00e9s par les clients pour s\u2019authentifier au service. Le STS ( Security Token Service ) est un service web qui fournit un tel courtier d\u2019authentification. Ses jetons respectent le standard WS-Trust. Il offre les fonctionnalit\u00e9s suivantes: D\u00e9livrer un jeton de s\u00e9curit\u00e9 bas\u00e9 sur des param\u00e8tres d\u2019authentification configur\u00e9s. V\u00e9rifier la validit\u00e9 d\u2019un param\u00e8tre d\u2019authentification Renouveler un jeton de s\u00e9curit\u00e9 Annuler un jeton de s\u00e9curit\u00e9 Transformer un jeton de s\u00e9curit\u00e9 donn\u00e9 en un autre de type diff\u00e9rent. L\u2019utilisation d\u2019un STS simplifie grandement la gestion de la s\u00e9curit\u00e9 pour le service et le client, car ils n\u2019ont qu\u2019\u00e0 faire appel \u00e0 ce STS, qui va g\u00e9rer la logique de s\u00e9curit\u00e9, au lieu de la traiter eux-m\u00eames.","title":"Security Token Service (STS) : Impl\u00e9mentation du WS-Trust"},{"location":"tp3/#configuration-des-parametres-de-securite","text":"Pour associer des param\u00e8tres de confidentialit\u00e9 \u00e0 un service, il faut suivre les \u00e9tapes suivantes: D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution Talend Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur Activer la prise en compte de STS dans votre service Configurer votre client pour saisir les param\u00e8tres d\u2019authentification.","title":"Configuration des Param\u00e8tres de S\u00e9curit\u00e9"},{"location":"tp3/#1-deployer-sts-dans-le-conteneur-dexecution","text":"Pour installer le service STS dans votre conteneur, d\u00e9marrer ce dernier, et taper l\u2019instruction suivante dans le terminal: feature : install tesb-sts Si le service a bien \u00e9t\u00e9 install\u00e9, vous pouvez v\u00e9rifier qu\u2019il est bien d\u00e9marr\u00e9 en ex\u00e9cutant la commande : list . Vous devriez trouver les lignes suivantes:","title":"1. D\u00e9ployer STS dans le conteneur d\u2019ex\u00e9cution"},{"location":"tp3/#2-configurer-les-parametres-de-securite-de-votre-conteneur","text":"Comme c\u2019est le STS qui prend en charge le contr\u00f4le d\u2019acc\u00e8s, les param\u00e8tres d\u2019authentification (le login/mdp par exemple) ne sont pas configur\u00e9s au niveau du service fournisseur, mais au niveau du conteneur lui-m\u00eame. Pour visualiser l\u2019ensemble des utilisateurs autoris\u00e9s sur votre conteneur, voir leurs mots de passes et r\u00f4les, et \u00e9ventuellement en ajouter de nouveaux, ouvrir le fichier: <conteneur>/etc/users.properties . Dans ce fichier, les informations d'authentification sont sous la forme: user=password,group . Ajouter une nouvelle ligne avec votre nom comme user et un mot de passe de votre choix, et choisir le groupe admin .","title":"2. Configurer les param\u00e8tres de s\u00e9curit\u00e9 de votre conteneur"},{"location":"tp3/#3-activer-sts-dans-votre-service","text":"Pour activer la prise en compte de STS au niveau de notre service utilisateur dans Talend Studio, dans ESB Runtime Options , cocher le type d\u2019authentification d\u00e9sir\u00e9 (dans notre cas, Identifiant/Mot de passe )","title":"3. Activer STS dans votre service"},{"location":"tp3/#4-configurer-le-client","text":"Pour ins\u00e9rer le login/mdp dans votre application cliente, modifier les param\u00e8tres d\u2019authentification de votre composant tESBConsumer dans votre job consommateur.","title":"4. Configurer le client"},{"location":"tp4/","text":"TP4 - Microservices avec Spring Boot et Spring Cloud \u00b6 T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 Cr\u00e9ation de microservices avec Spring Boot et Spring Cloud D\u00e9ploiement d'un microservices sur plusieurs instances Acknowledgement \u00b6 Ce TP a \u00e9t\u00e9 largement inspir\u00e9 du travail d'un bin\u00f4me d'\u00e9tudiants en G\u00e9nie Logiciel \u00e0 l'INSAT, promotion 2017 (Houssem Ben Braiek et Hadhemi Jabnoun), que je tiens \u00e0 f\u00e9liciter et remercier. Outils et Versions \u00b6 Spring Boot Version: 1.5.8 Spring Cloud Version 1.2.4 Java Version 1.8.0_121 Maven Version 3.5.2 IntelliJ IDEA Version Ultimate 2016.1 (ou tout autre IDE de votre choix) Architecture Microservices \u00b6 Pr\u00e9sentation \u00b6 Une architecture Microservices repr\u00e9sente un moyen de concevoir les applications comme ensemble de services ind\u00e9pendamment d\u00e9ployables. Ces services doivent de pr\u00e9f\u00e9rence \u00eatre organis\u00e9s autours des comp\u00e9tences m\u00e9tier, de d\u00e9ploiement automatique, d'extr\u00e9mit\u00e9s intelligentes et de contr\u00f4le d\u00e9centralis\u00e9 des technologies et des donn\u00e9es. Architecture Propos\u00e9e \u00b6 L'objectif de ce travail est de montrer comment cr\u00e9er plusieurs services ind\u00e9pendamment d\u00e9ployables qui communiquent entre eux, en utilisant les facilit\u00e9s offertes par Spring Cloud et Spring Boot. Spring Cloud fournit des outils pour les d\u00e9veloppeurs pour construire rapidement et facilement des patrons communs de syst\u00e8mes r\u00e9partis (tel que des services de configuration, de d\u00e9couverte ou de routage intelligent). Spring Boot permet de son c\u00f4t\u00e9 de construire des applications Spring rapidement aussi rapidement que possible, en minimisant au maximum le temps de configuration, d'habitude p\u00e9nible, des applications Spring. Nous allons donc cr\u00e9er les microservices suivants: Product Service : Service principal, qui offre une API REST pour lister une liste de produits. Config Service : Service de configuration, dont le r\u00f4le est de centraliser les fichiers de configuration des diff\u00e9rents microservices dans un endroit unique. Proxy Service : Passerelle se chargeant du routage d'une requ\u00eate vers l'une des instances d'un service, de mani\u00e8re \u00e0 g\u00e9rer automatiquement la distribution de charge. Discovery Service : Service permettant l'enregistrement des instances de services en vue d'\u00eatre d\u00e9couvertes par d'autres services. L'architecture r\u00e9sultante aura l'allure suivante: Cr\u00e9ation des Microservices \u00b6 Microservice ProductService \u00b6 Nous commen\u00e7ons par cr\u00e9er le service principal: Product Service . Chaque microservice sera sous forme d'un projet Spring. Pour cr\u00e9er rapidement et facilement un projet Spring avec toutes les d\u00e9pendances n\u00e9cessaires, Spring Boot fournit Spring Initializr . Pour cela, aller au site start.spring.io , et cr\u00e9er un projet avec les caract\u00e9ristiques suivantes: Projet Maven avec Java et Spring Boot version 1.5.8 Group: tn.insat.tpmicro Artifact: product-service D\u00e9pendances: Web Rest Repositories JPA : Java Persistence API H2 : base de donn\u00e9es pour le stockage Actuator : pour le montoring et la gestion de l'application Eureka Discovery : pour l'int\u00e9gration avec le Discovery Service Config Client : pour l'int\u00e9gration avec le Config Service Suivre ensuite les \u00e9tapes suivantes pour cr\u00e9er le microservice ProductService : Ouvrir le projet t\u00e9l\u00e9charg\u00e9 avec IntelliJ IDEA. Sous le r\u00e9pertoire src/main/java et dans le package tn.insat.tpmicro.productservice , cr\u00e9er la classe Product suivante: package tn.insat.tpmicro.productservice ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.Id ; import java.io.Serializable ; @Entity public class Product implements Serializable { @Id @GeneratedValue private int id ; private String name ; public Product (){ } public Product ( String name ) { this . name = name ; } public int getId () { return id ; } public void setId ( int id ) { this . id = id ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } } Cette classe est annot\u00e9e avec JPA, pour stocker ensuite les objets Product dans la base de donn\u00e9es H2 gr\u00e2ce \u00e0 Spring Data. Pour cela, cr\u00e9er l'interface ProductRepository dans le m\u00eame package: package tn.insat.tpmicro.productservice ; import org.springframework.data.jpa.repository.JpaRepository ; public interface ProductRepository extends JpaRepository < Product , Integer > { } Pour ins\u00e9rer les objets dans la base, nous utiliserons l'objet Stream . Pour cela, nous allons cr\u00e9er la classe DummyDataCLR : package tn.insat.tpmicro.productservice ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.CommandLineRunner ; import org.springframework.stereotype.Component ; import java.util.stream.Stream ; @Component class DummyDataCLR implements CommandLineRunner { @Override public void run ( String ... strings ) throws Exception { Stream . of ( \"Pencil\" , \"Book\" , \"Eraser\" ). forEach ( s -> productRepository . save ( new Product ( s ))); productRepository . findAll (). forEach ( s -> System . out . println ( s . getName ())); } @Autowired private ProductRepository productRepository ; } Nous remarquons ici que le productRepository sera instanci\u00e9 automatiquement gr\u00e2ce au m\u00e9canisme d'injection de d\u00e9pendances, utilis\u00e9 par Spring. Lancer la classe principale. Une base de donn\u00e9es H2 sera cr\u00e9\u00e9e et le CommandLineRunner se chargera de lui injecter les donn\u00e9es. Attention Prenez soin d'utiliser JDK 8! Pour ex\u00e9cuter votre application: Cr\u00e9er une configuration mvn package en faisant Run->Edit Configurations puis en cr\u00e9ant une nouvelle configuration de type Maven avec la commande package comme suit: Un r\u00e9pertoire target sera cr\u00e9\u00e9, contenant les classes g\u00e9n\u00e9r\u00e9es. Lancer ensuite la configuration Spring Boot ProductServiceApplication cr\u00e9\u00e9e par d\u00e9faut par IntelliJ. Le r\u00e9sultat sur la console devrait ressembler \u00e0 ce qui suit: Tip Pour \u00e9viter de lancer \u00e0 chaque fois les deux configurations, ajouter dans la deuxi\u00e8me configuration une d\u00e9pendance vers la premi\u00e8re, rajouter cette derni\u00e8re dans la case Before Launch: Build, Maven Goal, Activate Tool Window , comme suit: Pour tester votre application, ouvrir la page http://localhost:8080 sur le navigateur. Vous obtiendrez (si tout se passe bien) le r\u00e9sultat suivant: Vous remarquerez que le service REST cr\u00e9\u00e9 respecte automatiquement la norme HATEOAS , qui offre dans les services REST, les liens pour naviguer dynamiquement entre les interfaces. Si vous naviguez vers la page http://localhost:8080/products , vous verrez la liste des produits, inject\u00e9s par le CLR, comme suit: Pour voir les informations relatives \u00e0 un seul produit, il suffit de conna\u00eetre son ID: http://localhost:8080/products/1 , par exemple. Pour rajouter une fonctionnalit\u00e9 de recherche par nom, par exemple, modifier l'interface ProductRepository , comme suit: package tn.insat.tpmicro.productservice ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.jpa.repository.JpaRepository ; import org.springframework.data.jpa.repository.Query ; import org.springframework.data.repository.query.Param ; import org.springframework.data.rest.core.annotation.RepositoryRestResource ; @RepositoryRestResource public interface ProductRepository extends JpaRepository < Product , Integer > { @Query ( \"select p from Product p where p.name like :name\" ) public Page < Product > productByName ( @Param ( \"name\" ) String mc , Pageable pageable ); } Pour tester cette fonctionnalit\u00e9 de recherche, aller au lien http://localhost:8080/products/search/productByName?name=Eraser Le r\u00e9sultat obtenu sera le suivant: La d\u00e9pendance Actuator qui a \u00e9t\u00e9 rajout\u00e9e au projet permet d'afficher des informations sur votre API REST sans avoir \u00e0 impl\u00e9menter explicitement la fonctionnalit\u00e9. Par exemple, si vous allez vers http://localhost:8080/metrics , vous pourrez avoir plusieurs informations sur le microservice, tel que le nombre de threads, la capacit\u00e9 m\u00e9moire, la classe charg\u00e9e en m\u00e9moire, etc. Mais d'abord, rajouter les deux lignes suivantes au fichier src/main/resources/application.properties pour (1) afficher des informations plus d\u00e9taill\u00e9es sur l'\u00e9tat du service et (2) d\u00e9sactiver les contraintes de s\u00e9curit\u00e9 par d\u00e9faut: endpoints.health.sensitive = false management.security.enabled = false Relancer le projet. Le r\u00e9sultat obtenu en ex\u00e9cutant http://localhost:8080/metrics sera comme suit: Les informations sur l'\u00e9tat du service sont affich\u00e9es gr\u00e2ce \u00e0 http://localhost:8080/health Plusieurs Instances du Microservice ProductService \u00b6 Nous allons maintenant cr\u00e9er d'autres instances du m\u00eame service et les d\u00e9ployer sur des ports diff\u00e9rents. Pour lancer plusieurs instances du service ProductService , nous allons d\u00e9finir plusieurs configurations avec des num\u00e9ros de port diff\u00e9rents. Pour cela: Aller \u00e0 Run->Edit Configurations , et copier la configuration ProductServiceApplication en la s\u00e9lectionnant dans la barre lat\u00e9rale, et en cliquant sur l'ic\u00f4ne . Une nouvelle configuration sera cr\u00e9\u00e9e. Changer son nom: ProductServiceApplication:8081 Ajouter dans la case Program Arguments l'argument suivant: --server.port = 8081 Lancer la configuration. Un nouveau service sera disponible \u00e0 l'adresse: http://localhost:8081 Tip En ex\u00e9cutant la seconde configuration, un popup s'affiche dans IntelliJ, qui vous demande si vous voulez afficher le dashboard pour visualiser plusieurs instances Spring Boot, comme suit: Cliquer dessus, et choisir : Show Run Configurations in Dashboard . La vue suivante s'affiche, en bas de votre \u00e9cran: Vous pouvez d\u00e9sormais g\u00e9rer vos instances dans cette fen\u00eatre. Refaire les m\u00eames \u00e9tapes pour cr\u00e9er une instance du service tourant sur le port 8082. Microservice ConfigService \u00b6 Dans une architecture microservices, plusieurs services s'ex\u00e9cutent en m\u00eame temps, sur des processus diff\u00e9rents, avec chacun sa propre configuration et ses propres param\u00e8tres. Spring Cloud Config fournit un support c\u00f4t\u00e9 serveur et c\u00f4t\u00e9 client pour externaliser les configurations dans un syst\u00e8me distribu\u00e9. Gr\u00e2ce au service de configuration, il est possible d'avoir un endroit centralis\u00e9 pour g\u00e9rer les propri\u00e9t\u00e9s de chacun de ces services. Pour cela: Commencer par cr\u00e9er un service ConfigService dans Spring Initializr , avec les d\u00e9pendances appropri\u00e9es, comme indiqu\u00e9 sur la figure suivante: Ouvrir le projet dans une autre instance d'IntelliJ IDEA. Pour exposer un service de configuration, utiliser l'annotation @EnableConfigServer pour la classe ConfigServiceApplication , comme suit: package tn.insat.tpmicro.configservice ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.config.server.EnableConfigServer ; @EnableConfigServer @SpringBootApplication public class ConfigServiceApplication { public static void main ( String [] args ) { SpringApplication . run ( ConfigServiceApplication . class , args ); } } Pour param\u00e9trer ce service de configuration, ajouter dans son fichier application.properties les valeurs suivantes: server.port = 8888 spring.cloud.config.server.git.uri = file:./src/main/resources/myConfig Ceci indique que le service de configuration sera lanc\u00e9 sur le port 8888 et que le r\u00e9pertoire contenant les fichiers de configuration se trouve dans le r\u00e9pertoire src/main/resources/myConfig . Il suffit maintenant de cr\u00e9er ce r\u00e9pertoire. Tip Pour pouvoir r\u00e9f\u00e9rencer un r\u00e9pertoire avec son chemin absolu, utiliser plut\u00f4t file:///<chemin_absolu> . Cr\u00e9er le r\u00e9pertoire myConfig \u00e0 l'arborescence src/main/resources Cr\u00e9er dans ce r\u00e9pertoire le fichier application.properties dans lequel vous ins\u00e9rez l'instruction suivante: global = xxxxx Ce fichier sera partag\u00e9 entre tous les microservices utilisant ce service de configuration. Le r\u00e9pertoire de configuration doit \u00eatre un r\u00e9pertoire git. Pour cela: Ouvrir le terminal avec IntelliJ et naviguer vers ce r\u00e9pertoire. Initialiser votre r\u00e9pertoire: git init Cr\u00e9er une entr\u00e9e racine dans le repository: git add . Faire un commit: git commit -m \"add .\" Revenir vers le projet ProductService et ajouter dans le fichier de configuration application.properties : spring.application.name = product-service spring.cloud.config.uri = http://localhost:8888 Red\u00e9marrer vos services. Pour consulter le service de configuration, aller \u00e0 http://localhost:8888/product-service/master . Vous verrez le fichier JSON suivant: { name : \"product-service\" , profiles : [ \"master\" ], label : null , version : \"6e1ea61d706133e2d8b62f40c6b784192fb58e8a\" , state : null , propertySources : [ { name : \"file:./src/main/resources/myConfig/application.properties\" , source : { global : \"xxxxx\" } } ] } Comme le fichier application.properties contient toutes les propri\u00e9t\u00e9s partag\u00e9es des diff\u00e9rents microservices, nous aurons besoins d'autres fichiers pour les propri\u00e9t\u00e9s sp\u00e9cifiques \u00e0 un microservice. Pour cela: Cr\u00e9er dans le r\u00e9pertoire myConfig un fichier product-service.properties pour le service ProductService . Attention Le nom du fichier doit correspondre \u00e0 la propri\u00e9t\u00e9 spring.application.name que vous avez saisi dans le fichier application.properties de votre microservice! Ajouter les propri\u00e9t\u00e9s de votre service, \u00e0 savoir, par exemple: me = lilia.sfaxi@insat.rnu.tn Relancer le microservice de configuration. En consultant l'url http://localhost:8888/product-service/master , nous remarquons l'ajout de la nouvelle propri\u00e9t\u00e9. { name : \"product-service\" , profiles : [ \"master\" ], label : null , version : \"6e1ea61d706133e2d8b62f40c6b784192fb58e8a\" , state : null , propertySources : [ { name : \"file:./src/main/resources/myConfig/product-service.properties\" , source : { me : \"lilia.sfaxi@insat.rnu.tn\" } }, { name : \"file:./src/main/resources/myConfig/application.properties\" , source : { global : \"xxxxx\" } } ] } Nous allons maintenant d\u00e9finir un appel REST \u00e0 cette propri\u00e9t\u00e9. Pour cela: Cr\u00e9er la classe ProductRestService dans le projet product-service . Son code ressemblera \u00e0 ce qui suit: package tn.insat.tpmicro.productservice ; import org.springframework.beans.factory.annotation.Value ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RestController ; @RestController public class ProductRestService { @Value ( \"${me}\" ) private String me ; @RequestMapping ( \"/messages\" ) public String tellMe (){ System . out . println ( \"c'est moi qui ai r\u00e9pondu!\" ); return me ; } } Red\u00e9marrer les trois instances du service, puis appeler dans votre navigateur le service en tapant: http://localhost:8080/messages . Vous verrez le r\u00e9sultat suivant sur le navigateur: Consulter votre Spring Dashboard, vous verrez le message suivant dans la console de l'instance du service lanc\u00e9e sur le port 8080: Microservice DiscoveryService \u00b6 Pour \u00e9viter un couplage fort entre microservices, il est fortement recommand\u00e9 d'utiliser un service de d\u00e9couverte qui permet d'enregistrer les propri\u00e9t\u00e9s des diff\u00e9rents services et d'\u00e9viter ainsi d'avoir \u00e0 appeler un service directement. Au lieu de cela, le service de d\u00e9couverte fournira dynamiquement les informations n\u00e9cessaires, ce qui permet d'assurer l'\u00e9lasticit\u00e9 et la dynamicit\u00e9 propres \u00e0 une architecture microservices. Pour r\u00e9aliser cela, Netflix offre le service Eureka Service Registration and Discovery , que nous allons utiliser dans notre application. Revenir \u00e0 Spring Initializr et cr\u00e9er un nouveau projet Spring Boot intitul\u00e9 discovery-service avec les d\u00e9pendances Eureka Server et Config Client . Lancer le projet avec IntelliJ. Dans la classe DiscoveryServiceApplication , ajouter l'annotation EnableEurekaServer . package tn.insat.tpmicro.discoveryservice ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer ; @EnableEurekaServer @SpringBootApplication public class DiscoveryServiceApplication { public static void main ( String [] args ) { SpringApplication . run ( DiscoveryServiceApplication . class , args ); } } Ajouter les propri\u00e9t\u00e9s suivantes dans son fichier application.properties . spring.application.name = discovery-service spring.cloud.config.uri = http://localhost:8888 Dans le projet config-service , cr\u00e9er un fichier discovery-service.properties sous le r\u00e9pertoire myConfig . Ajouter les propri\u00e9t\u00e9s suivantes pour (1) d\u00e9finir le port par d\u00e9faut du service de d\u00e9couverte et (2) emp\u00eacher un auto-enregistrement du service Eureka. server.port = 8761 eureka.client.fetch-registry = false eureka.client.register-with-eureka = false Pour consulter le service Eureka, aller \u00e0 http://localhost:8761 , l'interface suivante s'affiche: Nous remarquons qu'aucune instance n'est inscrite dans le serveur de d\u00e9couverte. Nous allons donc modifier le code de la classe ProductServiceApplication pour que le microservice ProductService s'enregistre: package tn.insat.tpmicro.productservice ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.client.discovery.EnableDiscoveryClient ; @EnableDiscoveryClient @SpringBootApplication public class ProductServiceApplication { public static void main ( String [] args ) { SpringApplication . run ( ProductServiceApplication . class , args ); } } Red\u00e9marrer les trois instances de services ProductService et actualiser la fen\u00eatre de Eureka , vous verrez qu'un seul service est d\u00e9clar\u00e9, avec trois adresses diff\u00e9rentes. Microservice ProxyService \u00b6 L'architecture microservices, en fournissant un ensemble de services ind\u00e9pendants et faiblement coupl\u00e9s, se trouve confront\u00e9e au challenge de fournir une interface unifi\u00e9e pour les consommateurs, de mani\u00e8re \u00e0 ce qu'ils ne voient pas la d\u00e9composition \u00e0 faible granularit\u00e9 de vos services. C'est pour cela que l'utilisation d'un service proxy, responsable du routage des requ\u00eates et de la r\u00e9partition de charge, est important. Netflix offre le service Zuul pour r\u00e9aliser cela. Pour cr\u00e9er votre microservice Proxy: Aller \u00e0 Spring Initializr . Cr\u00e9er le projet proxy-service avec les d\u00e9pendances suivantes: Zuul, Web, HATEOAS, Actuator, Config Client et Eureka Discovery. Ouvrir le service avec IntelliJ IDEA. Ajouter \u00e0 la classe ProxyServiceApplication l'annotation @EnableZuulProxy , ainsi que @EnableDiscoveryClient pour que le proxy soit \u00e9galement enregistr\u00e9 dans le service de d\u00e9couverte. Ajouter les propri\u00e9t\u00e9s spring.application.name et spring.cloud.config.uri dans le fichier application.properties du service proxy. Cr\u00e9er le fichier proxy-service.properties dans le r\u00e9pertoire myConfig du service de configuration, dans lequel vous allez fixer le port du service proxy \u00e0 9999. En lan\u00e7ant le service Proxy, vous remarquerez qu'il est rajout\u00e9 dans Eureka. Si vous ex\u00e9cutez la requ\u00eate http://localhost:9999/product-service/messages plusieurs fois, vous remarquerez que l'affichage c'est moi qui ai r\u00e9pondu! s'affichera sur les consoles des trois instances respectivement, \u00e0 tour de r\u00f4le.","title":"TP4 - Microservices avec Spring Boot et Spring Cloud"},{"location":"tp4/#tp4-microservices-avec-spring-boot-et-spring-cloud","text":"","title":"TP4 - Microservices avec Spring Boot et Spring Cloud"},{"location":"tp4/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp4/#objectifs-du-tp","text":"Cr\u00e9ation de microservices avec Spring Boot et Spring Cloud D\u00e9ploiement d'un microservices sur plusieurs instances","title":"Objectifs du TP"},{"location":"tp4/#acknowledgement","text":"Ce TP a \u00e9t\u00e9 largement inspir\u00e9 du travail d'un bin\u00f4me d'\u00e9tudiants en G\u00e9nie Logiciel \u00e0 l'INSAT, promotion 2017 (Houssem Ben Braiek et Hadhemi Jabnoun), que je tiens \u00e0 f\u00e9liciter et remercier.","title":"Acknowledgement"},{"location":"tp4/#outils-et-versions","text":"Spring Boot Version: 1.5.8 Spring Cloud Version 1.2.4 Java Version 1.8.0_121 Maven Version 3.5.2 IntelliJ IDEA Version Ultimate 2016.1 (ou tout autre IDE de votre choix)","title":"Outils et Versions"},{"location":"tp4/#architecture-microservices","text":"","title":"Architecture Microservices"},{"location":"tp4/#presentation","text":"Une architecture Microservices repr\u00e9sente un moyen de concevoir les applications comme ensemble de services ind\u00e9pendamment d\u00e9ployables. Ces services doivent de pr\u00e9f\u00e9rence \u00eatre organis\u00e9s autours des comp\u00e9tences m\u00e9tier, de d\u00e9ploiement automatique, d'extr\u00e9mit\u00e9s intelligentes et de contr\u00f4le d\u00e9centralis\u00e9 des technologies et des donn\u00e9es.","title":"Pr\u00e9sentation"},{"location":"tp4/#architecture-proposee","text":"L'objectif de ce travail est de montrer comment cr\u00e9er plusieurs services ind\u00e9pendamment d\u00e9ployables qui communiquent entre eux, en utilisant les facilit\u00e9s offertes par Spring Cloud et Spring Boot. Spring Cloud fournit des outils pour les d\u00e9veloppeurs pour construire rapidement et facilement des patrons communs de syst\u00e8mes r\u00e9partis (tel que des services de configuration, de d\u00e9couverte ou de routage intelligent). Spring Boot permet de son c\u00f4t\u00e9 de construire des applications Spring rapidement aussi rapidement que possible, en minimisant au maximum le temps de configuration, d'habitude p\u00e9nible, des applications Spring. Nous allons donc cr\u00e9er les microservices suivants: Product Service : Service principal, qui offre une API REST pour lister une liste de produits. Config Service : Service de configuration, dont le r\u00f4le est de centraliser les fichiers de configuration des diff\u00e9rents microservices dans un endroit unique. Proxy Service : Passerelle se chargeant du routage d'une requ\u00eate vers l'une des instances d'un service, de mani\u00e8re \u00e0 g\u00e9rer automatiquement la distribution de charge. Discovery Service : Service permettant l'enregistrement des instances de services en vue d'\u00eatre d\u00e9couvertes par d'autres services. L'architecture r\u00e9sultante aura l'allure suivante:","title":"Architecture Propos\u00e9e"},{"location":"tp4/#creation-des-microservices","text":"","title":"Cr\u00e9ation des Microservices"},{"location":"tp4/#microservice-productservice","text":"Nous commen\u00e7ons par cr\u00e9er le service principal: Product Service . Chaque microservice sera sous forme d'un projet Spring. Pour cr\u00e9er rapidement et facilement un projet Spring avec toutes les d\u00e9pendances n\u00e9cessaires, Spring Boot fournit Spring Initializr . Pour cela, aller au site start.spring.io , et cr\u00e9er un projet avec les caract\u00e9ristiques suivantes: Projet Maven avec Java et Spring Boot version 1.5.8 Group: tn.insat.tpmicro Artifact: product-service D\u00e9pendances: Web Rest Repositories JPA : Java Persistence API H2 : base de donn\u00e9es pour le stockage Actuator : pour le montoring et la gestion de l'application Eureka Discovery : pour l'int\u00e9gration avec le Discovery Service Config Client : pour l'int\u00e9gration avec le Config Service Suivre ensuite les \u00e9tapes suivantes pour cr\u00e9er le microservice ProductService : Ouvrir le projet t\u00e9l\u00e9charg\u00e9 avec IntelliJ IDEA. Sous le r\u00e9pertoire src/main/java et dans le package tn.insat.tpmicro.productservice , cr\u00e9er la classe Product suivante: package tn.insat.tpmicro.productservice ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.Id ; import java.io.Serializable ; @Entity public class Product implements Serializable { @Id @GeneratedValue private int id ; private String name ; public Product (){ } public Product ( String name ) { this . name = name ; } public int getId () { return id ; } public void setId ( int id ) { this . id = id ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } } Cette classe est annot\u00e9e avec JPA, pour stocker ensuite les objets Product dans la base de donn\u00e9es H2 gr\u00e2ce \u00e0 Spring Data. Pour cela, cr\u00e9er l'interface ProductRepository dans le m\u00eame package: package tn.insat.tpmicro.productservice ; import org.springframework.data.jpa.repository.JpaRepository ; public interface ProductRepository extends JpaRepository < Product , Integer > { } Pour ins\u00e9rer les objets dans la base, nous utiliserons l'objet Stream . Pour cela, nous allons cr\u00e9er la classe DummyDataCLR : package tn.insat.tpmicro.productservice ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.CommandLineRunner ; import org.springframework.stereotype.Component ; import java.util.stream.Stream ; @Component class DummyDataCLR implements CommandLineRunner { @Override public void run ( String ... strings ) throws Exception { Stream . of ( \"Pencil\" , \"Book\" , \"Eraser\" ). forEach ( s -> productRepository . save ( new Product ( s ))); productRepository . findAll (). forEach ( s -> System . out . println ( s . getName ())); } @Autowired private ProductRepository productRepository ; } Nous remarquons ici que le productRepository sera instanci\u00e9 automatiquement gr\u00e2ce au m\u00e9canisme d'injection de d\u00e9pendances, utilis\u00e9 par Spring. Lancer la classe principale. Une base de donn\u00e9es H2 sera cr\u00e9\u00e9e et le CommandLineRunner se chargera de lui injecter les donn\u00e9es. Attention Prenez soin d'utiliser JDK 8! Pour ex\u00e9cuter votre application: Cr\u00e9er une configuration mvn package en faisant Run->Edit Configurations puis en cr\u00e9ant une nouvelle configuration de type Maven avec la commande package comme suit: Un r\u00e9pertoire target sera cr\u00e9\u00e9, contenant les classes g\u00e9n\u00e9r\u00e9es. Lancer ensuite la configuration Spring Boot ProductServiceApplication cr\u00e9\u00e9e par d\u00e9faut par IntelliJ. Le r\u00e9sultat sur la console devrait ressembler \u00e0 ce qui suit: Tip Pour \u00e9viter de lancer \u00e0 chaque fois les deux configurations, ajouter dans la deuxi\u00e8me configuration une d\u00e9pendance vers la premi\u00e8re, rajouter cette derni\u00e8re dans la case Before Launch: Build, Maven Goal, Activate Tool Window , comme suit: Pour tester votre application, ouvrir la page http://localhost:8080 sur le navigateur. Vous obtiendrez (si tout se passe bien) le r\u00e9sultat suivant: Vous remarquerez que le service REST cr\u00e9\u00e9 respecte automatiquement la norme HATEOAS , qui offre dans les services REST, les liens pour naviguer dynamiquement entre les interfaces. Si vous naviguez vers la page http://localhost:8080/products , vous verrez la liste des produits, inject\u00e9s par le CLR, comme suit: Pour voir les informations relatives \u00e0 un seul produit, il suffit de conna\u00eetre son ID: http://localhost:8080/products/1 , par exemple. Pour rajouter une fonctionnalit\u00e9 de recherche par nom, par exemple, modifier l'interface ProductRepository , comme suit: package tn.insat.tpmicro.productservice ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.jpa.repository.JpaRepository ; import org.springframework.data.jpa.repository.Query ; import org.springframework.data.repository.query.Param ; import org.springframework.data.rest.core.annotation.RepositoryRestResource ; @RepositoryRestResource public interface ProductRepository extends JpaRepository < Product , Integer > { @Query ( \"select p from Product p where p.name like :name\" ) public Page < Product > productByName ( @Param ( \"name\" ) String mc , Pageable pageable ); } Pour tester cette fonctionnalit\u00e9 de recherche, aller au lien http://localhost:8080/products/search/productByName?name=Eraser Le r\u00e9sultat obtenu sera le suivant: La d\u00e9pendance Actuator qui a \u00e9t\u00e9 rajout\u00e9e au projet permet d'afficher des informations sur votre API REST sans avoir \u00e0 impl\u00e9menter explicitement la fonctionnalit\u00e9. Par exemple, si vous allez vers http://localhost:8080/metrics , vous pourrez avoir plusieurs informations sur le microservice, tel que le nombre de threads, la capacit\u00e9 m\u00e9moire, la classe charg\u00e9e en m\u00e9moire, etc. Mais d'abord, rajouter les deux lignes suivantes au fichier src/main/resources/application.properties pour (1) afficher des informations plus d\u00e9taill\u00e9es sur l'\u00e9tat du service et (2) d\u00e9sactiver les contraintes de s\u00e9curit\u00e9 par d\u00e9faut: endpoints.health.sensitive = false management.security.enabled = false Relancer le projet. Le r\u00e9sultat obtenu en ex\u00e9cutant http://localhost:8080/metrics sera comme suit: Les informations sur l'\u00e9tat du service sont affich\u00e9es gr\u00e2ce \u00e0 http://localhost:8080/health","title":"Microservice ProductService"},{"location":"tp4/#plusieurs-instances-du-microservice-productservice","text":"Nous allons maintenant cr\u00e9er d'autres instances du m\u00eame service et les d\u00e9ployer sur des ports diff\u00e9rents. Pour lancer plusieurs instances du service ProductService , nous allons d\u00e9finir plusieurs configurations avec des num\u00e9ros de port diff\u00e9rents. Pour cela: Aller \u00e0 Run->Edit Configurations , et copier la configuration ProductServiceApplication en la s\u00e9lectionnant dans la barre lat\u00e9rale, et en cliquant sur l'ic\u00f4ne . Une nouvelle configuration sera cr\u00e9\u00e9e. Changer son nom: ProductServiceApplication:8081 Ajouter dans la case Program Arguments l'argument suivant: --server.port = 8081 Lancer la configuration. Un nouveau service sera disponible \u00e0 l'adresse: http://localhost:8081 Tip En ex\u00e9cutant la seconde configuration, un popup s'affiche dans IntelliJ, qui vous demande si vous voulez afficher le dashboard pour visualiser plusieurs instances Spring Boot, comme suit: Cliquer dessus, et choisir : Show Run Configurations in Dashboard . La vue suivante s'affiche, en bas de votre \u00e9cran: Vous pouvez d\u00e9sormais g\u00e9rer vos instances dans cette fen\u00eatre. Refaire les m\u00eames \u00e9tapes pour cr\u00e9er une instance du service tourant sur le port 8082.","title":"Plusieurs Instances du Microservice ProductService"},{"location":"tp4/#microservice-configservice","text":"Dans une architecture microservices, plusieurs services s'ex\u00e9cutent en m\u00eame temps, sur des processus diff\u00e9rents, avec chacun sa propre configuration et ses propres param\u00e8tres. Spring Cloud Config fournit un support c\u00f4t\u00e9 serveur et c\u00f4t\u00e9 client pour externaliser les configurations dans un syst\u00e8me distribu\u00e9. Gr\u00e2ce au service de configuration, il est possible d'avoir un endroit centralis\u00e9 pour g\u00e9rer les propri\u00e9t\u00e9s de chacun de ces services. Pour cela: Commencer par cr\u00e9er un service ConfigService dans Spring Initializr , avec les d\u00e9pendances appropri\u00e9es, comme indiqu\u00e9 sur la figure suivante: Ouvrir le projet dans une autre instance d'IntelliJ IDEA. Pour exposer un service de configuration, utiliser l'annotation @EnableConfigServer pour la classe ConfigServiceApplication , comme suit: package tn.insat.tpmicro.configservice ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.config.server.EnableConfigServer ; @EnableConfigServer @SpringBootApplication public class ConfigServiceApplication { public static void main ( String [] args ) { SpringApplication . run ( ConfigServiceApplication . class , args ); } } Pour param\u00e9trer ce service de configuration, ajouter dans son fichier application.properties les valeurs suivantes: server.port = 8888 spring.cloud.config.server.git.uri = file:./src/main/resources/myConfig Ceci indique que le service de configuration sera lanc\u00e9 sur le port 8888 et que le r\u00e9pertoire contenant les fichiers de configuration se trouve dans le r\u00e9pertoire src/main/resources/myConfig . Il suffit maintenant de cr\u00e9er ce r\u00e9pertoire. Tip Pour pouvoir r\u00e9f\u00e9rencer un r\u00e9pertoire avec son chemin absolu, utiliser plut\u00f4t file:///<chemin_absolu> . Cr\u00e9er le r\u00e9pertoire myConfig \u00e0 l'arborescence src/main/resources Cr\u00e9er dans ce r\u00e9pertoire le fichier application.properties dans lequel vous ins\u00e9rez l'instruction suivante: global = xxxxx Ce fichier sera partag\u00e9 entre tous les microservices utilisant ce service de configuration. Le r\u00e9pertoire de configuration doit \u00eatre un r\u00e9pertoire git. Pour cela: Ouvrir le terminal avec IntelliJ et naviguer vers ce r\u00e9pertoire. Initialiser votre r\u00e9pertoire: git init Cr\u00e9er une entr\u00e9e racine dans le repository: git add . Faire un commit: git commit -m \"add .\" Revenir vers le projet ProductService et ajouter dans le fichier de configuration application.properties : spring.application.name = product-service spring.cloud.config.uri = http://localhost:8888 Red\u00e9marrer vos services. Pour consulter le service de configuration, aller \u00e0 http://localhost:8888/product-service/master . Vous verrez le fichier JSON suivant: { name : \"product-service\" , profiles : [ \"master\" ], label : null , version : \"6e1ea61d706133e2d8b62f40c6b784192fb58e8a\" , state : null , propertySources : [ { name : \"file:./src/main/resources/myConfig/application.properties\" , source : { global : \"xxxxx\" } } ] } Comme le fichier application.properties contient toutes les propri\u00e9t\u00e9s partag\u00e9es des diff\u00e9rents microservices, nous aurons besoins d'autres fichiers pour les propri\u00e9t\u00e9s sp\u00e9cifiques \u00e0 un microservice. Pour cela: Cr\u00e9er dans le r\u00e9pertoire myConfig un fichier product-service.properties pour le service ProductService . Attention Le nom du fichier doit correspondre \u00e0 la propri\u00e9t\u00e9 spring.application.name que vous avez saisi dans le fichier application.properties de votre microservice! Ajouter les propri\u00e9t\u00e9s de votre service, \u00e0 savoir, par exemple: me = lilia.sfaxi@insat.rnu.tn Relancer le microservice de configuration. En consultant l'url http://localhost:8888/product-service/master , nous remarquons l'ajout de la nouvelle propri\u00e9t\u00e9. { name : \"product-service\" , profiles : [ \"master\" ], label : null , version : \"6e1ea61d706133e2d8b62f40c6b784192fb58e8a\" , state : null , propertySources : [ { name : \"file:./src/main/resources/myConfig/product-service.properties\" , source : { me : \"lilia.sfaxi@insat.rnu.tn\" } }, { name : \"file:./src/main/resources/myConfig/application.properties\" , source : { global : \"xxxxx\" } } ] } Nous allons maintenant d\u00e9finir un appel REST \u00e0 cette propri\u00e9t\u00e9. Pour cela: Cr\u00e9er la classe ProductRestService dans le projet product-service . Son code ressemblera \u00e0 ce qui suit: package tn.insat.tpmicro.productservice ; import org.springframework.beans.factory.annotation.Value ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RestController ; @RestController public class ProductRestService { @Value ( \"${me}\" ) private String me ; @RequestMapping ( \"/messages\" ) public String tellMe (){ System . out . println ( \"c'est moi qui ai r\u00e9pondu!\" ); return me ; } } Red\u00e9marrer les trois instances du service, puis appeler dans votre navigateur le service en tapant: http://localhost:8080/messages . Vous verrez le r\u00e9sultat suivant sur le navigateur: Consulter votre Spring Dashboard, vous verrez le message suivant dans la console de l'instance du service lanc\u00e9e sur le port 8080:","title":"Microservice ConfigService"},{"location":"tp4/#microservice-discoveryservice","text":"Pour \u00e9viter un couplage fort entre microservices, il est fortement recommand\u00e9 d'utiliser un service de d\u00e9couverte qui permet d'enregistrer les propri\u00e9t\u00e9s des diff\u00e9rents services et d'\u00e9viter ainsi d'avoir \u00e0 appeler un service directement. Au lieu de cela, le service de d\u00e9couverte fournira dynamiquement les informations n\u00e9cessaires, ce qui permet d'assurer l'\u00e9lasticit\u00e9 et la dynamicit\u00e9 propres \u00e0 une architecture microservices. Pour r\u00e9aliser cela, Netflix offre le service Eureka Service Registration and Discovery , que nous allons utiliser dans notre application. Revenir \u00e0 Spring Initializr et cr\u00e9er un nouveau projet Spring Boot intitul\u00e9 discovery-service avec les d\u00e9pendances Eureka Server et Config Client . Lancer le projet avec IntelliJ. Dans la classe DiscoveryServiceApplication , ajouter l'annotation EnableEurekaServer . package tn.insat.tpmicro.discoveryservice ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer ; @EnableEurekaServer @SpringBootApplication public class DiscoveryServiceApplication { public static void main ( String [] args ) { SpringApplication . run ( DiscoveryServiceApplication . class , args ); } } Ajouter les propri\u00e9t\u00e9s suivantes dans son fichier application.properties . spring.application.name = discovery-service spring.cloud.config.uri = http://localhost:8888 Dans le projet config-service , cr\u00e9er un fichier discovery-service.properties sous le r\u00e9pertoire myConfig . Ajouter les propri\u00e9t\u00e9s suivantes pour (1) d\u00e9finir le port par d\u00e9faut du service de d\u00e9couverte et (2) emp\u00eacher un auto-enregistrement du service Eureka. server.port = 8761 eureka.client.fetch-registry = false eureka.client.register-with-eureka = false Pour consulter le service Eureka, aller \u00e0 http://localhost:8761 , l'interface suivante s'affiche: Nous remarquons qu'aucune instance n'est inscrite dans le serveur de d\u00e9couverte. Nous allons donc modifier le code de la classe ProductServiceApplication pour que le microservice ProductService s'enregistre: package tn.insat.tpmicro.productservice ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.client.discovery.EnableDiscoveryClient ; @EnableDiscoveryClient @SpringBootApplication public class ProductServiceApplication { public static void main ( String [] args ) { SpringApplication . run ( ProductServiceApplication . class , args ); } } Red\u00e9marrer les trois instances de services ProductService et actualiser la fen\u00eatre de Eureka , vous verrez qu'un seul service est d\u00e9clar\u00e9, avec trois adresses diff\u00e9rentes.","title":"Microservice DiscoveryService"},{"location":"tp4/#microservice-proxyservice","text":"L'architecture microservices, en fournissant un ensemble de services ind\u00e9pendants et faiblement coupl\u00e9s, se trouve confront\u00e9e au challenge de fournir une interface unifi\u00e9e pour les consommateurs, de mani\u00e8re \u00e0 ce qu'ils ne voient pas la d\u00e9composition \u00e0 faible granularit\u00e9 de vos services. C'est pour cela que l'utilisation d'un service proxy, responsable du routage des requ\u00eates et de la r\u00e9partition de charge, est important. Netflix offre le service Zuul pour r\u00e9aliser cela. Pour cr\u00e9er votre microservice Proxy: Aller \u00e0 Spring Initializr . Cr\u00e9er le projet proxy-service avec les d\u00e9pendances suivantes: Zuul, Web, HATEOAS, Actuator, Config Client et Eureka Discovery. Ouvrir le service avec IntelliJ IDEA. Ajouter \u00e0 la classe ProxyServiceApplication l'annotation @EnableZuulProxy , ainsi que @EnableDiscoveryClient pour que le proxy soit \u00e9galement enregistr\u00e9 dans le service de d\u00e9couverte. Ajouter les propri\u00e9t\u00e9s spring.application.name et spring.cloud.config.uri dans le fichier application.properties du service proxy. Cr\u00e9er le fichier proxy-service.properties dans le r\u00e9pertoire myConfig du service de configuration, dans lequel vous allez fixer le port du service proxy \u00e0 9999. En lan\u00e7ant le service Proxy, vous remarquerez qu'il est rajout\u00e9 dans Eureka. Si vous ex\u00e9cutez la requ\u00eate http://localhost:9999/product-service/messages plusieurs fois, vous remarquerez que l'affichage c'est moi qui ai r\u00e9pondu! s'affichera sur les consoles des trois instances respectivement, \u00e0 tour de r\u00f4le.","title":"Microservice ProxyService"},{"location":"tp5/","text":"TP5 - API Management avec Atom et Anypoint \u00b6 T\u00e9l\u00e9charger PDF \u00b6 Objectifs du TP \u00b6 G\u00e9n\u00e9ration d\u2019API avec Atom et le langage RAML Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft Outils et Versions \u00b6 Atom Version: 1.22.1 API Workbench : Plugin Atom. Version: 0.8.47 Anypoint Studio Version: 6.4.1 MySQL Version 5.7.20 (ou tout autre SGBD de votre choix) G\u00e9n\u00e9ration d'API avec RAML \u00b6 RAML \u00b6 RAML (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful. RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles technologie, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage. API Workbench \u00b6 Pour \u00e9crire un document RAML de mani\u00e8re simple et intuitive, un outil de travail est fourni, sous la forme d\u2019un plugin pour Atom , l'\u00e9diteur de texte open source, appel\u00e9 API Workbench . Pour l\u2019installer: T\u00e9l\u00e9charger et installer Atom: https://atom.io/ Dans le menu Pr\u00e9f\u00e9rences, choisir l\u2019option Packages , et taper dans la barre de recherche: api-workbench . Une fois le package install\u00e9, on devrait trouver dans le menu Packages, un nouvel \u00e9l\u00e9ment API Workbench . Cr\u00e9ation d\u2019un document RAML \u00b6 Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations d\u00e9crites dans le cours. Cr\u00e9ation d\u2019une API RAML \u00b6 Pour cr\u00e9er un nouveau projet RAML, aller vers Packages -> API Workbench -> Create RAML Project . Indiquer : Le r\u00e9pertoire de travail Le titre de l\u2019API : Par exemple Pet Shop La version : v1 L\u2019URI de base l\u2019API : /petshop Cocher uniquement Use RAML 1.0 Le projet obtenu aura l\u2019allure suivante: Ajout de Ressources et M\u00e9thodes \u00b6 Sous l\u2019onglet Palette de la rubrique D\u00e9tails, cliquer sur Add new ressource pour ajouter une nouvelle ressource. Appeler la ressource /pets S\u00e9lectionner les m\u00e9thodes get et post La ressource est d\u00e9sormais cr\u00e9\u00e9e avec deux m\u00e9thodes vides. Remplir les corps et r\u00e9ponses des m\u00e9thodes \u00b6 Mettre le focus sur la m\u00e9thode get: Dans la Palette, cliquer sur Create new response Garder le code 200 pour la r\u00e9ponse et cliquer sur OK Une fois le code de la r\u00e9ponse g\u00e9n\u00e9r\u00e9, mettre le focus sur 200: Cliquer sur Create new Response Body , puis dans la fen\u00eatre qui apparait cliquer sur OK, pour g\u00e9n\u00e9rer une r\u00e9ponse de type par d\u00e9faut application/json Pour la m\u00e9thode post, g\u00e9n\u00e9rer directement un corps, en cliquant sur Create new body . Le r\u00e9sultat appara\u00eet comme suit: Ajouter des sous-ressources \u00b6 Pour d\u00e9finir le reste des m\u00e9thodes (put et delete), destin\u00e9es \u00e0 agir sur un \u00e9l\u00e9ment unique de la ressource pets, et les associer \u00e0 une sous-ressource: Mettre le focus sur /pets Cliquer sur Add new resource Taper /{id} comme ressource URL, et s\u00e9lectionner les m\u00e9thodes put et delete. Ajouter un body \u00e0 put de type application/json Ajouter une r\u00e9ponse \u00e0 delete de type 204 D\u00e9finir des types \u00b6 Pour d\u00e9finir le contenu des messages JSON manipul\u00e9s, d\u00e9finir un type comme suit: Dans une nouvelle ligne au dessus de /pets , taper ty , puis cliquer sur entr\u00e9e Appeler le type Pet , puis d\u00e9finir les propri\u00e9t\u00e9s name, kind et price, comme suit: types : Pet : properties : name : string kind : string price : number D\u00e9finir Pet comme type pour le corps de la m\u00e9thode post , en \u00e9crivant: type: Pet au dessous de application/json de la m\u00e9thode post Ajouter de m\u00eame Pet comme type pour la m\u00e9thode put, et Pet[] pour la m\u00e9thode get. Extraction d\u2019un type de ressources \u00b6 Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante: Mettre le focus sur la ressource /pets Cliquer sur Extract Resource Type (si vous ne la trouvez pas, appuyer sur entr\u00e9e ) Taper Collection comme nom de type de ressource et d\u00e9placer les m\u00e9thodes get et post de la fen\u00eatre de gauche vers celle de droite Un nouveau resourceType , appel\u00e9 Collection , est cr\u00e9\u00e9, contenant les m\u00e9thodes get et post comme elles ont \u00e9t\u00e9 d\u00e9finies sous la ressource /pets . De plus, /pets est d\u00e9sormais de type Collection . R\u00e9p\u00e9ter la proc\u00e9dure pour la ressource /{id}. On appellera le type Member . Le r\u00e9sultat devra ressembler \u00e0 ce qui suit: Ajout de param\u00e8tres au type de ressource \u00b6 Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela: Remplacer le terme Pet dans Collection et Member par <<item>> . Corriger les erreurs qui s\u2019affichent dans les ressources Collection et Member respectivement par { Collection: {item : Pet} } et { Member: {item : Pet} } Ajout d\u2019un exemple \u00b6 Pour ajouter un exemple d\u2019animal, modifier le type Pet pour qu\u2019il soit comme suit: types : Pet : properties : name : string kind : string price : number example : name : Snoopy kind : Dog price : 1000 D\u00e9finir des param\u00e8tres pour les m\u00e9thodes \u00b6 Nous nous proposons d\u2019ajouter une autre m\u00e9thode de type get , qui d\u00e9finit plusieurs param\u00e8tres. Sous (et au m\u00eame niveau que) type de /pets , taper: get: Mettre le focus sur le get nouvellement cr\u00e9\u00e9 Cliquer sur Create new query parameter Cr\u00e9er trois param\u00e8tres: priceLessThan de type number priceMoreThan de type number petKind , de type enum;[bird, dog] Cela devra ressembler \u00e0 ce qui suit: get : queryParameters : priceLessThan : number priceMoreThan : number petKind : enum : - bird - dog Il est possible d\u2019extraire certains des param\u00e8tres comme Trait , c\u2019est \u00e0 dire un crit\u00e8re de filtrage. Pour cela: Mettre le focus sur le get Cliquer sur Extract trait Nommer le trait FiltrableByPrice , et d\u00e9placer les m\u00e9thodes priceLessThan et priceMoreThan vers la droite. Vous remarquerez que les deux param\u00e8tres choisis ont \u00e9t\u00e9 enlev\u00e9s de la m\u00e9thode get , et remplac\u00e9s par is: [FilterableByPrice] . Voici donc le r\u00e9sultat final du fichier RAML: #%RAML 1.0 traits : FiltrableByPrice : queryParameters : priceLessThan : number priceMoreThan : number resourceTypes : Collection : get : responses : 200 : body : application/json : type : <<item>> post : body : application/json : type : <<item>> Member : delete : responses : 204 : put : body : application/json : type : <<item>> title : Pet Shop version : v1 baseUri : /petshop types : Pet : properties : name : string kind : string price : number example : name : Snoopy kind : Dog price : 1000 /pets : type : { Collection: {item : Pet} } get : queryParameters : petKind : enum : - bird - dog is : [FiltrableByPrice] /{id} : type : { Member: {item : Pet} } Extraction de la librairie \u00b6 Pour extraire les types d\u00e9finis et les repr\u00e9senter dans une entit\u00e9 r\u00e9utilisable: Mettre le focus en dehors de toutes les structures, par exemple sur title Cliquer sur Extract Library Appeler la librarie PetTypes D\u00e9placer Pet , Collection et Member vers le panel de droite Cliquer sur Extract Un nouveau fichier contenant les trois types s\u00e9lectionn\u00e9s a \u00e9t\u00e9 cr\u00e9\u00e9, puis inclus comme r\u00e9f\u00e9rence dans notre fichier principal. API Management avec Anypoint Studio \u00b6 Anypoint Platform \u00b6 Anypoint est une plateforme d\u00e9velopp\u00e9e par l\u2019entreprise Mulesoft qui offre les outils n\u00e9cessaires pour la gestion d\u2019APIs. Anypoint est class\u00e9e par Gartner dans son Magic Quadrant dans la rubrique \u201cApplication Services Governance\u201d d\u2019Avril 2015 parmi les leaders du march\u00e9 du API Management. Premi\u00e8re Application \u00b6 Une fois Anypoint Studio t\u00e9l\u00e9charg\u00e9 et install\u00e9, cr\u00e9er un nouveau projet, qu\u2019on appellera PremiereApplication , et choisir Mule Server comme Runtime Environment . La fen\u00eatre obtenue a l\u2019allure suivante: Attention Anypoint Studio version 6.4.1 ne fonctionne qu'avec au plus JDK 1.8.0_151! Nous allons commencer par cr\u00e9er une simple application qui affiche un message dans un navigateur. \u00c0 partir de la palette, glisser-d\u00e9placer les \u00e9l\u00e9ments graphiques suivants dans le canevas: HTTP : permet de se connecter aux ressources web via HTTP ou HTTPS. Set Payload : modifie le message affich\u00e9 (payload) en \"Hello World!\". Votre flux aura l\u2019allure suivante: Configurer votre composant HTTP : Ajouter une nouvelle Connector Configuration Garder les options par d\u00e9faut. Votre h\u00f4te se lancera \u00e0 l\u2019URL 0.0.0.0:8081 Configurer le composant Set Payload: Remplacer la valeur de l\u2019\u00e9l\u00e9ment Value par Hello World! Lancer votre application : Run -> Run As -> Mule Application. La console devrait afficher un message comme suit: Dans un navigateur, taper l'adresse: 0.0.0.0:8081. Le message suivant devra s'afficher: Gestion des APIs avec APIKit \u00b6 APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs. Nous allons pour cela exposer l'API REST que nous avons cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent , gr\u00e2ce aux microservices Spring. Cr\u00e9ation d'un fichier RAML pour le microservice \u00b6 Pour repr\u00e9senter le microservice \"ProductService\", cr\u00e9er le fichier api.raml suivant avec Atom: #%RAML 1.0 title : Micro-API version : v1 baseUri : http://products.tn /products : get : description : List of all the products responses : 200 : body : application/json : example : !include products-example.json Rajouter \u00e9galement (dans le m\u00eame r\u00e9pertoire) un fichier products-example.json , o\u00f9 vous allez trouver un exemple de produits, tel qu'ils sont repr\u00e9sent\u00e9s par votre service sur http://localhost:9999/product-service/products . Cela devrait ressembler \u00e0 ce qui suit: { \"_embedded\" : { \"products\" : [ { \"name\" : \"Sample Product\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products{?page,size,sort}\" , \"templated\" : true }, \"profile\" : { \"href\" : \"http://localhost:9999/product-service/profile/products\" }, \"search\" : { \"href\" : \"http://localhost:9999/product-service/products/search\" } }, \"page\" : { \"size\" : 20 , \"totalElements\" : 3 , \"totalPages\" : 1 , \"number\" : 0 } } Nouveau Projet de API Management \u00b6 Cr\u00e9er un nouveau projet qu\u2019on appellera API_Project : Choisir comme environnement d\u2019ex\u00e9cution Mule Server. Cocher la case Add APIKit components et entrer votre fichier api.raml. Un nouveau projet sera cr\u00e9\u00e9 avec les fichiers api.raml et products-example.json ajout\u00e9 sous le r\u00e9pertoire src/main/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment: Flux Description Figure api-main Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception action:/ressource:api-config Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products Exception Strategy Mapping Flux fournis par Studio pour configurer les messages d\u2019erreur dans un format HTTP-status-code-friendly Configuration du flux principal \u00b6 Dans les propri\u00e9t\u00e9s du composant HTTP, d\u00e9finir le Path par: /prod-services/*. Dans le Connector Configuration , cliquer sur l'ic\u00f4ne , puis cliquer sur OK pour valider le host (0.0.0.0) et le port (8081) Remarque Vous pouvez changer ici le port d\u00e9fini par d\u00e9faut, pour \u00e9viter les conflits avec vos microservices. Lancer le projet comme Mule Project . Une APIKit Console s'affiche comme suit: Pour tester votre API, cliquer par exemple sur le bouton GET devant la ressource /products . la Console affichera alors la r\u00e9ponse (le produit Sample Product ), qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part. Pour visualiser le r\u00e9sultat sur le navigateur, taper le chemin de la requ\u00eate comme suit: http://localhost:8081/prod-services/products Vous obtiendrez le r\u00e9sultat suivant: Mapping de l'API avec votre microservice ProductService \u00b6 Pour relier votre API cr\u00e9\u00e9e avec le microservice Proxy (cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent), et qui est d\u00e9ploy\u00e9 \u00e0 l'adresse suivante: http://localhost:9999/product-service/products Supprimer le Set Payload du flow : get:/products:api-config Ajouter un connecteur HTTP dans la partie Source Le configurer comme suit: Path: /prod-services Cliquer sur puis sur OK pour valider le h\u00f4te et port. Ajouter un connecteur HTTP dans la partie Process Le configurer comme suit: Devant Connector Configuration , cliquer sur pour ajouter une nouvelle configuration. Cela repr\u00e9sente les informations du service auquel on va acc\u00e9der. D\u00e9finir le Host par localhost , le port par 9999 , et le base path par /product-service Cliquer sur OK pour valider Dans la partie URL Settings , d\u00e9finir : Path: /products Method: Get Sauvegarder, et lancer le service. Tester le service sur le navigateur avec l'URL: http://localhost:8081/prod-services . Vous obtiendrez la liste compl\u00e8te des produits, tels que retourn\u00e9s par le service ProductService initial, comme suit: { \"_embedded\" : { \"products\" : [ { \"name\" : \"Pencil\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" } } }, { \"name\" : \"Book\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/2\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/2\" } } }, { \"name\" : \"Eraser\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/3\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/3\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products{?page,size,sort}\" , \"templated\" : true }, \"profile\" : { \"href\" : \"http://localhost:9999/product-service/profile/products\" }, \"search\" : { \"href\" : \"http://localhost:9999/product-service/products/search\" } }, \"page\" : { \"size\" : 20 , \"totalElements\" : 3 , \"totalPages\" : 1 , \"number\" : 0 } } Transformation du r\u00e9sultat du microservice ProductService \u00b6 Si vous d\u00e9sirez retourner un r\u00e9sultat diff\u00e9rent du Microservice initial, en ne laissant par exemple que les noms des produits, sans tous les autres \u00e9l\u00e9ments et liens suppl\u00e9mentaires, utiliser un objet Transform Message Copier le flow get:/products pour cr\u00e9er un autre flow identique Modifier le Path du connecteur HTTP source, pour /prod-services/names Rajouter un objet Transform Message juste apr\u00e8s le connecteur HTTP de droite (celui de la partie Process). Le flow devra ressembler \u00e0 ce qui suit: Configurer l'objet Transform Message : L'interface suivante repr\u00e9sente les mappings \u00e0 faire entre les entr\u00e9es du service et sa sortie. Cliquer sur Define Metadata du payload en entr\u00e9e (\u00e0 gauche) gauche) Cliquer sur Add Entrer le nom du type en entr\u00e9e, par exemple products Indiquer comme type JSON Indiquer dans la liste d\u00e9roulante suivante que le fichier donn\u00e9 est un Example , puis choisir le fichier products-example.json que vous aviez cr\u00e9\u00e9. Cliquer sur Select. Le sch\u00e9ma du fichier donn\u00e9 est charg\u00e9 dans la partie Input de Transform Message . Pour repr\u00e9senter le format de sortie d\u00e9sir\u00e9, cr\u00e9er un fichier appel\u00e9 names.json \u00e0 l'endroit de votre pr\u00e9f\u00e9rence sur votre ordinateur. Saisir le contenu suivant dans names.json : { \"name\" : \"prod\" } Cliquer sur Define Metadata de sortie (\u00e0 droite). Ajouter un nouveau type que vous appellerez names D\u00e9finir comme type Json et charger le fichier names.json que vous venez de cr\u00e9er. Valider. Maintenant que les deux sch\u00e9mas (entr\u00e9e et sortie) sont d\u00e9finis, cr\u00e9er les associations de votre choix. Dans notre cas, nous allons associer le champ _embedded.products.name en entr\u00e9e au champ name en sortie, comme suit: Sauvegarder, et lancer le service. Pour tester le service, lancer dans un navigateur: http://localhost:8081/prod-services/names . Vous obtiendrez le r\u00e9sultat suivant: { \"name\" : [ \"Pencil\" , \"Book\" , \"Eraser\" ] }","title":"TP5 - API Management avec Atom et Anypoint"},{"location":"tp5/#tp5-api-management-avec-atom-et-anypoint","text":"","title":"TP5 - API Management avec Atom et Anypoint"},{"location":"tp5/#telecharger-pdf","text":"","title":"T\u00e9l\u00e9charger PDF"},{"location":"tp5/#objectifs-du-tp","text":"G\u00e9n\u00e9ration d\u2019API avec Atom et le langage RAML Gestion des APIs avec Anypoint Studio et le API Gateway de Mulesoft","title":"Objectifs du TP"},{"location":"tp5/#outils-et-versions","text":"Atom Version: 1.22.1 API Workbench : Plugin Atom. Version: 0.8.47 Anypoint Studio Version: 6.4.1 MySQL Version 5.7.20 (ou tout autre SGBD de votre choix)","title":"Outils et Versions"},{"location":"tp5/#generation-dapi-avec-raml","text":"","title":"G\u00e9n\u00e9ration d'API avec RAML"},{"location":"tp5/#raml","text":"RAML (RESTful API Modeling Language) est un langage pour la d\u00e9finition d\u2019API HTTP qui satisfont les exigences de l'architecture REST. La sp\u00e9cification RAML est une application de la sp\u00e9cification YAML, qui fournit des m\u00e9canismes pour la d\u00e9finition d\u2019APIs RESTful. RAML est d\u00e9velopp\u00e9 et support\u00e9 par un groupe de leaders en nouvelles technologie, provenant de plusieurs entreprises \u00e9minentes (Mulesoft, Airware, Akana, VMware, CISCO\u2026). Leur but est de construire une sp\u00e9cification ouverte, simple et succincte pour la description d\u2019APIs. Ce groupe de travail contribue \u00e0 la fois \u00e0 la sp\u00e9cification RAML, ainsi qu\u2019\u00e0 un \u00e9cosyst\u00e8me croissant d\u2019outils autours de ce langage.","title":"RAML"},{"location":"tp5/#api-workbench","text":"Pour \u00e9crire un document RAML de mani\u00e8re simple et intuitive, un outil de travail est fourni, sous la forme d\u2019un plugin pour Atom , l'\u00e9diteur de texte open source, appel\u00e9 API Workbench . Pour l\u2019installer: T\u00e9l\u00e9charger et installer Atom: https://atom.io/ Dans le menu Pr\u00e9f\u00e9rences, choisir l\u2019option Packages , et taper dans la barre de recherche: api-workbench . Une fois le package install\u00e9, on devrait trouver dans le menu Packages, un nouvel \u00e9l\u00e9ment API Workbench .","title":"API Workbench"},{"location":"tp5/#creation-dun-document-raml","text":"Dans ce qui suit, nous vous indiquons les \u00e9tapes n\u00e9cessaires pour cr\u00e9er un simple fichier RAML d\u00e9crivant une API REST r\u00e9pondant aux recommandations d\u00e9crites dans le cours.","title":"Cr\u00e9ation d\u2019un document RAML"},{"location":"tp5/#creation-dune-api-raml","text":"Pour cr\u00e9er un nouveau projet RAML, aller vers Packages -> API Workbench -> Create RAML Project . Indiquer : Le r\u00e9pertoire de travail Le titre de l\u2019API : Par exemple Pet Shop La version : v1 L\u2019URI de base l\u2019API : /petshop Cocher uniquement Use RAML 1.0 Le projet obtenu aura l\u2019allure suivante:","title":"Cr\u00e9ation d\u2019une API RAML"},{"location":"tp5/#ajout-de-ressources-et-methodes","text":"Sous l\u2019onglet Palette de la rubrique D\u00e9tails, cliquer sur Add new ressource pour ajouter une nouvelle ressource. Appeler la ressource /pets S\u00e9lectionner les m\u00e9thodes get et post La ressource est d\u00e9sormais cr\u00e9\u00e9e avec deux m\u00e9thodes vides.","title":"Ajout de Ressources et M\u00e9thodes"},{"location":"tp5/#remplir-les-corps-et-reponses-des-methodes","text":"Mettre le focus sur la m\u00e9thode get: Dans la Palette, cliquer sur Create new response Garder le code 200 pour la r\u00e9ponse et cliquer sur OK Une fois le code de la r\u00e9ponse g\u00e9n\u00e9r\u00e9, mettre le focus sur 200: Cliquer sur Create new Response Body , puis dans la fen\u00eatre qui apparait cliquer sur OK, pour g\u00e9n\u00e9rer une r\u00e9ponse de type par d\u00e9faut application/json Pour la m\u00e9thode post, g\u00e9n\u00e9rer directement un corps, en cliquant sur Create new body . Le r\u00e9sultat appara\u00eet comme suit:","title":"Remplir les corps et r\u00e9ponses des m\u00e9thodes"},{"location":"tp5/#ajouter-des-sous-ressources","text":"Pour d\u00e9finir le reste des m\u00e9thodes (put et delete), destin\u00e9es \u00e0 agir sur un \u00e9l\u00e9ment unique de la ressource pets, et les associer \u00e0 une sous-ressource: Mettre le focus sur /pets Cliquer sur Add new resource Taper /{id} comme ressource URL, et s\u00e9lectionner les m\u00e9thodes put et delete. Ajouter un body \u00e0 put de type application/json Ajouter une r\u00e9ponse \u00e0 delete de type 204","title":"Ajouter des sous-ressources"},{"location":"tp5/#definir-des-types","text":"Pour d\u00e9finir le contenu des messages JSON manipul\u00e9s, d\u00e9finir un type comme suit: Dans une nouvelle ligne au dessus de /pets , taper ty , puis cliquer sur entr\u00e9e Appeler le type Pet , puis d\u00e9finir les propri\u00e9t\u00e9s name, kind et price, comme suit: types : Pet : properties : name : string kind : string price : number D\u00e9finir Pet comme type pour le corps de la m\u00e9thode post , en \u00e9crivant: type: Pet au dessous de application/json de la m\u00e9thode post Ajouter de m\u00eame Pet comme type pour la m\u00e9thode put, et Pet[] pour la m\u00e9thode get.","title":"D\u00e9finir des types"},{"location":"tp5/#extraction-dun-type-de-ressources","text":"Pour g\u00e9n\u00e9rer un type de ressources \u00e0 partir d\u2019une ressource existante: Mettre le focus sur la ressource /pets Cliquer sur Extract Resource Type (si vous ne la trouvez pas, appuyer sur entr\u00e9e ) Taper Collection comme nom de type de ressource et d\u00e9placer les m\u00e9thodes get et post de la fen\u00eatre de gauche vers celle de droite Un nouveau resourceType , appel\u00e9 Collection , est cr\u00e9\u00e9, contenant les m\u00e9thodes get et post comme elles ont \u00e9t\u00e9 d\u00e9finies sous la ressource /pets . De plus, /pets est d\u00e9sormais de type Collection . R\u00e9p\u00e9ter la proc\u00e9dure pour la ressource /{id}. On appellera le type Member . Le r\u00e9sultat devra ressembler \u00e0 ce qui suit:","title":"Extraction d\u2019un type de ressources"},{"location":"tp5/#ajout-de-parametres-au-type-de-ressource","text":"Pour rendre le type de ressource cr\u00e9\u00e9 g\u00e9n\u00e9rique, il serait plus int\u00e9ressant de param\u00e9trer le type de r\u00e9ponse. Pour cela: Remplacer le terme Pet dans Collection et Member par <<item>> . Corriger les erreurs qui s\u2019affichent dans les ressources Collection et Member respectivement par { Collection: {item : Pet} } et { Member: {item : Pet} }","title":"Ajout de param\u00e8tres au type de ressource"},{"location":"tp5/#ajout-dun-exemple","text":"Pour ajouter un exemple d\u2019animal, modifier le type Pet pour qu\u2019il soit comme suit: types : Pet : properties : name : string kind : string price : number example : name : Snoopy kind : Dog price : 1000","title":"Ajout d\u2019un exemple"},{"location":"tp5/#definir-des-parametres-pour-les-methodes","text":"Nous nous proposons d\u2019ajouter une autre m\u00e9thode de type get , qui d\u00e9finit plusieurs param\u00e8tres. Sous (et au m\u00eame niveau que) type de /pets , taper: get: Mettre le focus sur le get nouvellement cr\u00e9\u00e9 Cliquer sur Create new query parameter Cr\u00e9er trois param\u00e8tres: priceLessThan de type number priceMoreThan de type number petKind , de type enum;[bird, dog] Cela devra ressembler \u00e0 ce qui suit: get : queryParameters : priceLessThan : number priceMoreThan : number petKind : enum : - bird - dog Il est possible d\u2019extraire certains des param\u00e8tres comme Trait , c\u2019est \u00e0 dire un crit\u00e8re de filtrage. Pour cela: Mettre le focus sur le get Cliquer sur Extract trait Nommer le trait FiltrableByPrice , et d\u00e9placer les m\u00e9thodes priceLessThan et priceMoreThan vers la droite. Vous remarquerez que les deux param\u00e8tres choisis ont \u00e9t\u00e9 enlev\u00e9s de la m\u00e9thode get , et remplac\u00e9s par is: [FilterableByPrice] . Voici donc le r\u00e9sultat final du fichier RAML: #%RAML 1.0 traits : FiltrableByPrice : queryParameters : priceLessThan : number priceMoreThan : number resourceTypes : Collection : get : responses : 200 : body : application/json : type : <<item>> post : body : application/json : type : <<item>> Member : delete : responses : 204 : put : body : application/json : type : <<item>> title : Pet Shop version : v1 baseUri : /petshop types : Pet : properties : name : string kind : string price : number example : name : Snoopy kind : Dog price : 1000 /pets : type : { Collection: {item : Pet} } get : queryParameters : petKind : enum : - bird - dog is : [FiltrableByPrice] /{id} : type : { Member: {item : Pet} }","title":"D\u00e9finir des param\u00e8tres pour les m\u00e9thodes"},{"location":"tp5/#extraction-de-la-librairie","text":"Pour extraire les types d\u00e9finis et les repr\u00e9senter dans une entit\u00e9 r\u00e9utilisable: Mettre le focus en dehors de toutes les structures, par exemple sur title Cliquer sur Extract Library Appeler la librarie PetTypes D\u00e9placer Pet , Collection et Member vers le panel de droite Cliquer sur Extract Un nouveau fichier contenant les trois types s\u00e9lectionn\u00e9s a \u00e9t\u00e9 cr\u00e9\u00e9, puis inclus comme r\u00e9f\u00e9rence dans notre fichier principal.","title":"Extraction de la librairie"},{"location":"tp5/#api-management-avec-anypoint-studio","text":"","title":"API Management avec Anypoint Studio"},{"location":"tp5/#anypoint-platform","text":"Anypoint est une plateforme d\u00e9velopp\u00e9e par l\u2019entreprise Mulesoft qui offre les outils n\u00e9cessaires pour la gestion d\u2019APIs. Anypoint est class\u00e9e par Gartner dans son Magic Quadrant dans la rubrique \u201cApplication Services Governance\u201d d\u2019Avril 2015 parmi les leaders du march\u00e9 du API Management.","title":"Anypoint Platform"},{"location":"tp5/#premiere-application","text":"Une fois Anypoint Studio t\u00e9l\u00e9charg\u00e9 et install\u00e9, cr\u00e9er un nouveau projet, qu\u2019on appellera PremiereApplication , et choisir Mule Server comme Runtime Environment . La fen\u00eatre obtenue a l\u2019allure suivante: Attention Anypoint Studio version 6.4.1 ne fonctionne qu'avec au plus JDK 1.8.0_151! Nous allons commencer par cr\u00e9er une simple application qui affiche un message dans un navigateur. \u00c0 partir de la palette, glisser-d\u00e9placer les \u00e9l\u00e9ments graphiques suivants dans le canevas: HTTP : permet de se connecter aux ressources web via HTTP ou HTTPS. Set Payload : modifie le message affich\u00e9 (payload) en \"Hello World!\". Votre flux aura l\u2019allure suivante: Configurer votre composant HTTP : Ajouter une nouvelle Connector Configuration Garder les options par d\u00e9faut. Votre h\u00f4te se lancera \u00e0 l\u2019URL 0.0.0.0:8081 Configurer le composant Set Payload: Remplacer la valeur de l\u2019\u00e9l\u00e9ment Value par Hello World! Lancer votre application : Run -> Run As -> Mule Application. La console devrait afficher un message comme suit: Dans un navigateur, taper l'adresse: 0.0.0.0:8081. Le message suivant devra s'afficher:","title":"Premi\u00e8re Application"},{"location":"tp5/#gestion-des-apis-avec-apikit","text":"APIKit est un toolkit open source sp\u00e9cialement cr\u00e9\u00e9 pour faciliter l\u2019impl\u00e9mentation d\u2019APIs REST, en renfor\u00e7ant les bonnes pratiques de cr\u00e9ation d\u2019APIs. Nous allons pour cela exposer l'API REST que nous avons cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent , gr\u00e2ce aux microservices Spring.","title":"Gestion des APIs avec APIKit"},{"location":"tp5/#creation-dun-fichier-raml-pour-le-microservice","text":"Pour repr\u00e9senter le microservice \"ProductService\", cr\u00e9er le fichier api.raml suivant avec Atom: #%RAML 1.0 title : Micro-API version : v1 baseUri : http://products.tn /products : get : description : List of all the products responses : 200 : body : application/json : example : !include products-example.json Rajouter \u00e9galement (dans le m\u00eame r\u00e9pertoire) un fichier products-example.json , o\u00f9 vous allez trouver un exemple de produits, tel qu'ils sont repr\u00e9sent\u00e9s par votre service sur http://localhost:9999/product-service/products . Cela devrait ressembler \u00e0 ce qui suit: { \"_embedded\" : { \"products\" : [ { \"name\" : \"Sample Product\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products{?page,size,sort}\" , \"templated\" : true }, \"profile\" : { \"href\" : \"http://localhost:9999/product-service/profile/products\" }, \"search\" : { \"href\" : \"http://localhost:9999/product-service/products/search\" } }, \"page\" : { \"size\" : 20 , \"totalElements\" : 3 , \"totalPages\" : 1 , \"number\" : 0 } }","title":"Cr\u00e9ation d'un fichier RAML pour le microservice"},{"location":"tp5/#nouveau-projet-de-api-management","text":"Cr\u00e9er un nouveau projet qu\u2019on appellera API_Project : Choisir comme environnement d\u2019ex\u00e9cution Mule Server. Cocher la case Add APIKit components et entrer votre fichier api.raml. Un nouveau projet sera cr\u00e9\u00e9 avec les fichiers api.raml et products-example.json ajout\u00e9 sous le r\u00e9pertoire src/main/api , ainsi que des flux de gestion des diff\u00e9rentes m\u00e9thodes ajout\u00e9es par d\u00e9faut dans le canevas. Vous retrouverez notamment: Flux Description Figure api-main Flux principal, d\u00e9finissant un point d\u2019acc\u00e8s HTTP, un routeur APIKit et une r\u00e9f\u00e9rence \u00e0 une strat\u00e9gie d'exception action:/ressource:api-config Un Backend flow pour chaque paire de ressource/action dans le fichier RAML. Par exemple, get:/products:api-config repr\u00e9sente l\u2019action get de la ressource products Exception Strategy Mapping Flux fournis par Studio pour configurer les messages d\u2019erreur dans un format HTTP-status-code-friendly","title":"Nouveau Projet de API Management"},{"location":"tp5/#configuration-du-flux-principal","text":"Dans les propri\u00e9t\u00e9s du composant HTTP, d\u00e9finir le Path par: /prod-services/*. Dans le Connector Configuration , cliquer sur l'ic\u00f4ne , puis cliquer sur OK pour valider le host (0.0.0.0) et le port (8081) Remarque Vous pouvez changer ici le port d\u00e9fini par d\u00e9faut, pour \u00e9viter les conflits avec vos microservices. Lancer le projet comme Mule Project . Une APIKit Console s'affiche comme suit: Pour tester votre API, cliquer par exemple sur le bouton GET devant la ressource /products . la Console affichera alors la r\u00e9ponse (le produit Sample Product ), qui a \u00e9t\u00e9 d\u00e9finie comme exemple dans le fichier RAML de d\u00e9part. Pour visualiser le r\u00e9sultat sur le navigateur, taper le chemin de la requ\u00eate comme suit: http://localhost:8081/prod-services/products Vous obtiendrez le r\u00e9sultat suivant:","title":"Configuration du flux principal"},{"location":"tp5/#mapping-de-lapi-avec-votre-microservice-productservice","text":"Pour relier votre API cr\u00e9\u00e9e avec le microservice Proxy (cr\u00e9\u00e9 dans le TP pr\u00e9c\u00e9dent), et qui est d\u00e9ploy\u00e9 \u00e0 l'adresse suivante: http://localhost:9999/product-service/products Supprimer le Set Payload du flow : get:/products:api-config Ajouter un connecteur HTTP dans la partie Source Le configurer comme suit: Path: /prod-services Cliquer sur puis sur OK pour valider le h\u00f4te et port. Ajouter un connecteur HTTP dans la partie Process Le configurer comme suit: Devant Connector Configuration , cliquer sur pour ajouter une nouvelle configuration. Cela repr\u00e9sente les informations du service auquel on va acc\u00e9der. D\u00e9finir le Host par localhost , le port par 9999 , et le base path par /product-service Cliquer sur OK pour valider Dans la partie URL Settings , d\u00e9finir : Path: /products Method: Get Sauvegarder, et lancer le service. Tester le service sur le navigateur avec l'URL: http://localhost:8081/prod-services . Vous obtiendrez la liste compl\u00e8te des produits, tels que retourn\u00e9s par le service ProductService initial, comme suit: { \"_embedded\" : { \"products\" : [ { \"name\" : \"Pencil\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/1\" } } }, { \"name\" : \"Book\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/2\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/2\" } } }, { \"name\" : \"Eraser\" , \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products/3\" }, \"product\" : { \"href\" : \"http://localhost:9999/product-service/products/3\" } } } ] }, \"_links\" : { \"self\" : { \"href\" : \"http://localhost:9999/product-service/products{?page,size,sort}\" , \"templated\" : true }, \"profile\" : { \"href\" : \"http://localhost:9999/product-service/profile/products\" }, \"search\" : { \"href\" : \"http://localhost:9999/product-service/products/search\" } }, \"page\" : { \"size\" : 20 , \"totalElements\" : 3 , \"totalPages\" : 1 , \"number\" : 0 } }","title":"Mapping de l'API avec votre microservice ProductService"},{"location":"tp5/#transformation-du-resultat-du-microservice-productservice","text":"Si vous d\u00e9sirez retourner un r\u00e9sultat diff\u00e9rent du Microservice initial, en ne laissant par exemple que les noms des produits, sans tous les autres \u00e9l\u00e9ments et liens suppl\u00e9mentaires, utiliser un objet Transform Message Copier le flow get:/products pour cr\u00e9er un autre flow identique Modifier le Path du connecteur HTTP source, pour /prod-services/names Rajouter un objet Transform Message juste apr\u00e8s le connecteur HTTP de droite (celui de la partie Process). Le flow devra ressembler \u00e0 ce qui suit: Configurer l'objet Transform Message : L'interface suivante repr\u00e9sente les mappings \u00e0 faire entre les entr\u00e9es du service et sa sortie. Cliquer sur Define Metadata du payload en entr\u00e9e (\u00e0 gauche) gauche) Cliquer sur Add Entrer le nom du type en entr\u00e9e, par exemple products Indiquer comme type JSON Indiquer dans la liste d\u00e9roulante suivante que le fichier donn\u00e9 est un Example , puis choisir le fichier products-example.json que vous aviez cr\u00e9\u00e9. Cliquer sur Select. Le sch\u00e9ma du fichier donn\u00e9 est charg\u00e9 dans la partie Input de Transform Message . Pour repr\u00e9senter le format de sortie d\u00e9sir\u00e9, cr\u00e9er un fichier appel\u00e9 names.json \u00e0 l'endroit de votre pr\u00e9f\u00e9rence sur votre ordinateur. Saisir le contenu suivant dans names.json : { \"name\" : \"prod\" } Cliquer sur Define Metadata de sortie (\u00e0 droite). Ajouter un nouveau type que vous appellerez names D\u00e9finir comme type Json et charger le fichier names.json que vous venez de cr\u00e9er. Valider. Maintenant que les deux sch\u00e9mas (entr\u00e9e et sortie) sont d\u00e9finis, cr\u00e9er les associations de votre choix. Dans notre cas, nous allons associer le champ _embedded.products.name en entr\u00e9e au champ name en sortie, comme suit: Sauvegarder, et lancer le service. Pour tester le service, lancer dans un navigateur: http://localhost:8081/prod-services/names . Vous obtiendrez le r\u00e9sultat suivant: { \"name\" : [ \"Pencil\" , \"Book\" , \"Eraser\" ] }","title":"Transformation du r\u00e9sultat du microservice ProductService"},{"location":"slides/intro/","text":"Additional Documentation Some references...","title":"Intro"},{"location":"slides/template/","text":"Additional Documentation Some references...","title":"Template"}]}